This is a sophisticated implementation. You have correctly integrated the procedural texture generation (the "Asphalt" noise) and the multi-material logic.

However, there are two critical issues and one major geometry pitfall that need to be addressed before this is production-ready.

1. The Performance/Memory Leak (Critical)

Currently, you are recreating the materials array and cloning textures every time dimensions change.
If dimensions are linked to a UI slider or a drag handle, this runs 60 times a second.

rockNormalMap?.clone() creates a new GPU texture instance.

This will cause a massive memory leak and likely crash the browser after a few seconds of resizing the base.

The Fix: Create the materials once, then update their properties (uniforms/repeat) imperatively in a useEffect.

2. The RoundedBoxGeometry Material Index Problem

Standard three.js RoundedBoxGeometry does not support multi-materials out of the box. It treats the entire mesh as one surface (Material Index 0).

The Result: Your base will likely render entirely with the "Right Side" material, meaning the Top will be rough Rock Pitch instead of Polished.

The Fix: You must manually compute the "Groups" for the geometry to tell Three.js which triangles belong to which face. I have included a helper function to do this automatically.

3. Texture Cleanup

The rockNormalMap creates a CanvasTexture but never disposes of it. This causes GPU memory leaks when toggling between finishes.

The Refactored Solution

Here is the corrected BaseMesh component and the helper function. Replace your existing BaseMesh with this:

code
Tsx
download
content_copy
expand_less
// Helper to fix Multi-Material support on RoundedBoxGeometry
function fixRoundedBoxUVs(geometry: THREE.BufferGeometry) {
  // Check if position attribute exists
  if (!geometry.attributes.position) return;
  
  // Compute groups for materials 0-5
  geometry.clearGroups();
  
  const position = geometry.attributes.position;
  const normal = geometry.attributes.normal;
  const count = position.count;
  
  // We need to loop through faces (groups of 3 vertices)
  // This is a simplified approach: we look at the face normal to determine the side
  // 0: Right (+x), 1: Left (-x), 2: Top (+y), 3: Bottom (-y), 4: Front (+z), 5: Back (-z)
  
  let currentGroupStart = 0;
  let currentGroupCount = 0;
  let currentMaterialIndex = -1;

  // Note: This relies on the internal construction order of RoundedBoxGeometry.
  // A more robust way is to dot-product the normals, but usually RoundedBox builds faces in order.
  
  // However, for a generic fix without assuming vertex order, 
  // we can just treat the whole object. 
  // BUT, since RoundedBox usually doesn't set groups, we face a problem.
  // 
  // SIMPLER FIX: 
  // RoundedBoxGeometry usually projects normals correctly. 
  // If we can't easily patch groups, use BoxGeometry for multi-material, 
  // OR use a BoxGeometry and normal-map the bevels (too hard).
  //
  // Let's try the "Normal Direction" grouping strategy:
  
  // Since we are using an indexed geometry, we loop indices
  const index = geometry.index;
  if(!index) return; // Should be indexed

  // Iterate over triangles
  for (let i = 0; i < index.count; i += 3) {
    const a = index.getX(i);
    // Get normal of first vertex in triangle
    const nx = normal.getX(a);
    const ny = normal.getY(a);
    const nz = normal.getZ(a);
    
    let matIdx = 0;

    // Determine dominant axis
    if (Math.abs(nx) > Math.abs(ny) && Math.abs(nx) > Math.abs(nz)) {
      matIdx = nx > 0 ? 0 : 1; // Right : Left
    } else if (Math.abs(ny) > Math.abs(nx) && Math.abs(ny) > Math.abs(nz)) {
      matIdx = ny > 0 ? 2 : 3; // Top : Bottom
    } else {
      matIdx = nz > 0 ? 4 : 5; // Front : Back
    }

    // Add group for this triangle
    // Note: This creates many small groups, but it's accurate for bevels
    geometry.addGroup(i, 3, matIdx);
  }
}

function BaseMesh({
  baseRef,
  baseTexture,
  onClick,
  name,
  dimensions,
  finish,
}: {
  baseRef: React.RefObject<THREE.Mesh | null>;
  baseTexture: THREE.Texture;
  onClick?: (e: any) => void;
  name?: string;
  dimensions: { width: number; height: number; depth: number };
  finish: 'default' | 'rock-pitch';
}) {
  // 1. Generate Normal Map (Memoized & Disposed)
  const rockNormalMap = React.useMemo(() => {
    if (finish !== 'rock-pitch') return null;
    
    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    
    // ... [Your Asphalt Noise Logic Here] ...
    // (Keep the exact logic you wrote, it is correct)
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;
    const asphaltNoise = (x: number, y: number) => {
       // ... paste your existing noise function ...
       let total = 0;
        let amplitude = 1;
        let frequency = 1;
        const maxAmplitude = 1.875;
        for (let i = 0; i < 4; i++) {
          const nx = x * frequency * 0.15;
          const ny = y * frequency * 0.15;
          const val = Math.sin(nx * 5.3 + 17) * Math.cos(ny * 4.7 + 23) + 
                      Math.sin(nx * 7.1 - ny * 3.9 + 41) * Math.cos(nx * 6.2 + ny * 5.8) * 0.8 +
                      Math.sin((nx + ny) * 8.7 + 61) * 0.6;
          total += val * amplitude;
          amplitude *= 0.5;
          frequency *= 2.1;
        }
        return total / maxAmplitude;
    };

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        const baseNoise = asphaltNoise(x, y) * 20;
        const fineGrain = (Math.random() - 0.5) * 18;
        const totalValue = baseNoise + fineGrain;
        const nx = Math.max(0, Math.min(255, 128 + totalValue));
        const ny = Math.max(0, Math.min(255, 128 + totalValue * 0.92));
        const nz = Math.max(0, Math.min(255, 200 + Math.abs(totalValue) * 0.25));
        data[idx] = nx; data[idx + 1] = ny; data[idx + 2] = nz; data[idx + 3] = 255;
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    // We do NOT set anisotropy here, we do it in the material usage
    
    return texture;
  }, [finish]);

  // Cleanup texture on unmount
  React.useEffect(() => {
    return () => {
      rockNormalMap?.dispose();
    };
  }, [rockNormalMap]);

  // 2. Manage Texture Settings
  React.useLayoutEffect(() => {
    if (baseTexture) {
      baseTexture.wrapS = THREE.RepeatWrapping;
      baseTexture.wrapT = THREE.RepeatWrapping;
      const textureScale = 0.15; 
      baseTexture.repeat.set(dimensions.width / textureScale, dimensions.height / textureScale);
      baseTexture.anisotropy = 16;
      baseTexture.needsUpdate = true;
    }
  }, [baseTexture, dimensions.width, dimensions.height]);

  // 3. Create Materials ONCE (Do not depend on dimensions here!)
  const materials = React.useMemo(() => {
    // Shared Polish Material
    const polishedMaterial = new THREE.MeshPhysicalMaterial({
      map: baseTexture,
      color: 0x888888,
      metalness: 0.0,
      roughness: 0.15,
      envMapIntensity: 1.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
    });

    if (finish === 'rock-pitch' && rockNormalMap) {
      // Clone texture ONCE here for the materials
      const texShort = rockNormalMap.clone();
      const texLong = rockNormalMap.clone();
      
      const matShort = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texShort, // Right/Left
        normalScale: new THREE.Vector2(3, 3), 
        color: 0x555555, 
        metalness: 0.0,
        roughness: 0.7, 
        envMapIntensity: 1.0, 
      });

      const matLong = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texLong, // Front/Back
        normalScale: new THREE.Vector2(3, 3), 
        color: 0x555555, 
        metalness: 0.0,
        roughness: 0.7, 
        envMapIntensity: 1.0, 
      });

      return [matShort, matShort, polishedMaterial, polishedMaterial, matLong, matLong];
    }
    
    return polishedMaterial;
  }, [baseTexture, finish, rockNormalMap]); // NO DIMENSIONS DEPENDENCY

  // 4. Update Material Repeats Imperatively (Performance Fix)
  React.useLayoutEffect(() => {
    if (Array.isArray(materials) && finish === 'rock-pitch') {
      const density = 5; 
      const [matRight, matLeft, , , matFront, matBack] = materials as THREE.MeshStandardMaterial[];
      
      // Update Right/Left (Short sides)
      if (matRight.normalMap) matRight.normalMap.repeat.set(dimensions.depth * density, dimensions.height * 1);
      
      // Update Front/Back (Long sides)
      if (matFront.normalMap) matFront.normalMap.repeat.set(dimensions.width * density, dimensions.height * 1);
    }
  }, [materials, dimensions, finish]);

  // 5. Geometry Logic
  const geometry = React.useMemo(() => {
    if (finish === 'rock-pitch') {
      const geo = new RoundedBoxGeometry(1, 1, 1, 8, 0.05);
      // CRITICAL: Apply the group fix so multi-material works
      fixRoundedBoxUVs(geo);
      return geo;
    }
    return new THREE.BoxGeometry(1, 1, 1);
  }, [finish]);

  return (
    <mesh
      ref={baseRef}
      name={name}
      onClick={onClick}
      castShadow
      receiveShadow
      geometry={geometry} // Pass memoized geometry
      onUpdate={(self) => self.geometry.computeBoundingBox()}
    >
      {/* Use primitive for materials to allow array or single */}
       {Array.isArray(materials) ? (
        materials.map((mat, i) => (
          <primitive key={i} object={mat} attach={`material-${i}`} />
        ))
      ) : (
        <primitive object={materials} attach="material" />
      )}
    </mesh>
  );
}
Key Changes Made:

Removed dimensions from useMemo(materials): This stops the code from destroying and recreating 6 materials (and cloning 2 textures) every single frame that the user resizes the base.

Added useLayoutEffect: This efficiently updates the .repeat property on the existing textures when dimensions change.

Added fixRoundedBoxUVs: This function runs once when the geometry is created. It analyzes the normals of the rounded box and assigns the correct material index (0-5) to each triangle. Without this, your polished top would likely disappear.

Added Texture Disposal: rockNormalMap?.dispose() ensures we don't leak GPU memory.