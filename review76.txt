Short answer: your base is being laid out outside the headstone’s own layout context and sized from the *mask/container width*, not from the rendered headstone width. That’s why it keeps floating and why its width looks “too wide” on the right. Fix = make the base a sibling of the headstone **inside one positioned wrapper**, measure the headstone’s rendered width, and size/position the base from that measurement (not from the page/mask).

Here’s a drop-in pattern you can use in your page (replace your current base render with this). It stacks the two elements, keeps them centered, and derives the base width/height from the stone’s actual render box, with a controlled overlap.

```tsx
function StoneWithBase({
  stoneSvg,                 // string: the headstone SVG text or src
  baseTexUrl,               // string: the base texture url
  stoneToBaseWidthRatio=1,  // number: base width / stone width (from JSON)
  baseAspect=0.22,          // number: baseHeight = baseWidth * baseAspect (from JSON)
  overlapPx=10              // number: how much the base tucks under the stone
}: {
  stoneSvg: string;
  baseTexUrl: string;
  stoneToBaseWidthRatio?: number;
  baseAspect?: number;
  overlapPx?: number;
}) {
  const wrapRef = React.useRef<HTMLDivElement>(null);
  const stoneRef = React.useRef<HTMLDivElement>(null);
  const [sizes, setSizes] = React.useState<{stoneW:number;baseW:number;baseH:number}>({stoneW:0, baseW:0, baseH:0});

  React.useLayoutEffect(() => {
    const update = () => {
      if (!stoneRef.current) return;
      const rect = stoneRef.current.getBoundingClientRect();
      const stoneW = rect.width;
      const baseW  = Math.round(stoneW * stoneToBaseWidthRatio);
      const baseH  = Math.round(baseW * baseAspect);
      setSizes({ stoneW, baseW, baseH });
    };
    update();
    const ro = new ResizeObserver(update);
    if (wrapRef.current) ro.observe(wrapRef.current);
    if (stoneRef.current) ro.observe(stoneRef.current);
    return () => ro.disconnect();
  }, [stoneToBaseWidthRatio, baseAspect]);

  return (
    <div
      ref={wrapRef}
      className="relative mx-auto"
      style={{
        display: 'inline-block',
        // Give room for the base below the stone; account for the little overlap
        paddingBottom: Math.max(0, sizes.baseH - overlapPx),
      }}
    >
      {/* Headstone */}
      <div ref={stoneRef} style={{ position: 'relative', zIndex: 2 }}>
        {/* however you render your SVG */}
        <img src={stoneSvg} alt="Headstone" style={{ display:'block', maxWidth:'100%', height:'auto' }}/>
      </div>

      {/* Base – sized from the stone’s rendered width, centered, and tucked under */}
      {sizes.baseW > 0 && (
        <div
          style={{
            position: 'absolute',
            left: '50%',
            top: `calc(100% - ${overlapPx}px)`,
            transform: 'translateX(-50%)',
            width: `${sizes.baseW}px`,
            height: `${sizes.baseH}px`,
            zIndex: 1,               // sits behind the stone edge
            overflow: 'hidden',
            borderRadius: 2,
            boxShadow: '0 2px 8px rgba(0,0,0,.25)',
          }}
        >
          <img
            src={baseTexUrl}
            alt="Base"
            style={{ width:'100%', height:'100%', objectFit:'cover', display:'block' }}
          />
        </div>
      )}
    </div>
  );
}
```

### Why this solves your two symptoms

1. **“Base too wide”**
   Previously, the base width was computed against the outer mask / page width. Now it’s set to `stoneWidth * stoneToBaseWidthRatio`. If your JSON says the base should match the stone, pass `stoneToBaseWidthRatio = 1`. If it should be 1.2× the stone, set `1.2`, etc. This makes width deterministic and identical across DPR/devices.

2. **“Base floating / covering the stone”**
   Making both elements children of a single `relative` wrapper and absolutely positioning the base with `left:50%` + `translateX(-50%)` guarantees a centered, under-stone placement. The `paddingBottom` reserves space so it never “floats away” in normal flow, and `overlapPx` lets you tuck it slightly under the tablet edge without covering inscriptions (z-index keeps the stone on top).

### Hook-up hints

* Pull the ratio and aspect from your design data:

  ```ts
  const headstone = designData.find((i:any)=>i.type==='Headstone');
  const base      = designData.find((i:any)=>i.type==='Base');

  const ratio = base && headstone ? (base.width / headstone.width) : 1;
  const aspect = base ? (base.height / base.width) : 0.22; // fallback
  ```

* Then render:

  ```tsx
  <StoneWithBase
    stoneSvg={stoneSvgUrlOrData}
    baseTexUrl={baseTextureUrl}
    stoneToBaseWidthRatio={ratio}
    baseAspect={aspect}
    overlapPx={12}
  />
  ```

* If you draw the stone from raw SVG text, you can keep using your existing “contain” logic. The measurement is taken from the *final rendered box* (`getBoundingClientRect()`), so it remains correct regardless of DPR/cropping.

This approach removes the DPR/mask coupling from the base entirely and binds it to the only thing that matters visually: the *actual rendered stone*. It also prevents the base from ever “drifting” because both items now live in the same positioning context.

If you want, I can adapt this straight into your `DesignPageClient.tsx` around the place where you render the stone and base. 
