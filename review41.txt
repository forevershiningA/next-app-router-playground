Great—sizes are right and your last screenshot shows they’re close.
**Next:** snap the *top* motifs to the stone’s curved edge so they always sit a fixed margin below the outline (instead of using a constant vPad).

### What to add

1. **Precompute the headstone’s top profile** in authoring pixels (initW×initH).
2. **When mapping motifs**, if a motif is in the upper band, move it so its **bbox top = profileY(x) + margin**.

### Drop-in code (DesignPageClient.tsx)

Add this utility (once, near your other helpers):

```ts
// Build a per-column "top Y" look-up of the rendered headstone
async function buildTopProfile(svgText: string, initW: number, initH: number) {
  const vbMatch = svgText.match(/viewBox\s*=\s*"([\d.\s-]+)"/i);
  const [, vbStr] = vbMatch || [, `0 0 ${initW} ${initH}`];
  const [ , , vbWStr, vbHStr ] = vbStr.split(/\s+/);
  const vbW = parseFloat(vbWStr) || initW;
  const vbH = parseFloat(vbHStr) || initH;

  // Fit like your shape renderer (contain)
  const scale = Math.min(initW / vbW, initH / vbH);
  const drawW = vbW * scale;
  const drawH = vbH * scale;
  const offX = (initW - drawW) / 2;
  const offY = (initH - drawH) / 2;

  // Paint the SVG into a canvas
  const blob = new Blob([svgText], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const img = await new Promise<HTMLImageElement>((res, rej) => {
    const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = url;
  });

  const c = document.createElement('canvas'); c.width = initW; c.height = initH;
  const g = c.getContext('2d')!;
  g.clearRect(0,0,initW,initH);
  g.drawImage(img, offX, offY, drawW, drawH);
  URL.revokeObjectURL(url);

  // For each column x, find first opaque pixel (top edge inside stone)
  const topY: number[] = new Array(initW).fill(initH);
  const imgData = g.getImageData(0, 0, initW, initH).data;
  for (let x = 0; x < initW; x++) {
    for (let y = 0; y < initH; y++) {
      const a = imgData[(y * initW + x) * 4 + 3];
      if (a > 8) { topY[x] = y; break; }
    }
  }
  return { topY, offX, offY, drawW, drawH, scale };
}
```

When you already fetch/store the headstone SVG text, build the profile once:

```ts
// after you set svgContent + screenshotDimensions:
useEffect(() => {
  (async () => {
    if (!svgContent || !screenshotDimensions) return;
    const { width: initW, height: initH } = screenshotDimensions;
    const prof = await buildTopProfile(svgContent, initW, initH);
    setTopProfile(prof); // create a useState for this
  })();
}, [svgContent, screenshotDimensions]);
```

Then, inside your **Motifs layer mapping** (where you compute `left/top`), replace the simple top-nudge with curvature snap:

```ts
// Inputs already available in your component:
// overlayW/H, offsetX/offsetY, sx/sy, initW/initH, motifPxW/motifPxH, cx, cy, ...
// plus: topProfile { topY, offX, offY, scale } from state.

let cyUsed = cy;

// Only affect "top band" motifs
const isTopBand = cy < -initH * 0.15;  // tweak band depth
if (topProfile && isTopBand) {
  // current screen X of motif center (overlay pixel space)
  const screenX = offsetX + overlayW / 2 + cx * sx;
  const col = Math.max(0, Math.min(initW - 1, Math.round(
    // convert overlay pixel X back to authoring pixel X
    (screenX - offsetX) * (initW / overlayW)
  )));
  // y of stone top at that column in authoring pixels
  const yTopAuthor = topProfile.topY[col];

  // desired bbox top (authoring px) with a safe margin below stone edge
  const marginPx = 10; // tune 8–16px
  const desiredTopAuthor = yTopAuthor + marginPx;

  // current motif bbox top in authoring px:
  // overlay center Y → authoring Y, then minus half motif height (authoring)
  const overlayCenterY = offsetY + overlayH / 2 + cy * sy;
  const authorCenterY = (overlayCenterY - offsetY) * (initH / overlayH);
  const motifHAuthor = (motifPxH * initH) / overlayH;
  const currentTopAuthor = authorCenterY - motifHAuthor / 2;

  // required delta in authoring px → convert back to cy space
  const deltaAuthor = desiredTopAuthor - currentTopAuthor;
  const deltaOverlay = deltaAuthor * (overlayH / initH);
  const deltaCy = deltaOverlay / sy;
  cyUsed = cy + deltaCy;
}

// now compute final left/top with cyUsed
const left = offsetX + overlayW / 2 + cx * sx;
const top  = offsetY + overlayH / 2 + cyUsed * sy;
```

**Why this works**

* We measure the stone’s **actual top curve** after the same fit you use to render it, so the result is device- and DPR-agnostic.
* Each top motif’s **bbox top** is pinned to `curveY + margin`, keeping it visually “hugging” the curved gable even when sizes/textures change.
* Lower/central motifs remain untouched.

If you prefer a simpler first pass, keep your vPad nudge and just replace the `isTopBand` condition with a tighter band (e.g., `cy < -initH*0.2`) and increase `marginPx` until it visually matches the reference.

Shout if you want me to splice this directly into your Motifs block in **DesignPageClient.tsx**—I can point to the exact lines where you log `MOTIF v…` and apply it there. 
