Short answer: your child wrapper is rotating, but your children likely aren’t “living” on the slanted plane. They’re being placed on a flat Z-slice and/or a child component is re-orienting itself (billboarding / lookAt / Html). Fix two things:

## 1) Align the child wrapper to the **actual front plane** (not just “rotate by angle”)

Instead of `rotation-x={-slantAngleRad}`, build a quaternion that points the group’s local +Z toward the front-face normal, and place the wrapper **on** the bottom-front edge so z-offsets are measured along the face normal. Patch in your `slant` branch where you return `childWrapperPos/Rotation`:

```ts
// --- after computing frontTopZOffset, height_svg_units ---
const slantAngleRad = Math.atan2(frontTopZOffset, height_svg_units);

// Front face normal in geometry space (before scaling):
//   face tilts backward: normal has +Z at bottom → rotate around +X by -angle
const frontNormal = new THREE.Vector3(0, Math.sin(-slantAngleRad), Math.cos(-slantAngleRad)).normalize();

// Build quaternion that rotates local +Z (0,0,1) to `frontNormal`
const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), frontNormal);

// Put wrapper origin on the **bottom–front** center line of the stone (Y=0 plane):
const wrapperPos: [number, number, number] = [0, 0, (depth / 2) * scale * sCore];

// Report a tiny front offset in **local Z** (now equals face normal)
const frontEpsilon = 0.001;

// In the returned object:
childWrapperPos: wrapperPos,
childWrapperRotation: [0, 0, 0],        // use quaternion below in JSX instead
apiData: {
  frontZ: frontEpsilon,
  // ...
}
```

Then in JSX, apply the quaternion:

```tsx
<group
  ref={scaledWrapperRef}
  position={childWrapperPos}
  // remove rotation-x prop
  // apply quaternion so +Z is the face normal
  quaternion={q}
/>
```

Now anything you put at `z = api.frontZ` inside that wrapper sits **on** the slanted face; positive Z moves “out of stone” along the face normal. (You already pass `worldHeight` = slant height, which is perfect for mapping inscriptions along Y.)

## 2) Stop children from undoing the rotation

Check your inscription/motif/addition components for any of these patterns and disable them:

* `<Billboard>` / `<Text billboard />` / `<Html transform={false} />`
* `meshRef.current.lookAt(camera.position)` in a `useFrame`
* Any code resetting `rotation` or `quaternion` every render

Use:

* drei `<Text>` **without** `billboard`
* drei `<Html transform />` (transform must be **true**) so it respects parent transforms
* No `lookAt` calls

If you must keep billboarding somewhere (e.g., UI gizmos), wrap **those** in a separate group, not under the slant wrapper.

## 3) (Optional) put the wrapper pivot on the **front plane**

For precise hit-testing and intuitive authoring, set the wrapper pivot to the **bottom-front plane** center, not the scene origin. You already do `position: [0,0,depth/2*scale*sCore]`; with the quaternion applied, that pivot now lies on the face edge, so local (x,y) match the stone’s front plane and local +Z is the face normal.

With those two changes, the inscriptions/motifs will visibly tilt with the slant and sit flush to the face. If they still look “upright,” you’ll find a billboarding/`lookAt` somewhere in the child components overriding the parent transform. 
