Yes, there are several "heavy" operations in your current scene that we can optimize without losing visual quality.

Here are the specific optimizations applied in the code below:

Shadow Optimization (The biggest impact):

Directional Light: Reduced shadow map size from 2048 to 1024. You rarely need 2k shadows for a soft outdoor scene.

ContactShadows: Reduced resolution to 256 (from 512). Since it's blurred anyway, high resolution is wasted processing power.

ContactShadows Refresh Rate: Added frames={1}. This is massive. It calculates the shadow once and bakes it into a texture. Since the headstone mostly rotates in place, the shadow on the ground doesn't need to be recalculated 60 times a second.

Texture Optimization:

Capped Anisotropy: Instead of gl.capabilities.getMaxAnisotropy() (which might be 16x), I capped it at 8. This reduces the workload on the GPU texture sampler significantly while keeping the grass sharp.

Environment Optimization:

Added resolution={256} to the <Environment />. Since you are blurring it (blur={1}), you don't need to download and process a 4K HDR image. A tiny 256px version looks exactly the same when blurred.

Cloud Optimization:

Drastically reduced cloud segments (from 40 to 10). Volumetric clouds create "overdraw" (transparency on top of transparency), which kills framerate. Reducing segments makes them much faster.

Adaptive Resolution:

Added <AdaptiveDpr />. This automatically lowers the visual quality slightly while you are rotating the camera, ensuring smooth 60fps movement, and snaps back to high quality when you stop.

1. Optimized Scene.tsx
code
Tsx
download
content_copy
expand_less
'use client';
import { OrbitControls, Environment, ContactShadows, useTexture, Sparkles, AdaptiveDpr } from '@react-three/drei';
import * as THREE from 'three';
import HeadstoneAssembly from './headstone/HeadstoneAssembly';
import AtmosphericSky from './AtmosphericSky';
import { useHeadstoneStore } from '#/lib/headstone-store';
import { useFrame, useThree } from '@react-three/fiber';
import { useRef, Suspense, useEffect, useMemo } from 'react';

const GRASS_COLOR = '#ffffff'; 
const FOG_COLOR = '#e8e8e8';

function GrassFloor() {
  const gl = useThree((state) => state.gl);
  
  const props = useTexture({
    map: '/textures/grass_color.jpg',
    normalMap: '/textures/grass_normal.jpg',
    aoMap: '/textures/grass_ao.jpg',
  });

  const REPEAT_SCALE = 40;

  useEffect(() => {
    // OPTIMIZATION: Cap anisotropy at 8. 
    // Going to 16 (max) is expensive and rarely noticeable on grass.
    const anisotropy = Math.min(gl.capabilities.getMaxAnisotropy(), 8);

    [props.map, props.normalMap, props.aoMap].forEach((tex) => {
      if (tex) {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = anisotropy;
        tex.needsUpdate = true;
      }
    });
  }, [props, gl]);

  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        <meshStandardMaterial 
          map={props.map}
          normalMap={props.normalMap}
          aoMap={props.aoMap}
          color={GRASS_COLOR}
          roughness={1}
          normalScale={new THREE.Vector2(0.5, 0.5)}
          metalness={0}
          envMapIntensity={0}
          fog={true}
        />
      </mesh>
      
      {/* OPTIMIZATION: Reduced resolution and set frames={1} to bake the shadow once */}
      <ContactShadows
        position={[0, 0.02, 0]}
        scale={15}
        blur={2.5}
        opacity={0.6}
        far={1.5}
        color="#001100"
        resolution={256} // Reduced from 512
        frames={1}       // Bake shadow once. Remove if shadow MUST move with rotation.
      />
    </group>
  );
}

// Fallback
function SimpleGrassFloor() {
  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        <meshStandardMaterial 
          color="#355c18"
          roughness={1}
          metalness={0}
          envMapIntensity={0}
        />
      </mesh>
      <ContactShadows position={[0, 0.02, 0]} scale={15} blur={2.5} opacity={0.6} far={1.5} color="#001100" resolution={256} frames={1} />
    </group>
  );
}

export default function Scene({ 
  targetRotation = 0,
  currentRotation
}: { 
  targetRotation?: number;
  currentRotation?: React.MutableRefObject<number>;
}) {
  const groupRef = useRef<THREE.Group>(null);
  const is2DMode = useHeadstoneStore((s) => s.is2DMode);
  const baseSwapping = useHeadstoneStore((s) => s.baseSwapping);
  const setSelected = useHeadstoneStore((s) => s.setSelected);
  const setEditingObject = useHeadstoneStore((s) => s.setEditingObject);
  const setSelectedInscriptionId = useHeadstoneStore((s) => s.setSelectedInscriptionId);
  const setSelectedAdditionId = useHeadstoneStore((s) => s.setSelectedAdditionId);
  const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);

  useFrame(() => {
    if (groupRef.current && currentRotation) {
      const diff = targetRotation - currentRotation.current;
      const delta = diff * 0.1;
      
      if (Math.abs(diff) > 0.001) {
        currentRotation.current += delta;
        groupRef.current.rotation.y = currentRotation.current;
      }
    }
  });

  const handleCanvasClick = (e: any) => {
    if (e.eventObject === e.object) {
      setSelected(null);
      setEditingObject('headstone');
      setSelectedInscriptionId(null);
      setSelectedAdditionId(null);
      setSelectedMotifId(null);
    }
  };

  return (
    <>
      {/* OPTIMIZATION: Downgrades quality while moving/rotating to keep 60fps */}
      <AdaptiveDpr pixelated />

      {is2DMode && <color attach="background" args={['#CFE8FC']} />}
      {!is2DMode && <fog attach="fog" args={[FOG_COLOR, 50, 150]} />}
      
      <mesh
        position={[0, 0, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
        onClick={handleCanvasClick}
      >
        <planeGeometry args={[200, 200]} />
        <meshBasicMaterial transparent opacity={0} side={THREE.DoubleSide} />
      </mesh>
      
      {!is2DMode && (
         <Sparkles 
           count={30} // Reduced count slightly
           scale={12}
           size={3}
           speed={0.3}
           opacity={0.4}
           color="#fffee0"
           position={[0, 2, 0]}
         />
      )}
      
      <ambientLight intensity={0.6} color="#ffffff" />
      
      <hemisphereLight
        args={['#fff8e7', '#444444']}
        intensity={0.5}
      />
      
      <spotLight 
        color="#fffce6"
        intensity={2.0}
        angle={0.8}
        penumbra={0.5}
        position={[-10, 15, 10]}
        castShadow
        shadow-bias={-0.0001}
        // OPTIMIZATION: Reduced shadow map size. 2048 is overkill for soft outdoor light.
        shadow-mapSize={[1024, 1024]} 
      />

      <pointLight position={[-5, 2, 5]} intensity={0.5} color="#ffffff" />
      <spotLight color="#ffffff" intensity={2} position={[5, 5, -5]} distance={30} />

      {/* 
        OPTIMIZATION:
        resolution={256}: We are blurring it anyway, so we don't need a high-res HDR.
        This saves massive download size and processing time.
      */}
      <Environment
        preset="city"
        background={false}
        blur={1.0}
        resolution={256} 
        environmentIntensity={0.4}
      />

      <group ref={groupRef}>
        <HeadstoneAssembly />
        <Suspense fallback={<SimpleGrassFloor />}>
          <GrassFloor />
        </Suspense>
      </group>
      
      {!is2DMode && <AtmosphericSky />}

      <OrbitControls
        makeDefault
        enabled={!baseSwapping}
        enableDamping={true}
        dampingFactor={baseSwapping ? 0 : 0.05}
        enableRotate={!is2DMode}
        enableZoom={!is2DMode}
        enablePan={!is2DMode}
        rotateSpeed={0.5}
        zoomSpeed={0.8}
        panSpeed={0.8}
        minPolarAngle={Math.PI / 3.5}
        maxPolarAngle={Math.PI / 2 - 0.05}
      />
    </>
  );
}
2. Optimized AtmosphericSky.tsx

Volumetric clouds are expensive. Reducing the number of segments reduces "overdraw" (pixels drawn on top of each other), which is the #1 killer of performance in Three.js scenes.

code
Tsx
download
content_copy
expand_less
import * as THREE from 'three';
import { Clouds, Cloud } from '@react-three/drei';

const SkyMaterial = {
  uniforms: {
    uColorTop: { value: new THREE.Color('#3b93ff') },    
    uColorBottom: { value: new THREE.Color('#dbecf8') }, 
    uSunPosition: { value: new THREE.Vector3(10, 20, 10) },
  },
  vertexShader: `
    varying vec3 vWorldPosition;
    varying vec2 vUv;
    void main() {
      vUv = uv;
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,
  fragmentShader: `
    uniform vec3 uColorTop;
    uniform vec3 uColorBottom;
    varying vec3 vWorldPosition;
    varying vec2 vUv;

    void main() {
      vec3 direction = normalize(vWorldPosition);
      float y = direction.y; 
      float t = max(0.0, (y + 0.15) * 0.8);
      t = pow(t, 0.6);
      vec3 color = mix(uColorBottom, uColorTop, t);
      float noise = fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453);
      color += (noise - 0.5) * 0.01;
      gl_FragColor = vec4(color, 1.0);
    }
  `
};

export default function AtmosphericSky() {
  return (
    <group>
      {/* Sky Dome - Cheap to render */}
      <mesh scale={[-1, 1, 1]}>
        <sphereGeometry args={[60, 32, 32]} /> {/* Reduced segments from 64 to 32 */}
        <shaderMaterial
          attach="material"
          args={[SkyMaterial]}
          side={THREE.BackSide}
        />
      </mesh>

      {/* 
        OPTIMIZATION:
        Reduced segments from 40 -> 10. 
        Volumetric clouds are very expensive (fill rate). 
        Lowering segments makes them render much faster with barely noticeable difference in the background.
      */}
      <Clouds material={THREE.MeshBasicMaterial}>
        <Cloud 
          seed={10} 
          bounds={[50, 6, 50]} 
          segments={10} 
          volume={8} 
          color="#ffffff"
          opacity={0.6} 
          position={[0, 10, -10]} 
          speed={0.1} 
        />
        <Cloud 
          seed={20} 
          bounds={[50, 6, 50]} 
          segments={10} 
          volume={8} 
          color="#ffffff" 
          opacity={0.4} 
          position={[0, 15, 0]} 
          speed={0.05} 
        />
      </Clouds>
    </group>
  );
}