You’re right on both counts:

1. the **base** is being laid out outside the same coordinate system as the headstone, so it’s not sharing the same centering/scale;
2. the **SEHOVIC/top motifs** are anchored by their *top* instead of their *center* relative to the headstone’s top-edge profile.

Here are focused fixes you can drop into `DesignPageClient.tsx`.

---

### 1) Keep the base in the same canvas (same scale, same center)

**Problem**: Base `<div>` is rendered in normal document flow, not in the scaled/centered overlay used for the stone; that’s why it drifts and keeps the “mask width”.

**Fix (structure & CSS):** wrap stone + base in one relative canvas and absolutely position both with the same `uniformScale`, `offX`, `offY`, and `drawW`. Use the headstone’s logical width to derive the base width.

```tsx
// inside your preview render where you already know: initW, initH, offX, offY, drawW, drawH, scale
<div
  className="relative"
  style={{ width: initW, height: initH }}   // logical canvas
>
  {/* Headstone SVG (already drawn using offX/offY/drawW/drawH) */}
  <div
    className="absolute left-0 top-0"
    style={{ width: initW, height: initH }}
  >
    {/* your existing svgHostRef renderer */}
    <div ref={svgHostRef} />
  </div>

  {/* Base – use same coordinate space */}
  {base && (
    <div
      className="absolute"
      style={{
        left: offX + (drawW - baseDisplayWidth) / 2, // center under stone
        top: offY + drawH - overlapPx,               // tuck under edge
        width: baseDisplayWidth,
        height: baseDisplayHeight,
        zIndex: 0,
        pointerEvents: 'none',
        backgroundImage: `url(${base.textureUrl})`,
        backgroundSize: 'cover',
      }}
    />
  )}
</div>
```

**Derive display size from JSON, not mask width:**

```ts
// mm from your JSON (examples)
const headWmm = headstoneItem.width ?? 600;
const baseWmm  = baseItem.width ?? 900;
const baseHmm  = baseItem.height ?? 100;

// pixels under current draw
const pxPerMm = drawW / headWmm;
const baseDisplayWidth  = baseWmm * pxPerMm;
const baseDisplayHeight = baseHmm * pxPerMm;

// slight overlap so the joint looks natural
const overlapPx = Math.round(8 * scale);
```

That centers the base and keeps its width proportional to the stone every time, eliminating the “too wide/too short” & “floated away” issues. 

---

### 2) Anchor the family name & top motifs to the **curve start** using *center-Y*

You already compute a `topProfile` (with `topY`, `offX`, `offY`, `drawW`, `scale`). Use it to place the family name (and any crown motif) so that the text’s **center** sits at the curve start + padding.

**Fix (placement math):**

```ts
function placeAtCurveStartCenter(xCenterCanvasPx: number, textPxHeight: number, padPx = 10) {
  if (!topProfile) return { x: xCenterCanvasPx, y: padPx };
  const xInDraw = Math.round(xCenterCanvasPx);                 // column in logical canvas
  const yCurveCanvas = topProfile.topY[xInDraw] ?? 0;          // curve start in canvas px
  // We want the *center* of the line at the curve start + padding:
  const yCenter = yCurveCanvas + padPx + textPxHeight / 2;
  return { x: xCenterCanvasPx, y: yCenter };
}
```

**Where you compute the title position:**

```ts
const xCenter = initW / 2;
const titlePxHeight = measuredTitleHeightPx; // from your text measurement
const { x: titleX, y: titleY } = placeAtCurveStartCenter(xCenter, titlePxHeight, Math.round(12 * topProfile.scale));

// Apply in the draggable/absolute style:
const titleStyle: React.CSSProperties = {
  position: 'absolute',
  left: titleX,
  top: titleY,
  transform: 'translate(-50%, -50%)',   // <- keep center origin
  // ...font etc.
};
```

Do the same for the leaf-and-birds motif row if you want it to “stick” to the curve: compute its own `motifPxHeight` and call `placeAtCurveStartCenter` with a slightly larger `padPx`.

This switches from “top-anchored” to **center-anchored** placement against the detected curve, which is why SEHOVIC currently sits too low—your code is using the curve Y as if it were the text’s top, not its middle. 

---

### 3) One common gotcha to check

Make sure your draggable wrappers **only** have a single centering translate and then append the drag delta (your component currently does this correctly):

```ts
transform: `${initialStyle.transform ?? 'translate(-50%, -50%)'} translate(${dx}px, ${dy}px)`
```

If a second `translate(-50%, -50%)` sneaks in, everything will misalign vertically against the curve. 

---

### Quick test checklist

* Base centers when you resize the stone or switch shapes.
* Base width changes with stone width (mm-accurate).
* Title’s **midline** sits exactly on the curve start + padding at any viewport/DPR.
* Crown motif row tracks the same curve logic.