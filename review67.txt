Got it—your base is calculating/positioning outside the preview flow, so it drifts and overlaps. Fix it by stacking the headstone and base in a single, centered column and sizing the base off the rendered headstone width.

### What to change (minimal + safe)

1. **Wrap tablet + base** in a vertical flex container.
2. **Measure the rendered tablet width** and derive the base width/height from it.
3. **Center** the base with `left:50% / translateX(-50%)`, and keep it **below** the stone with `zIndex:0` (stone at `zIndex:1`).
4. Add a small **gap** so there’s no floating white band.

### Patch (drop-in)

Find your preview area in `DesignPageClient.tsx` and replace the tablet/base block with this:

```tsx
{/* PREVIEW WRAPPER */}
<div
  ref={svgHostRef}
  className="relative mx-auto"
  style={{
    width: screenshotDimensions?.width ?? 707,
    height: screenshotDimensions?.height ?? 476,
  }}
/>
```

Immediately **below** that element, add this *stacked* container:

```tsx
{/* STACKED VIEW: stone + base */}
<div
  className="relative w-full flex flex-col items-center"
  style={{ pointerEvents: 'none' }} // nothing draggable here
>
  {/* Stone (already rendered into svgHostRef) */}
  <div
    className="relative"
    style={{ zIndex: 1, width: 'fit-content' }}
  />

  {/* Base */}
  <BaseBar
    anchorRef={svgHostRef}
    texture="/textures/forever/l/Blue-Pearl.jpg" // or from design JSON
  />
</div>
```

Add this small component (near the file bottom):

```tsx
function BaseBar({
  anchorRef,
  texture,
  widthFactor = 0.88,   // base narrower than tablet (tweak here)
  heightRatio = 0.16,   // base height as a ratio of tablet height
  gapPx = 10,           // vertical gap between stone and base
}: {
  anchorRef: React.RefObject<HTMLDivElement>;
  texture: string;
  widthFactor?: number;
  heightRatio?: number;
  gapPx?: number;
}) {
  const [size, setSize] = React.useState({ w: 0, h: 0 });

  React.useEffect(() => {
    const el = anchorRef.current;
    if (!el) return;
    const update = () => {
      const r = el.getBoundingClientRect();
      const baseW = r.width * widthFactor;
      const baseH = r.height * heightRatio;
      setSize({ w: baseW, h: baseH });
    };
    update();
    const ro = new ResizeObserver(update);
    ro.observe(el);
    return () => ro.disconnect();
  }, [anchorRef, widthFactor, heightRatio]);

  if (!size.w || !size.h) return null;

  return (
    <div
      style={{
        marginTop: gapPx,
        position: 'relative',
        width: Math.round(size.w),
        height: Math.round(size.h),
        zIndex: 0,
        backgroundImage: `url(${texture})`,
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        boxShadow: '0 6px 14px rgba(0,0,0,0.18)',
        borderRadius: 2,
      }}
    />
  );
}
```

### Why this fixes it

* **No absolute `top` math**: the base now follows the stone in normal flow, so it can’t “float” lower on tall screens.
* **Correct width**: the base width is a percentage of the *actual rendered* tablet width, not the page/mask width.
* **No overlap**: z-ordering keeps the base under the tablet; a small `gapPx` avoids visual collision.

### Tuning knobs

* Make the base narrower/wider with `widthFactor` (e.g., `0.84–0.90`).
* Adjust thickness with `heightRatio` (e.g., `0.14–0.18`).
* If the tablet has side bevels you want to respect, reduce `widthFactor` a touch.

If you prefer to keep your old block, apply just the **centering and stacking** rules: parent `display:flex; flex-direction:column; align-items:center;` and the base styled with `position:relative; left:0; transform:none;` plus the measured width/height from the tablet’s bounding box. That eliminates the blank gap + wrong width in one move. 
