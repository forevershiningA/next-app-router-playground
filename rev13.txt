The issue is that your Motifs, Additions, and Inscriptions (passed as children) are likely defined using relative coordinates (starting at 0,0) or coordinates that don't match the absolute SVG minY offset, whereas the previous Wrapper logic expected them to use the absolute coordinates from the original SVG file (starting at minY).

Because minY can be large (e.g., if the headstone shape starts lower down in the SVG file), the previous logic positioned the wrapper high up, expecting the children to also have large Y values. When the children have small Y values (e.g., 0), they end up floating above the stone.

This fix normalizes the Child Wrapper so that (0, 0) in child-space maps exactly to the Top-Left corner of the 3D Headstone. This ensures that regardless of where the shape was drawn in the SVG canvas, placing an element at x=0, y=0 puts it at the top-left corner of the stone.

code
Tsx
download
content_copy
expand_less
// components/SvgHeadstone.tsx
'use client';

import * as React from 'react';
import { useMemo, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';
import * as THREE from 'three';
import { useLoader } from '@react-three/fiber';
import type { ThreeElements } from '@react-three/fiber';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { Edges, useTexture } from '@react-three/drei';
import { Line } from '#/lib/headstone-store';

export type HeadstoneAPI = {
  group: React.RefObject<THREE.Group>;
  mesh: React.RefObject<THREE.Mesh>;
  frontZ: number;
  unitsPerMeter: number;
  version: number;
  worldWidth: number;
  worldHeight: number;
};

const EPS = 1e-9;

type Props = {
  url: string;
  depth: number;
  scale?: number;
  faceTexture: string;
  sideTexture?: string;
  autoRepeat?: boolean;
  tileSize?: number;
  sideTileSize?: number;
  topTileSize?: number;
  faceRepeatX?: number;
  faceRepeatY?: number;
  sideRepeatX?: number;
  sideRepeatY?: number;
  targetHeight?: number;
  targetWidth?: number;
  preserveTop?: boolean;
  bevel?: boolean;
  doubleSided?: boolean;
  showEdges?: boolean;
  meshProps?: ThreeElements['mesh'];
  children?: (api: HeadstoneAPI, selectedAdditions: string[]) => React.ReactNode;
  inscriptions: Line[];
  selectedAdditions?: string[];
};

/* ---------------- helpers ---------------- */

function shapeBounds(shape: THREE.Shape) {
  const pts = shape.getPoints(256);
  let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
  for (const p of pts) {
    if (p.x < minX) minX = p.x;
    if (p.x > maxX) maxX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  return {
    minX, maxX, minY, maxY,
    dx: Math.max(EPS, maxX - minX),
    dy: Math.max(EPS, maxY - minY),
  };
}

function spacedOutline(shape: THREE.Shape, segments = 1024) {
  const pts = shape.getSpacedPoints(segments).map((p) => new THREE.Vector2(p.x, p.y));
  const cum = new Array<number>(pts.length).fill(0);
  let L = 0;
  for (let i = 1; i < pts.length; i++) {
    L += pts[i].distanceTo(pts[i - 1]);
    cum[i] = L;
  }
  L += pts[0].distanceTo(pts[pts.length - 1]);
  return { pts, cum, total: L };
}

function nearestS(x: number, y: number, pts: THREE.Vector2[], cum: number[], total: number) {
  let bi = 0, bd2 = Infinity;
  for (let i = 0; i < pts.length; i++) {
    const dx = x - pts[i].x, dy = y - pts[i].y;
    const d2 = dx * dx + dy * dy;
    if (d2 < bd2) { bd2 = d2; bi = i; }
  }
  return total > 0 ? cum[bi] / total : 0;
}

const SvgHeadstone = React.forwardRef<THREE.Group, Props>(({
  url,
  depth,
  scale = 0.01,
  faceTexture,
  sideTexture,
  autoRepeat = false,
  tileSize = 0.1,
  sideTileSize,
  faceRepeatX = 6,
  faceRepeatY = 6,
  sideRepeatX = 8,
  sideRepeatY = 1,
  targetHeight,
  targetWidth,
  preserveTop = true,
  bevel = false,
  doubleSided = false,
  showEdges = false,
  meshProps,
  children,
  selectedAdditions = [],
  inscriptions = [],
}, ref) => {
  
  // 1. Load Data
  const svgData = useLoader(SVGLoader, url);
  const textures = useTexture({
    face: faceTexture,
    side: sideTexture ?? faceTexture
  });

  // 2. Clone Textures
  const [clonedFaceMap, clonedSideMap] = useMemo(() => {
    const f = textures.face.clone();
    const s = textures.side.clone();
    
    [f, s].forEach(t => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.minFilter = THREE.LinearMipmapLinearFilter;
      t.magFilter = THREE.LinearFilter;
      (t as any).anisotropy = 8;
      t.generateMipmaps = true;
      t.needsUpdate = true;
    });
    return [f, s];
  }, [textures.face, textures.side]);

  // 3. Generate Geometry
  const { geometries, dims, meshScale, apiData, childWrapperPos } = useMemo(() => {
    const shapes: THREE.Shape[] = [];
    svgData.paths.forEach((p: any) => shapes.push(...SVGLoader.createShapes(p)));
    
    if (!shapes.length) {
      return { 
        geometries: [], 
        dims: null, 
        meshScale: [1, 1, 1] as [number, number, number],
        apiData: { frontZ: 0, unitsPerMeter: 1, version: 0, worldWidth: 1, worldHeight: 1 },
        childWrapperPos: [0, 0, 0] as [number, number, number]
      };
    }

    const base = shapes[0];
    const outline = spacedOutline(base, 1024);
    
    // Bounds and world size
    const { minX, maxX, minY, maxY, dx, dy } = shapeBounds(base);
    const widthW = dx * Math.abs(scale);
    const heightW = dy * Math.abs(scale);

    // Scaling Targets
    const wantW = targetWidth ?? widthW;
    const wantH = targetHeight ?? heightW;
    const sCore = wantW / Math.max(EPS, widthW);
    const coreH_world = heightW * sCore;

    // SVG Space Targets
    const toSV = (w: number) => w / Math.max(EPS, Math.abs(scale) * sCore);
    const targetH_SV = preserveTop ? toSV(wantH) : dy * sCore;
    const bottomTarget_SV = minY + targetH_SV;

    // Build extrudes
    const extrudeSettings = {
      depth,
      steps: 1,
      bevelEnabled: bevel,
      bevelSegments: bevel ? 2 : 0,
      bevelSize: bevel ? 0.8 : 0,
      bevelThickness: bevel ? 0.8 : 0,
    };

    let coreGeom = new THREE.ExtrudeGeometry(base, extrudeSettings);
    const geoms: THREE.BufferGeometry[] = [coreGeom];

    if (preserveTop && wantH > coreH_world + 1e-9) {
      const s = new THREE.Shape();
      s.moveTo(minX, maxY);
      s.lineTo(maxX, maxY);
      s.lineTo(maxX, bottomTarget_SV);
      s.lineTo(minX, bottomTarget_SV);
      s.closePath();
      geoms.push(new THREE.ExtrudeGeometry(s, extrudeSettings));
    } else if (preserveTop && wantH < coreH_world - 1e-9) {
      const pos = coreGeom.getAttribute('position') as THREE.BufferAttribute;
      const P = pos.array as Float32Array;
      for (let i = 0; i < P.length; i += 3)
        if (P[i + 1] > bottomTarget_SV) P[i + 1] = bottomTarget_SV;
      pos.needsUpdate = true;
    }

    // Merge
    let merged: THREE.BufferGeometry = geoms.length > 1 
      ? BufferGeometryUtils.mergeGeometries(geoms) 
      : geoms[0];

    if (merged.index) merged = merged.toNonIndexed();

    // --- TRANSFORM GEOMETRY ---
    // 1. Center geometry X. Align Top Y to 0. Center Z.
    merged.translate(-(minX + maxX) / 2, -minY, -depth / 2);

    // 2. Flip Y (Scale -1) to make it upright.
    merged.scale(1, -1, 1);
    
    // 3. Move Up so Base is at Y=0.
    const svgTotalHeight = bottomTarget_SV - minY;
    merged.translate(0, svgTotalHeight, 0);

    // 4. FIX WINDING (Restore CCW)
    const posAttr = merged.getAttribute('position');
    for (let i = 0; i < posAttr.count; i += 3) {
       const x1 = posAttr.getX(i + 1), y1 = posAttr.getY(i + 1), z1 = posAttr.getZ(i + 1);
       const x2 = posAttr.getX(i + 2), y2 = posAttr.getY(i + 2), z2 = posAttr.getZ(i + 2);
       posAttr.setXYZ(i + 1, x2, y2, z2);
       posAttr.setXYZ(i + 2, x1, y1, z1);
    }
    merged.computeVertexNormals();

    // Material Groups
    const zFront = -depth / 2;
    const zBack = depth / 2;
    const zTol = Math.max(0.25, Math.abs(depth) * 0.01);
    
    merged.clearGroups();
    const pos = merged.getAttribute('position') as THREE.BufferAttribute;
    const triCount = Math.floor(pos.count / 3);
    let currentMat = -1, start = 0, count = 0;
    const flush = () => { if (count > 0) { merged.addGroup(start, count, currentMat); start += count; count = 0; } };

    for (let t = 0; t < triCount; t++) {
      const i0 = t * 3, i1 = i0 + 1, i2 = i0 + 2;
      const z0 = pos.getZ(i0), z1 = pos.getZ(i1), z2 = pos.getZ(i2);
      const cap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol && Math.abs(z2 - zFront) <= zTol) ||
                  (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol && Math.abs(z2 - zBack) <= zTol);
      const matIndex = cap ? 0 : 1;
      if (currentMat === -1) currentMat = matIndex;
      if (matIndex !== currentMat) { flush(); currentMat = matIndex; }
      count += 3;
    }
    flush();

    // UV Mapping
    merged.computeBoundingBox();
    const bb = merged.boundingBox!;
    const x0 = bb.min.x, dxU = bb.max.x - bb.min.x;
    const y0 = bb.min.y, dyU = bb.max.y - bb.min.y;
    const uvArr = new Float32Array(pos.count * 2);
    const centerX = (minX + maxX) / 2;
    
    for (let i = 0; i < pos.count; i += 3) {
      const z0 = pos.getZ(i), z1 = pos.getZ(i+1);
      const isCap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol) ||
                    (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol);
      if (isCap) {
        for (let j = 0; j < 3; j++) {
          uvArr[2*(i+j)] = (pos.getX(i+j) - x0) / dxU;
          uvArr[2*(i+j)+1] = (pos.getY(i+j) - y0) / dyU; 
        }
      } else {
        for (let j = 0; j < 3; j++) {
          const px = pos.getX(i+j);
          const py = pos.getY(i+j);
          const pz = pos.getZ(i+j);
          const originalSvgY = svgTotalHeight - py + minY;
          const s = nearestS(px + centerX, originalSvgY, outline.pts, outline.cum, outline.total);
          const t = (pz - zFront) / (zBack - zFront);
          uvArr[2*(i+j)] = s;
          uvArr[2*(i+j)+1] = t;
        }
      }
    }
    merged.setAttribute('uv', new THREE.BufferAttribute(uvArr, 2));

    // Stats
    const worldW = (maxX - minX) * Math.abs(scale) * sCore;
    const worldH = (bottomTarget_SV - minY) * Math.abs(scale) * sCore;
    const worldPerim = outline.total * Math.abs(scale) * sCore;
    const worldDepth = Math.abs(depth * scale);

    const finalScale: [number, number, number] = [scale * sCore, scale * sCore, scale];

    // --- CHILD WRAPPER CORRECTION ---
    // Normalized to align Child(0,0) to Stone(Top-Left)
    // X: -(maxX - minX) / 2  => Left Edge of centered geometry
    // Y: svgTotalHeight      => Top Edge of geometry (which sits on Y=0)
    // Z: depth / 2 + offset
    const wrapperX = -(maxX - minX) / 2;
    const wrapperY = svgTotalHeight;
    const wrapperZ = depth / 2 + 0.05;

    return {
      geometries: [merged],
      dims: { worldW, worldH, worldPerim, worldDepth },
      meshScale: finalScale,
      apiData: {
        frontZ: depth / 2,
        unitsPerMeter: 1 / Math.max(EPS, scale * sCore),
        version: Math.random(),
        worldWidth: worldW,
        worldHeight: worldH
      },
      childWrapperPos: [wrapperX, wrapperY, wrapperZ] as [number, number, number]
    };
  }, [svgData, depth, bevel, scale, targetWidth, targetHeight, preserveTop]);

  // 4. Update Texture Repeats
  useLayoutEffect(() => {
    if (!dims) return;
    const usePhysical = autoRepeat || tileSize != null || sideTileSize != null;
    const faceTile = tileSize ?? 0.1;
    const sideTile = sideTileSize ?? faceTile;
    const repFaceX = usePhysical ? Math.max(1, dims.worldW / faceTile) : (faceRepeatX ?? 6);
    const repFaceY = usePhysical ? Math.max(1, dims.worldH / faceTile) : (faceRepeatY ?? 6);
    const repSideX = usePhysical ? Math.max(1, dims.worldPerim / sideTile) : (sideRepeatX ?? 8);
    const repSideY = usePhysical ? Math.max(1, dims.worldDepth / sideTile) : (sideRepeatY ?? 1);

    clonedFaceMap.repeat.set(repFaceX, repFaceY);
    clonedSideMap.repeat.set(repSideX, repSideY);
    clonedFaceMap.needsUpdate = true;
    clonedSideMap.needsUpdate = true;
  }, [dims, autoRepeat, tileSize, sideTileSize, faceRepeatX, faceRepeatY, sideRepeatX, sideRepeatY, clonedFaceMap, clonedSideMap]);

  // 5. Materials
  const materials = useMemo(() => {
    const common = {
      roughness: 0.15,
      metalness: 0.1,
      color: new THREE.Color(0xffffff),
      side: doubleSided ? THREE.DoubleSide : THREE.FrontSide,
      envMapIntensity: 1.5,
    };
    return [
      new THREE.MeshStandardMaterial({ ...common, map: clonedFaceMap }),
      new THREE.MeshStandardMaterial({ ...common, map: clonedSideMap })
    ];
  }, [clonedFaceMap, clonedSideMap, doubleSided]);

  const meshRef = useRef<THREE.Mesh>(null!);
  const groupRef = useRef<THREE.Group>(null!);
  
  const [isReady, setIsReady] = useState(false);
  useLayoutEffect(() => { setIsReady(true); }, []);

  useImperativeHandle(ref, () => groupRef.current);

  const childApi = useMemo(() => ({
    group: groupRef,
    mesh: meshRef,
    frontZ: apiData?.frontZ ?? 0,
    unitsPerMeter: apiData?.unitsPerMeter ?? 100,
    version: apiData?.version ?? 0,
    worldWidth: apiData?.worldWidth ?? 1,
    worldHeight: apiData?.worldHeight ?? 1
  }), [apiData, isReady]);

  if (!geometries.length || !dims) return null;

  return (
    <group ref={groupRef} scale={meshScale}>
      {geometries.map((geom, i) => (
        <mesh
          key={`hs-${i}`}
          ref={i === 0 ? meshRef : undefined}
          geometry={geom}
          material={materials}
          castShadow
          receiveShadow
          {...meshProps}
        >
          {showEdges && <Edges scale={1.002} threshold={15} color="white" />}
        </mesh>
      ))}

      <group position={childWrapperPos} scale={[1, -1, 1]}>
         {typeof children === 'function' && children(childApi, selectedAdditions)}
      </group>
    </group>
  );
});

SvgHeadstone.displayName = 'SvgHeadstone';

export default SvgHeadstone;