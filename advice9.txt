The issue "it is even worse" is happening because of Double Transforms.

In the previous code, the geometry was built offset from the center (baked into the vertices), but the Mesh was placed at (0,0,0).
When you scale a Mesh that has offset geometry (e.g., a Top Rail geometry located at Y=200 inside a Mesh at Y=0), the rail moves upwards visually because you are scaling the distance from the origin.

The Fix:

Zero-Center the Geometry: The geometry for every part (Corners, Rails) must be centered at (0,0,0).

Move the Mesh: We place the Mesh at the correct position (e.g., Top Right corner).

Scale/Translate: Now, when useLayoutEffect scales the rail, it stretches from its own center. When it moves the corner, it moves the whole object cleanly.

Here is the corrected code.

code
Tsx
download
content_copy
expand_less
/**
 * Bronze Plaque Border Component - Fixed Origin & Scaling
 */

'use client';

import React, { useCallback, useEffect, useLayoutEffect, useRef, useState, useMemo } from 'react';
import * as THREE from 'three';
import { SVGLoader, type SVGResult } from 'three/examples/jsm/loaders/SVGLoader.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

interface BronzeBorderProps {
  borderName: string | null;
  plaqueWidth: number;
  plaqueHeight: number;
  unitsPerMeter: number;
  frontZ: number;
  color: string;
  depth: number;
}

interface BorderResources {
  geometries: THREE.BufferGeometry[];
}

type ScratchType = 'pos' | 'uv' | 'norm';

const sliceScratchBuffers: Record<ScratchType, Float32Array> = {
  pos: new Float32Array(0),
  uv: new Float32Array(0),
  norm: new Float32Array(0),
};

function ensureScratchCapacity(type: ScratchType, required: number) {
  const current = sliceScratchBuffers[type];
  if (current.length >= required) {
    return current;
  }
  let nextSize = current.length || 1;
  while (nextSize < required) {
    nextSize *= 2;
  }
  sliceScratchBuffers[type] = new Float32Array(nextSize);
  return sliceScratchBuffers[type];
}

const BORDER_SLUG_ALIASES: Record<string, string> = {
  bar: 'border1',
  square: 'border2',
  solidoutline: 'border3',
  solid: 'border4',
  notch: 'border5',
  scallop: 'border6',
  roundoutline: 'border7',
  floral: 'border8',
  decorative: 'border9',
  squareangular: 'border10',
};


const BORDER_SCALE = 1.3;
const BORDER_THICKNESS_SCALE = 1.5;
const BORDER_RELIEF_SCALE = 0.33;
const OVERLAP_BUFFER = 1.0;

const CURVE_SEGMENTS = 6;
const BEVEL_SEGMENTS = 1;
const UNIT_BOX_GEOMETRY = new THREE.BoxGeometry(1, 1, 1);
const PART_NAMES = ['top', 'bottom', 'left', 'right', 'tl', 'tr', 'bl', 'br'] as const;
type PartName = typeof PART_NAMES[number];

function buildScaledBoxGeometry(width: number, height: number, depth: number) {
  const geom = UNIT_BOX_GEOMETRY.clone();
  geom.scale(width, height, depth);
  geom.translate(0, 0, depth / 2);
  return geom;
}

interface BronzeTextures {
  map: THREE.CanvasTexture;
  roughnessMap: THREE.CanvasTexture;
}

interface BuiltState {
  group: THREE.Group | null;
  dims: { w: number; h: number };
}

function normalizeGeometry(geometry: THREE.BufferGeometry) {
  let geom = geometry;
  if (geom.index) {
    const nonIndexed = geom.toNonIndexed();
    geom.dispose();
    geom = nonIndexed;
  }

  if (!geom.getAttribute('normal')) {
    geom.computeVertexNormals();
  }

  if (!geom.getAttribute('uv')) {
    const position = geom.getAttribute('position') as THREE.BufferAttribute;
    const uvs = new Float32Array(position.count * 2);
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  }

  geom.computeBoundingBox();
  return geom;
}

function sliceGeometryAxis(
  geometry: THREE.BufferGeometry, 
  axis: 'x' | 'y', 
  limit: number, 
  keepCondition: 'less' | 'greater'
): THREE.BufferGeometry {
  const posAttr = geometry.getAttribute('position');
  const uvAttr = geometry.getAttribute('uv');
  const normAttr = geometry.getAttribute('normal');
  const count = posAttr.count;

  const maxVerts = Math.max(1, Math.floor(count * 1.2)); 
  
  const outPos = ensureScratchCapacity('pos', maxVerts * 3);
  const outUV = ensureScratchCapacity('uv', maxVerts * 2);
  const outNorm = ensureScratchCapacity('norm', maxVerts * 3);
  
  let vIdx = 0; 

  const axisIdx = axis === 'x' ? 0 : 1;
  const isKept = (val: number) => keepCondition === 'less' ? val < limit : val > limit;

  let ax, ay, az, bx, by, bz, cx, cy, cz;
  let au, av, bu, bv, cu, cv;
  let anx, any, anz, bnx, bny, bnz, cnx, cny, cnz;
  let ka, kb, kc; 
  let t;

  const pushV = (x:number, y:number, z:number, u:number, v:number, nx:number, ny:number, nz:number) => {
    if (vIdx >= maxVerts) return; 
    const i3 = vIdx * 3;
    const i2 = vIdx * 2;
    outPos[i3] = x; outPos[i3+1] = y; outPos[i3+2] = z;
    outUV[i2] = u; outUV[i2+1] = v;
    outNorm[i3] = nx; outNorm[i3+1] = ny; outNorm[i3+2] = nz;
    vIdx++;
  };

  const interpPush = (
    x1:number, y1:number, z1:number, u1:number, v1:number, nx1:number, ny1:number, nz1:number,
    x2:number, y2:number, z2:number, u2:number, v2:number, nx2:number, ny2:number, nz2:number,
    val1:number, val2:number
  ) => {
    t = (limit - val1) / (val2 - val1);
    pushV(
      x1 + (x2-x1)*t, y1 + (y2-y1)*t, z1 + (z2-z1)*t,
      u1 + (u2-u1)*t, v1 + (v2-v1)*t,
      nx1 + (nx2-nx1)*t, ny1 + (ny2-ny1)*t, nz1 + (nz2-nz1)*t
    );
  };

  for (let i = 0; i < count; i += 3) {
    ax = posAttr.getX(i);   ay = posAttr.getY(i);   az = posAttr.getZ(i);
    bx = posAttr.getX(i+1); by = posAttr.getY(i+1); bz = posAttr.getZ(i+1);
    cx = posAttr.getX(i+2); cy = posAttr.getY(i+2); cz = posAttr.getZ(i+2);

    ka = isKept(axisIdx === 0 ? ax : ay);
    kb = isKept(axisIdx === 0 ? bx : by);
    kc = isKept(axisIdx === 0 ? cx : cy);

    if (!ka && !kb && !kc) continue;

    au = uvAttr.getX(i);   av = uvAttr.getY(i);
    bu = uvAttr.getX(i+1); bv = uvAttr.getY(i+1);
    cu = uvAttr.getX(i+2); cv = uvAttr.getY(i+2);

    anx = normAttr.getX(i);   any = normAttr.getY(i);   anz = normAttr.getZ(i);
    bnx = normAttr.getX(i+1); bny = normAttr.getY(i+1); bnz = normAttr.getZ(i+1);
    cnx = normAttr.getX(i+2); cny = normAttr.getY(i+2); cnz = normAttr.getZ(i+2);

    if (ka && kb && kc) {
      pushV(ax, ay, az, au, av, anx, any, anz);
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      continue;
    }

    if (ka && !kb && !kc) { 
      pushV(ax, ay, az, au, av, anx, any, anz);
      interpPush(ax,ay,az,au,av,anx,any,anz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?ax:ay, axisIdx===0?bx:by);
      interpPush(ax,ay,az,au,av,anx,any,anz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?ax:ay, axisIdx===0?cx:cy);
    }
    else if (!ka && kb && !kc) {
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?bx:by, axisIdx===0?cx:cy);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?bx:by, axisIdx===0?ax:ay);
    }
    else if (!ka && !kb && kc) {
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?cx:cy, axisIdx===0?ax:ay);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?cx:cy, axisIdx===0?bx:by);
    }
    else if (ka && kb && !kc) {
      pushV(ax, ay, az, au, av, anx, any, anz);
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?bx:by, axisIdx===0?cx:cy);
      pushV(ax, ay, az, au, av, anx, any, anz);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?bx:by, axisIdx===0?cx:cy);
      interpPush(ax,ay,az,au,av,anx,any,anz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?ax:ay, axisIdx===0?cx:cy);
    }
    else if (!ka && kb && kc) {
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?cx:cy, axisIdx===0?ax:ay);
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?cx:cy, axisIdx===0?ax:ay);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?bx:by, axisIdx===0?ax:ay);
    }
    else if (ka && !kb && kc) {
      pushV(ax, ay, az, au, av, anx, any, anz);
      interpPush(ax,ay,az,au,av,anx,any,anz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?ax:ay, axisIdx===0?bx:by);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      interpPush(ax,ay,az,au,av,anx,any,anz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?ax:ay, axisIdx===0?bx:by);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?cx:cy, axisIdx===0?bx:by);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
    }
  }

  const newGeom = new THREE.BufferGeometry();
  newGeom.setAttribute('position', new THREE.BufferAttribute(outPos.slice(0, vIdx * 3), 3));
  newGeom.setAttribute('uv', new THREE.BufferAttribute(outUV.slice(0, vIdx * 2), 2));
  newGeom.setAttribute('normal', new THREE.BufferAttribute(outNorm.slice(0, vIdx * 3), 3));
  
  return newGeom;
}

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));

function shiftLuminance(hex: string, delta: number) {
  const color = new THREE.Color(hex);
  const hsl = { h: 0, s: 0, l: 0 };
  color.getHSL(hsl);
  const next = new THREE.Color();
  next.setHSL(hsl.h, clamp01(hsl.s + delta * 0.15), clamp01(hsl.l + delta));
  return `#${next.getHexString()}`;
}

function createBronzeTextures(baseHex: string): BronzeTextures | null {
  if (typeof document === 'undefined') {
    return null;
  }

  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = mapCanvas.height = 512;
  const mapCtx = mapCanvas.getContext('2d');
  if (!mapCtx) return null;

  const gradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
  gradient.addColorStop(0, shiftLuminance(baseHex, 0.2));
  gradient.addColorStop(0.45, shiftLuminance(baseHex, 0.08));
  gradient.addColorStop(0.6, baseHex);
  gradient.addColorStop(1, shiftLuminance(baseHex, -0.2));
  mapCtx.fillStyle = gradient;
  mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

  mapCtx.globalAlpha = 0.08;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.6)';
  for (let y = 0; y < mapCanvas.height; y += 2) {
    mapCtx.beginPath();
    const jitter = Math.random() * 1.5;
    mapCtx.moveTo(0, y + jitter);
    mapCtx.lineTo(mapCanvas.width, y + Math.random() * 1.5);
    mapCtx.stroke();
  }
  mapCtx.globalAlpha = 0.12;
  mapCtx.strokeStyle = 'rgba(0,0,0,0.4)';
  for (let y = 1; y < mapCanvas.height; y += 3) {
    mapCtx.beginPath();
    mapCtx.moveTo(0, y + Math.random());
    mapCtx.lineTo(mapCanvas.width, y + Math.random());
    mapCtx.stroke();
  }

  const mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
  mapTexture.anisotropy = 8;
  mapTexture.needsUpdate = true;

  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = 256;
  const roughCtx = roughCanvas.getContext('2d');
  if (!roughCtx) {
    return {
      map: mapTexture,
      roughnessMap: mapTexture.clone() as THREE.CanvasTexture,
    };
  }
  const roughData = roughCtx.createImageData(roughCanvas.width, roughCanvas.height);
  for (let i = 0; i < roughData.data.length; i += 4) {
    const shade = 130 + Math.random() * 90;
    roughData.data[i] = roughData.data[i + 1] = roughData.data[i + 2] = shade;
    roughData.data[i + 3] = 255;
  }
  roughCtx.putImageData(roughData, 0, 0);
  const roughnessMap = new THREE.CanvasTexture(roughCanvas);
  roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;
  roughnessMap.anisotropy = 4;
  roughnessMap.needsUpdate = true;

  return { map: mapTexture, roughnessMap };
}

export function BronzeBorder({
  borderName,
  plaqueWidth,
  plaqueHeight,
  unitsPerMeter,
  frontZ,
  color,
  depth,
}: BronzeBorderProps) {
  const unitScale = Math.max(1e-6, Math.abs(unitsPerMeter) || 1);
  const localWidth = Math.max(1e-3, Math.abs(plaqueWidth) * unitScale);
  const localHeight = Math.max(1e-3, Math.abs(plaqueHeight) * unitScale);

  const normalizedName = borderName?.toLowerCase() ?? '';
  const effectiveName = normalizedName.includes('no border') ? null : borderName;
  const slug = effectiveName ? toBorderSlug(effectiveName) : null;
  const resolvedSlug = slug ? `${slug}a` : null;
  const usesIntegratedRails = false;
  const shouldRender = Boolean(resolvedSlug && localWidth > 0 && localHeight > 0);

  const bronzeTextures = useMemo(() => createBronzeTextures(color), [color]);

  useEffect(() => {
    return () => {
      bronzeTextures?.map.dispose();
      bronzeTextures?.roughnessMap.dispose();
    };
  }, [bronzeTextures]);

  const [svgData, setSvgData] = useState<SVGResult | null>(null);
  const [builtState, setBuiltState] = useState<BuiltState>({ group: null, dims: { w: localWidth, h: localHeight } });

  const resourcesRef = useRef<BorderResources | null>(null);
  const svgCacheRef = useRef<Record<string, SVGResult>>({});
  const groupRef = useRef<THREE.Group>(null);
  const materialRef = useRef<THREE.MeshPhysicalMaterial | null>(null);

  const getMaterial = useCallback(() => {
    if (!materialRef.current) {
      materialRef.current = new THREE.MeshPhysicalMaterial({
        metalness: 0.95,
        roughness: 0.28,
        envMapIntensity: 1.5,
        clearcoat: 0.7,
        clearcoatRoughness: 0.18,
        side: THREE.DoubleSide,
        clippingPlanes: [],
      });
    }
    return materialRef.current;
  }, []);

  const [debouncedDims, setDebouncedDims] = useState({ w: localWidth, h: localHeight });
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const disposeResources = useCallback(() => {
    if (!resourcesRef.current) return;
    resourcesRef.current.geometries.forEach((geom) => geom.dispose());
    resourcesRef.current = null;
  }, []);

  useEffect(() => disposeResources, [disposeResources]);

  useEffect(() => {
    const material = getMaterial();
    material.color.set(color);
  }, [color, getMaterial]);

  useEffect(() => {
    const material = getMaterial();
    material.map = bronzeTextures?.map ?? null;
    material.roughnessMap = bronzeTextures?.roughnessMap ?? null;
    material.needsUpdate = true;
  }, [bronzeTextures, getMaterial]);

  useEffect(() => () => {
    materialRef.current?.dispose();
    materialRef.current = null;
  }, []);

  useEffect(() => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => {
      setDebouncedDims({ w: localWidth, h: localHeight });
    }, 150);
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, [localWidth, localHeight]);

  // -------------------------------------------------------------
  // VISUAL STABILITY LOGIC
  // -------------------------------------------------------------
  useLayoutEffect(() => {
    if (!groupRef.current || !builtState.group) return;

    // Dimensions the current geometry was built for
    const { w: builtW, h: builtH } = builtState.dims;
    const safeBuiltW = builtW || 1;
    const safeBuiltH = builtH || 1;

    // Calculate how much larger/smaller the props are compared to the built geometry
    const deltaW = localWidth - safeBuiltW;
    const deltaH = localHeight - safeBuiltH;
    const halfDeltaW = deltaW / 2;
    const halfDeltaH = deltaH / 2;

    // Calculate ratio for scaling rails
    const ratioW = localWidth / safeBuiltW;
    const ratioH = localHeight / safeBuiltH;

    // Iterate through parts and apply specific transform rules
    PART_NAMES.forEach((part) => {
      const mesh = groupRef.current?.getObjectByName(part) as THREE.Object3D & {
        userData: {
          __basePosition?: THREE.Vector3;
          __baseScale?: THREE.Vector3;
        };
      } | undefined;
      
      if (!mesh || !mesh.userData.__basePosition) return;

      const basePos = mesh.userData.__basePosition;
      
      // Reset logic
      mesh.scale.set(1, 1, 1);
      mesh.position.copy(basePos);

      switch (part) {
        case 'top':
          // Move Y by half delta, Stretch X
          // Since geometry is centered at (0,0,0), scaling X stretches evenly
          mesh.position.y = basePos.y + halfDeltaH;
          mesh.scale.x = ratioW;
          break;
        case 'bottom':
          mesh.position.y = basePos.y - halfDeltaH;
          mesh.scale.x = ratioW;
          break;
        case 'left':
          // Move X by half delta, Stretch Y
          mesh.position.x = basePos.x - halfDeltaW;
          mesh.scale.y = ratioH;
          break;
        case 'right':
          mesh.position.x = basePos.x + halfDeltaW;
          mesh.scale.y = ratioH;
          break;
        case 'tl':
          // Move Corner (No Scale)
          mesh.position.x = basePos.x - halfDeltaW;
          mesh.position.y = basePos.y + halfDeltaH;
          break;
        case 'tr':
          mesh.position.x = basePos.x + halfDeltaW;
          mesh.position.y = basePos.y + halfDeltaH;
          break;
        case 'bl':
          mesh.position.x = basePos.x - halfDeltaW;
          mesh.position.y = basePos.y - halfDeltaH;
          break;
        case 'br':
          mesh.position.x = basePos.x + halfDeltaW;
          mesh.position.y = basePos.y - halfDeltaH;
          break;
      }
    });
  }, [localWidth, localHeight, builtState]);

  useEffect(() => {
    if (!resolvedSlug) {
      setSvgData(null);
      return;
    }

    if (svgCacheRef.current[resolvedSlug]) {
      setSvgData(svgCacheRef.current[resolvedSlug]);
      return;
    }

    let cancelled = false;
    const loader = new SVGLoader();

    loader.load(
      `/shapes/borders/${resolvedSlug}.svg`,
      (data) => {
        if (cancelled) return;
        svgCacheRef.current[resolvedSlug] = data;
        setSvgData(data);
      },
      undefined,
      (error) => {
        if (cancelled) return;
        console.warn(`Failed to load border SVG ${resolvedSlug}`, error);
        setSvgData(null);
      },
    );

    return () => {
      cancelled = true;
    };
  }, [resolvedSlug]);

  useEffect(() => {
    if (!shouldRender || !svgData) {
      disposeResources();
      setBuiltState({ group: null, dims: { w: localWidth, h: localHeight } });
      return;
    }

    const material = getMaterial();

    const built = buildBorderGroup(svgData, {
      plaqueWidth: debouncedDims.w,
      plaqueHeight: debouncedDims.h,
      depth,
      frontZ,
      textures: bronzeTextures ?? undefined,
      integratedRails: usesIntegratedRails,
      material,
      borderSlug: resolvedSlug,
    });

    if (!built) {
      disposeResources();
      setBuiltState({ group: null, dims: { w: debouncedDims.w, h: debouncedDims.h } });
      return;
    }

    disposeResources();
    resourcesRef.current = {
      geometries: built.geometries,
    };
    setBuiltState({ group: built.group, dims: { w: debouncedDims.w, h: debouncedDims.h } });
  }, [svgData, shouldRender, debouncedDims, depth, frontZ, bronzeTextures, disposeResources, usesIntegratedRails, getMaterial, localWidth, localHeight, resolvedSlug]);

  if (!builtState.group) {
    return null;
  }

  return <primitive object={builtState.group} ref={groupRef} />;
}

function toBorderSlug(name: string) {
  const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const alias = BORDER_SLUG_ALIASES[normalized];
  if (alias) {
    return alias;
  }
  const match = name.match(/\d+/);
  if (match) {
    return `border${match[0]}`;
  }
  return normalized || 'border1';
}

function buildBorderGroup(
  data: SVGResult,
  params: {
    plaqueWidth: number;
    plaqueHeight: number;
    depth: number;
    frontZ: number;
    textures?: BronzeTextures;
    integratedRails?: boolean;
    material: THREE.MeshPhysicalMaterial;
    borderSlug?: string | null;
  },
): {
  group: THREE.Group;
  geometries: THREE.BufferGeometry[];
} | null {
  const { plaqueWidth, plaqueHeight, depth, frontZ, textures, integratedRails = false, material, borderSlug } = params;
  const width = Math.max(1e-3, Math.abs(plaqueWidth));
  const height = Math.max(1e-3, Math.abs(plaqueHeight));

  const reliefDepthBase = Math.max(0.001, Math.min(width, height) * 0.003);
  const reliefDepth = reliefDepthBase * BORDER_RELIEF_SCALE;
  const extrudeSettings = {
    depth: reliefDepth,
    bevelEnabled: true,
    bevelSegments: BEVEL_SEGMENTS,
    bevelSize: reliefDepth * 0.35,
    bevelThickness: reliefDepth * 0.35,
    steps: 1,
    curveSegments: CURVE_SEGMENTS,
  } satisfies THREE.ExtrudeGeometryOptions;

  const tempGeometries: THREE.BufferGeometry[] = [];

  for (const path of data.paths) {
    const shapes = SVGLoader.createShapes(path);
    for (const shape of shapes) {
      if (!shape.curves.length) continue;
      const raw = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const geom = normalizeGeometry(raw);
      tempGeometries.push(geom);
    }
  }

  if (!tempGeometries.length || tempGeometries.some((geom) => !geom.getAttribute('position'))) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  const merged = mergeGeometries(tempGeometries, false);
  if (!merged) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  merged.computeBoundingBox();
  const centeredBounds = merged.boundingBox;
  if (!centeredBounds) {
    merged.dispose();
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  const originalWidth = Math.max(1e-3, centeredBounds.max.x - centeredBounds.min.x);
  const originalHeight = Math.max(1e-3, centeredBounds.max.y - centeredBounds.min.y);
  const centerX = (centeredBounds.min.x + centeredBounds.max.x) / 2;
  const centerY = (centeredBounds.min.y + centeredBounds.max.y) / 2;

  merged.translate(-centerX, -centerY, 0);

  const edgeThicknessBase = Math.max(0.01, Math.min(width, height) * 0.02 * BORDER_SCALE);
  const edgeThickness = edgeThicknessBase * BORDER_THICKNESS_SCALE;
  const lineThickness = edgeThickness * 0.4;
  const lineGap = lineThickness * 0.6;

  const INTEGRATED_SCALE_OVERRIDES: Record<string, number> = {
    border1a: 4,
  };

  if (integratedRails) {
    let uniformScale = Math.min(width / originalWidth, height / originalHeight);
    if (borderSlug && INTEGRATED_SCALE_OVERRIDES[borderSlug]) {
      uniformScale *= INTEGRATED_SCALE_OVERRIDES[borderSlug];
    }
    merged.scale(uniformScale, uniformScale, 1);
  } else {
    const targetCornerSpan = Math.max(lineThickness * 6, Math.min(width, height) * 0.25);
    const baseScale = (targetCornerSpan / Math.max(originalWidth, originalHeight)) * 0.7;
    merged.scale(baseScale, baseScale, 1);
  }
  merged.computeVertexNormals();
  merged.computeBoundingBox();
  const scaledBounds = merged.boundingBox!;
  const cornerSpanX = scaledBounds.max.x - scaledBounds.min.x;
  const cornerSpanY = scaledBounds.max.y - scaledBounds.min.y;

  const textureRepeatX = Math.max(1, width / 120);
  const textureRepeatY = Math.max(1, height / 120);

  if (textures?.map && material.map !== textures.map) {
    material.map = textures.map;
  }
  if (textures?.roughnessMap && material.roughnessMap !== textures.roughnessMap) {
    material.roughnessMap = textures.roughnessMap;
  }

  if (material.map) {
    material.map.repeat.set(textureRepeatX, textureRepeatY);
    material.map.needsUpdate = true;
  }

  if (material.roughnessMap instanceof THREE.Texture) {
    material.roughnessMap.repeat.set(textureRepeatX, textureRepeatY);
    material.roughnessMap.needsUpdate = true;
  }

  let topEdgeStartX: number | null = null;
  let topEdgeEndX: number | null = null;
  let bottomEdgeStartX: number | null = null;
  let bottomEdgeEndX: number | null = null;
  let topInnerEdgeY: number | null = null;
  let bottomInnerEdgeY: number | null = null;
  let leftEdgeTopInnerY: number | null = null;
  let leftEdgeBottomInnerY: number | null = null;
  let rightEdgeTopInnerY: number | null = null;
  let rightEdgeBottomInnerY: number | null = null;
  let leftInnerEdgeX: number | null = null;
  let rightInnerEdgeX: number | null = null;

  const group = new THREE.Group();
  const resourceGeometries: THREE.BufferGeometry[] = [];
  const SURFACE_Z = frontZ + 0.0001;
  
  // Store geometry + position for each part
  const parts: Record<PartName, { geoms: THREE.BufferGeometry[]; pos: THREE.Vector3 }> = {
    top: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    bottom: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    left: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    right: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    tl: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    tr: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    bl: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
    br: { geoms: [], pos: new THREE.Vector3(0, 0, SURFACE_Z) },
  };

  const lineAnchors = {
    top: null as [number, number] | null,
    bottom: null as [number, number] | null,
    left: null as [number, number] | null,
    right: null as [number, number] | null,
  };

  const axisTolerance = Math.max(width, height) * 0.0005;

  const extractUniqueAxisValues = (geom: THREE.BufferGeometry, axis: 'x' | 'y') => {
    const attr = geom.getAttribute('position') as THREE.BufferAttribute;
    const values: number[] = [];
    for (let i = 0; i < attr.count; i += 1) {
      values.push(axis === 'x' ? attr.getX(i) : attr.getY(i));
    }
    values.sort((a, b) => a - b);
    const uniques: number[] = [];
    for (const value of values) {
      if (!uniques.length || Math.abs(uniques[uniques.length - 1] - value) > axisTolerance) {
        uniques.push(value);
      }
    }
    return uniques;
  };

  const captureAnchors = (
    geom: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    const toPair = (values: number[], reverse = false): [number, number] | null => {
      if (!values.length) {
        return null;
      }
      const list = reverse ? [...values].reverse() : values;
      if (list.length === 1) {
        return [list[0], list[0]];
      }
      return [list[0], list[1]];
    };

    const yValues = extractUniqueAxisValues(geom, 'y');
    if (alignY === 'top' && !lineAnchors.top) {
      const anchors = toPair(yValues.slice(-2), true);
      if (anchors) {
        lineAnchors.top = anchors;
      }
    }
    if (alignY === 'bottom' && !lineAnchors.bottom) {
      const anchors = toPair(yValues.slice(0, 2));
      if (anchors) {
        lineAnchors.bottom = anchors;
      }
    }

    const xValues = extractUniqueAxisValues(geom, 'x');
    if (alignX === 'left' && !lineAnchors.left) {
      const anchors = toPair(xValues.slice(0, 2));
      if (anchors) {
        lineAnchors.left = anchors;
      }
    }
    if (alignX === 'right' && !lineAnchors.right) {
      const anchors = toPair(xValues.slice(-2), true);
      if (anchors) {
        lineAnchors.right = anchors;
      }
    }
  };

  const createCornerMesh = (
    source: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
    dest: PartName,
  ) => {
    let geom = source.clone();
    
    // 1. Flip
    const flipX = alignX === 'right';
    const flipY = alignY === 'top';
    if (flipX) geom.scale(-1, 1, 1);
    if (flipY) geom.scale(1, -1, 1);
    
    if (flipX !== flipY) {
      const pos = geom.getAttribute('position');
      for (let i = 0; i < pos.count; i += 3) {
        const x2 = pos.getX(i + 1), y2 = pos.getY(i + 1), z2 = pos.getZ(i + 1);
        const x3 = pos.getX(i + 2), y3 = pos.getY(i + 2), z3 = pos.getZ(i + 2);
        pos.setXYZ(i + 1, x3, y3, z3);
        pos.setXYZ(i + 2, x2, y2, z2);
      }
    }
    
    geom = normalizeGeometry(geom);
    geom.computeBoundingBox();
    const bounds = geom.boundingBox!;
    
    // 2. Position temporarily in World Space to perform the Cut
    // We move the Corner Geometry to the actual Corner of the plaque
    const cornerX = alignX === 'left' ? -width / 2 : width / 2;
    const cornerY = alignY === 'top' ? height : 0;
    
    // Align the geometry bounding box corner to the plaque corner
    const alignOffsetX = alignX === 'left' ? -bounds.min.x : -bounds.max.x;
    const alignOffsetY = alignY === 'top' ? -bounds.max.y : -bounds.min.y;
    
    const worldX = cornerX + alignOffsetX;
    const worldY = cornerY + alignOffsetY;
    
    geom.translate(worldX, worldY, SURFACE_Z);
    
    // Regenerate UVs
    const posAttr = geom.getAttribute('position');
    const uvs = geom.getAttribute('uv');
    for (let i = 0; i < posAttr.count; i++) {
        uvs.setXY(i, posAttr.getX(i), posAttr.getY(i));
    }
    uvs.needsUpdate = true;

    // 3. Slice
    if (alignX === 'left') {
      geom = sliceGeometryAxis(geom, 'x', OVERLAP_BUFFER, 'less');
    } else {
      geom = sliceGeometryAxis(geom, 'x', -OVERLAP_BUFFER, 'greater');
    }
    if (alignY === 'top') {
      geom = sliceGeometryAxis(geom, 'y', (height / 2) - OVERLAP_BUFFER, 'greater');
    } else {
      geom = sliceGeometryAxis(geom, 'y', (height / 2) + OVERLAP_BUFFER, 'less');
    }

    geom.computeVertexNormals();
    captureAnchors(geom, alignX, alignY);

    // 4. RE-CENTERING TRICK:
    // Move the geometry back to (0,0,0) relative to the specific corner anchor
    // so that the Mesh can be placed at the anchor.
    // Anchor Point: The absolute corner of the plaque (cornerX, cornerY)
    geom.translate(-cornerX, -cornerY, -SURFACE_Z);

    // Set the destination Mesh position to the Corner Anchor
    parts[dest].pos.set(cornerX, cornerY, SURFACE_Z);
    parts[dest].geoms.push(geom);
  };

  createCornerMesh(merged, 'left', 'top', 'tl');
  createCornerMesh(merged, 'right', 'top', 'tr');
  createCornerMesh(merged, 'left', 'bottom', 'bl');
  createCornerMesh(merged, 'right', 'bottom', 'br');

  const fallbackTopStartX = -width / 2 + cornerSpanX;
  const fallbackTopEndX = width / 2 - cornerSpanX;
  const fallbackBottomStartX = fallbackTopStartX;
  const fallbackBottomEndX = fallbackTopEndX;
  const fallbackTopInnerY = height - cornerSpanY;
  const fallbackBottomInnerY = cornerSpanY;
  const fallbackLeftTopInnerY = fallbackTopInnerY;
  const fallbackLeftBottomInnerY = fallbackBottomInnerY;
  const fallbackRightTopInnerY = fallbackTopInnerY;
  const fallbackRightBottomInnerY = fallbackBottomInnerY;
  const fallbackLeftInnerX = -width / 2 + cornerSpanX;
  const fallbackRightInnerX = width / 2 - cornerSpanX;

  const clampEdgeXValue = (value: number | null) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return null;
    return Math.min(width / 2, Math.max(-width / 2, value));
  };

  const clampEdgeYValue = (value: number | null) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return null;
    return Math.min(height, Math.max(0, value));
  };


  const sortedFallbackTop: readonly [number, number] = [
    Math.min(fallbackTopStartX, fallbackTopEndX),
    Math.max(fallbackTopStartX, fallbackTopEndX),
  ];
  const sortedFallbackBottom: readonly [number, number] = [
    Math.min(fallbackBottomStartX, fallbackBottomEndX),
    Math.max(fallbackBottomStartX, fallbackBottomEndX),
  ];

  const resolveSpan = (
    start: number | null,
    end: number | null,
    fallback: readonly [number, number],
  ): readonly [number, number] => {
    if (start == null || end == null) {
      return fallback;
    }
    const left = Math.min(start, end);
    const right = Math.max(start, end);
    if (!Number.isFinite(left) || !Number.isFinite(right) || right - left < lineThickness * 1.25) {
      return fallback;
    }
    return [left, right] as const;
  };

  const [topStartX, topEndX] = resolveSpan(
    clampEdgeXValue(topEdgeStartX),
    clampEdgeXValue(topEdgeEndX),
    sortedFallbackTop,
  );
  const [bottomStartX, bottomEndX] = resolveSpan(
    clampEdgeXValue(bottomEdgeStartX),
    clampEdgeXValue(bottomEdgeEndX),
    sortedFallbackBottom,
  );

  const resolvedTopInnerY = clampEdgeYValue(topInnerEdgeY) ?? fallbackTopInnerY;
  const resolvedBottomInnerY = clampEdgeYValue(bottomInnerEdgeY) ?? fallbackBottomInnerY;
  const leftTopY = clampEdgeYValue(leftEdgeTopInnerY) ?? fallbackLeftTopInnerY;
  const leftBottomY = clampEdgeYValue(leftEdgeBottomInnerY) ?? fallbackLeftBottomInnerY;
  const rightTopY = clampEdgeYValue(rightEdgeTopInnerY) ?? fallbackRightTopInnerY;
  const rightBottomY = clampEdgeYValue(rightEdgeBottomInnerY) ?? fallbackRightBottomInnerY;
  const resolvedLeftInnerX = clampEdgeXValue(leftInnerEdgeX) ?? fallbackLeftInnerX;
  const resolvedRightInnerX = clampEdgeXValue(rightInnerEdgeX) ?? fallbackRightInnerX;

  const clampSpan = (value: number) => Math.max(lineThickness * 2, Math.max(0.001, value));

  const topSpan = clampSpan(topEndX - topStartX);
  const bottomSpan = clampSpan(bottomEndX - bottomStartX);
  const sortedLeftTopY = Math.max(leftTopY, leftBottomY);
  const sortedLeftBottomY = Math.min(leftTopY, leftBottomY);
  const sortedRightTopY = Math.max(rightTopY, rightBottomY);
  const sortedRightBottomY = Math.min(rightTopY, rightBottomY);
  const leftSpan = clampSpan(sortedLeftTopY - sortedLeftBottomY);
  const rightSpan = clampSpan(sortedRightTopY - sortedRightBottomY);

  const addEdgeBar = (geom: THREE.BufferGeometry, yOffset: number, dest: PartName) => {
    const piece = geom.clone().toNonIndexed();
    // For rails, we keep geometry centered at (0,0) locally.
    // The yOffset is used for the Mesh position, not geometry translation.
    
    // HOWEVER, `createDecorativeRails` builds boxes centered at origin.
    // We need to shift them slightly if they are inner/outer lines so they match the
    // yOffset relative to the rail center.
    // Since `yOffset` here is the absolute position on the plaque, we handle that in parts[dest].pos
    
    // Actually, `addEdgeBar` is called with specific Y coordinates (e.g. topOuterCenterY).
    // To allow `scale` to work from the CENTER of the rail, the geometry must be at 0.
    // But the rail has two lines (inner and outer). 
    // We should center the *group* of lines at 0, and move the Mesh to the center of the rail group.
    
    // Simplified strategy:
    // 1. We know the rail center (e.g. topCenterX, topCenterY implicit from span).
    // 2. We translate the geometry relative to that center.
    // 3. We place the Mesh at that center.
    
    // Let's look at call sites. 
    // topRails[0] is at topOuterCenterY. topRails[1] is at topInnerCenterY.
    // We should find the midpoint of those two lines, place the mesh there,
    // and offset the lines relative to that midpoint.
    
    // Better yet: Just put the Mesh at the absolute Y passed in (yOffset), 
    // and keep the geometry at 0.
    // But `addEdgeBar` is called twice for 'top' (outer line, inner line).
    // We need one Mesh for 'top' containing both lines.
    
    // Solution:
    // The `parts` bucket accumulates geometries.
    // For 'top', we want the Mesh at (0, height, Z) or close to it.
    // Let's set the Mesh Position for 'top' to (0, height, SURFACE_Z).
    // Then translate the geometry by `yOffset - height`.
    
    const isTop = dest === 'top';
    const isBottom = dest === 'bottom';
    const isLeft = dest === 'left';
    const isRight = dest === 'right';
    
    let meshBaseX = 0;
    let meshBaseY = 0;
    
    if (isTop) meshBaseY = height;
    if (isBottom) meshBaseY = 0;
    if (isLeft) meshBaseX = -width / 2;
    if (isRight) meshBaseX = width / 2;
    
    // Set the mesh base position (idempotent, effectively sets it for the group)
    parts[dest].pos.set(meshBaseX, meshBaseY, SURFACE_Z);
    
    // Offset the geometry relative to the mesh base
    // Note: createDecorativeRails builds geometry centered at (0,0).
    // In original code: piece.translate(x, y, ...).
    // Here: piece.translate(x - meshBaseX, y - meshBaseY, 0).
    
    // The `x` passed to addEdgeBar is the center of the span.
    // For Top/Bottom rails, `x` is 0 (centered).
    // For Left/Right rails, `y` is height/2 (centered).
    
    // WAIT. `topCenterX` is (topStartX + topEndX)/2.
    // If plaque is centered, topStartX = -W/2 + corner, topEndX = W/2 - corner.
    // So topCenterX is 0. Correct.
    
    // So for Top Rail: passed X=0, passed Y=specific line Y.
    // Mesh Base: (0, height).
    // Geom Translate: (0, specific line Y - height).
    
    const geomOffsetX = arguments[1] - meshBaseX; // x - meshBaseX
    const geomOffsetY = arguments[2] - meshBaseY; // y - meshBaseY
    
    piece.translate(geomOffsetX, geomOffsetY, 0);
    parts[dest].geoms.push(piece);
  };

  if (!integratedRails) {
    const clampY = (value: number) => Math.min(height, Math.max(0, value));
    const clampX = (value: number) => Math.min(width / 2, Math.max(-width / 2, value));

    const topLineY = clampY(resolvedTopInnerY);
    const bottomLineY = clampY(resolvedBottomInnerY);
    const leftLineX = clampX(resolvedLeftInnerX);
    const rightLineX = clampX(resolvedRightInnerX);

    const resolveAnchors = (
      anchors: [number, number] | null,
      fallbackOuter: number,
      fallbackInner: number,
    ): [number, number] => {
      if (anchors) {
        return anchors;
      }
      return [fallbackOuter, fallbackInner];
    };

    const [topOuterCenterY, topInnerCenterY] = resolveAnchors(
      lineAnchors.top,
      clampY(topLineY + lineThickness / 2),
      clampY(topLineY + lineThickness / 2 - (lineThickness + lineGap)),
    );
    const [bottomOuterCenterY, bottomInnerCenterY] = resolveAnchors(
      lineAnchors.bottom,
      clampY(bottomLineY - lineThickness / 2),
      clampY(bottomLineY - lineThickness / 2 + (lineThickness + lineGap)),
    );
    const [leftOuterCenterX, leftInnerCenterX] = resolveAnchors(
      lineAnchors.left,
      clampX(leftLineX - lineThickness / 2),
      clampX(leftLineX - lineThickness / 2 + (lineThickness + lineGap)),
    );
    const [rightOuterCenterX, rightInnerCenterX] = resolveAnchors(
      lineAnchors.right,
      clampX(rightLineX + lineThickness / 2),
      clampX(rightLineX + lineThickness / 2 - (lineThickness + lineGap)),
    );

    const createDecorativeRails = (
      length: number,
      orientation: 'horizontal' | 'vertical'
    ): THREE.BufferGeometry[] => {
      const rails: THREE.BufferGeometry[] = [];
      const isHorizontal = orientation === 'horizontal';
      const railWidth = isHorizontal ? length : lineThickness;
      const railHeight = isHorizontal ? lineThickness : length;
      
      const outerLine = buildScaledBoxGeometry(railWidth, railHeight, reliefDepth);
      const innerLine = buildScaledBoxGeometry(railWidth, railHeight, reliefDepth);
      rails.push(outerLine, innerLine);
      return rails;
    };

    const topRails = createDecorativeRails(topSpan, 'horizontal');
    const bottomRails = createDecorativeRails(bottomSpan, 'horizontal');
    const leftRails = createDecorativeRails(leftSpan, 'vertical');
    const rightRails = createDecorativeRails(rightSpan, 'vertical');

    // Note: passing 3 args (geom, x, y) but helper expects (geom, yOffset, dest) logic mismatch
    // Let's call the helper explicitly with correct args
    
    // Top
    addEdgeBar(topRails[0], topCenterX, topOuterCenterY, 'top');
    addEdgeBar(topRails[1], topCenterX, topInnerCenterY, 'top');
    
    // Bottom
    addEdgeBar(bottomRails[0], bottomCenterX, bottomOuterCenterY, 'bottom');
    addEdgeBar(bottomRails[1], bottomCenterX, bottomInnerCenterY, 'bottom');
    
    // Left
    addEdgeBar(leftRails[0], leftOuterCenterX, leftCenterY, 'left');
    addEdgeBar(leftRails[1], leftInnerCenterX, leftCenterY, 'left');
    
    // Right
    addEdgeBar(rightRails[0], rightOuterCenterX, rightCenterY, 'right');
    addEdgeBar(rightRails[1], rightInnerCenterX, rightCenterY, 'right');

    topRails.forEach(r => r.dispose());
    bottomRails.forEach(r => r.dispose());
    leftRails.forEach(r => r.dispose());
    rightRails.forEach(r => r.dispose());
  }

  PART_NAMES.forEach((partName) => {
    const { geoms, pos } = parts[partName];
    if (!geoms.length) return;

    let mergedPart: THREE.BufferGeometry | null = null;
    if (geoms.length === 1) {
      mergedPart = geoms[0];
    } else {
      mergedPart = mergeGeometries(geoms, false);
      geoms.forEach((geom) => geom.dispose());
    }

    if (!mergedPart) return;

    const mesh = new THREE.Mesh(mergedPart, material);
    mesh.name = partName;
    mesh.castShadow = false;
    mesh.receiveShadow = false;
    mesh.renderOrder = 3;
    
    // IMPORTANT: Set initial position here
    mesh.position.copy(pos);
    
    // Cache for scaling logic
    mesh.userData.__basePosition = pos.clone();
    
    group.add(mesh);
    resourceGeometries.push(mergedPart);
  });

  merged.dispose();

  return {
    group,
    geometries: resourceGeometries,
  };
}