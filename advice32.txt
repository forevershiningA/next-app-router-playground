I understand. It's common for visual changes from procedural texture improvements to be subtle, especially with normal maps, which primarily affect how light interacts with the surface rather than the base color.

Given that the visual change wasn't as pronounced as you hoped, let's explore some specific adjustments and alternative approaches to make the "pitch rock" more apparent and realistic.

Why You Might Not See Much Change & What to Check:

Lighting: Normal maps require good lighting to show their effect. If your scene lighting is very flat (e.g., direct overhead ambient light, no strong directional lights), the bumps won't be noticeable.

Action: Ensure you have a strong DirectionalLight or SpotLight in your scene, preferably casting shadows, to highlight the surface irregularities. Try moving the light around to see how it catches the details.

Action: Consider adding an AmbientLight but keep its intensity low, letting the directional light define the shape.

Action: An Environment Map (like an HDR texture) can also greatly enhance the appearance by providing realistic reflections and diffuse lighting.

normalScale: Your current normalScale is new THREE.Vector2(2.0, 2.0). This value controls the intensity of the normal map effect.

Action: Try increasing normalScale significantly (e.g., 5.0, 10.0, even 20.0) to exaggerate the bumps and see if they become more visible. This is a quick way to gauge the map's effectiveness.

Texture Density (textureDensity in UV Mapping): If textureDensity is too low, the "chips" might be too large and few, making the surface look coarse but not detailed. If it's too high, the chips might be too small to be perceived as distinct features.

Action: Experiment with textureDensity (e.g., 10.0, 40.0, 80.0). A smaller textureDensity makes features larger, and a larger textureDensity makes features smaller and more numerous.

roughness and metalness:

The roughness: 0.65 is a good starting point. Lowering it slightly (e.g., 0.4 to 0.55) might make the surface appear a bit shinier, which can highlight normal map details through more distinct reflections.

metalness: 0.0 is correct for stone.

Action: Try different roughness values.

color of the Material: Darker colors can sometimes hide subtle normal map details because less light is reflected.

Action: Temporarily set color to a lighter gray (e.g., 0x888888) for the side material to see if the details become more apparent before reverting to a darker shade.

Advanced Improvements for the Procedural Normal Map:

Let's refine the rockNormalCanvas generation based on the previous suggestions.

1. Layered Voronoi Noise (FBM for getHeight)

This will create more varied and realistic chip sizes.

code
TypeScript
download
content_copy
expand_less
// Inside rockNormalCanvas useMemo:
    // ...
    const fract = (x: number) => x - Math.floor(x);
    const random2 = (x: number, y: number) => {
        const r1 = fract(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453);
        const r2 = fract(Math.sin(x * 26.345 + y * 42.123) * 31421.3551);
        return { x: r1, y: r2 };
    };

    // Helper to get Voronoi distance for a given scale and point
    const getSingleLayerVoronoiHeight = (u: number, v: number, layerScale: number, amplitude: number) => {
        const su = u * layerScale;
        const sv = v * layerScale;

        let minDist = 999;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const cellX = Math.floor(su) + dx;
                const cellY = Math.floor(sv) + dy;
                const rand = random2(cellX, cellY);
                // Offset by random values to break perfect grid
                const pointX = cellX + rand.x;
                const pointY = cellY + rand.y;
                const dist = Math.sqrt((su - pointX) ** 2 + (sv - pointY) ** 2);
                if (dist < minDist) minDist = dist;
            }
        }
        // Normalize distance to 0-1 based on expected max distance for this scale
        // A cell diagonal is sqrt(2) * 0.5 = ~0.707
        const normalizedDist = Math.min(minDist, 1.0); 
        return Math.pow(1.0 - normalizedDist, 2.0) * amplitude; // Squared for sharper chips, amplitude for intensity
    };

    const getHeight = (u: number, v: number) => {
        // Layer 1: Large scale "boulders"
        const h1 = getSingleLayerVoronoiHeight(u, v, 4.0, 0.6); 
        // Layer 2: Medium scale "rocks"
        const h2 = getSingleLayerVoronoiHeight(u, v, 15.0, 0.3); 
        // Layer 3: Fine "chips" and grit
        const h3 = getSingleLayerVoronoiHeight(u, v, 40.0, 0.1); 

        // Combine the layers
        return h1 + h2 + h3; // Summing them up to create more complex height
    };

    // ... rest of your normal map generation ...
2. Incorporate a Roughness Map

This will add visual interest by varying the surface shininess.

code
TypeScript
download
content_copy
expand_less
// Inside rockNormalCanvas useMemo, after getHeight and before normal calculation:
    // ...
    const heights: number[][] = [];
    const roughnessMap: number[][] = []; // New roughness map
    for (let y = 0; y < size; y++) {
      heights[y] = [];
      roughnessMap[y] = [];
      for (let x = 0; x < size; x++) {
        const h = getHeight(x / size, y / size);
        heights[y][x] = h;
        // Derive roughness: Deeper/sharper parts are rougher (higher value), flatter parts are smoother.
        // The 'h' value is 0-1, so 1-h makes lower spots rougher.
        roughnessMap[y][x] = 0.5 + h * 0.5; // Scale to a reasonable roughness range, e.g., 0.5 to 1.0
      }
    }

    // ... your existing normal map generation ...

    ctx.putImageData(imageData, 0, 0); // This saves the normal map
    // You'll need another canvas or texture for the roughness map
    const roughnessCanvas = document.createElement('canvas');
    roughnessCanvas.width = size;
    roughnessCanvas.height = size;
    const rCtx = roughnessCanvas.getContext('2d');
    if (rCtx) {
        const rImageData = rCtx.getImageData(0, 0, size, size);
        const rData = rImageData.data;
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                const rVal = roughnessMap[y][x]; // Value between 0 and 1
                const byteVal = (rVal * 255) | 0;
                const idx = (y * size + x) * 4;
                rData[idx] = byteVal;
                rData[idx + 1] = byteVal;
                rData[idx + 2] = byteVal;
                rData[idx + 3] = 255;
            }
        }
        rCtx.putImageData(rImageData, 0, 0);
    }
    return { normalCanvas: canvas, roughnessCanvas: roughnessCanvas }; // Return both
  }, [headstoneStyle]);

Then, you'll need to create a CanvasTexture for the roughness map and apply it:

code
TypeScript
download
content_copy
expand_less
// 2c. Create normal map and roughness map textures from canvases
  const { rockNormalTexture, rockRoughnessTexture } = useMemo(() => {
    if (!rockNormalCanvas || !rockNormalCanvas.normalCanvas) return { rockNormalTexture: null, rockRoughnessTexture: null };
    
    const normalTex = new THREE.CanvasTexture(rockNormalCanvas.normalCanvas);
    normalTex.wrapS = THREE.RepeatWrapping;
    normalTex.wrapT = THREE.RepeatWrapping;
    normalTex.colorSpace = THREE.NoColorSpace; // Crucial for normal maps
    normalTex.needsUpdate = true;

    const roughnessTex = new THREE.CanvasTexture(rockNormalCanvas.roughnessCanvas!);
    roughnessTex.wrapS = THREE.RepeatWrapping;
    roughnessTex.wrapT = THREE.RepeatWrapping;
    roughnessTex.colorSpace = THREE.NoColorSpace; // Roughness maps are linear
    roughnessTex.needsUpdate = true;
    
    return { rockNormalTexture: normalTex, rockRoughnessTexture: roughnessTex };
  }, [rockNormalCanvas]);

  // 2d. Cleanup
  React.useEffect(() => {
    return () => {
      if (rockNormalTexture) rockNormalTexture.dispose();
      if (rockRoughnessTexture) rockRoughnessTexture.dispose();
    };
  }, [rockNormalTexture, rockRoughnessTexture]);

  // ...

  // 5. Create Materials
  const materials = useMemo(() => {
    // ... common ...
    
    if (headstoneStyle === 'slant' && rockNormalTexture && rockRoughnessTexture) {
      return [
        new THREE.MeshPhysicalMaterial({ 
          ...common, 
          map: clonedFaceMap,
          clearcoat: 0,
          clearcoatRoughness: 0,
        }),
        new THREE.MeshPhysicalMaterial({ 
          ...common, 
          map: clonedSideMap,
          normalMap: rockNormalTexture,
          normalScale: new THREE.Vector2(2.0, 2.0), // Adjust this value!
          roughnessMap: rockRoughnessTexture, // Apply the roughness map
          roughness: 1.0, // Base roughness, will be modulated by the map
          clearcoat: 0,
          clearcoatRoughness: 0,
        })
      ];
    }
    // ... upright materials ...
  }, [clonedFaceMap, clonedSideMap, doubleSided, headstoneStyle, rockNormalTexture, rockRoughnessTexture]); // Add rockRoughnessTexture to dependencies
Next Steps:

Implement Layered Voronoi: Replace your getHeight function with the layered version.

Implement Roughness Map: Generate and apply the roughnessMap.

Adjust normalScale: Start by setting normalScale to a high value like 5.0 or 10.0 initially, just to see the detail, then dial it back to a realistic level.

Experiment with textureDensity: Adjust this for different granularities of rock.

Lighting Test: Ensure your scene has strong, directional lighting.

By layering the noise, adding a roughness map, and fine-tuning the normalScale and textureDensity, you should see a much more dynamic and convincing "pitch rock" texture.