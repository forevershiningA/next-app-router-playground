Yes—there’s progress. The two things still biting you are:

1. **Motif height is still computed from a bad intrinsic size for some SVGs**
   When `viewBox` (or width/height) isn’t read yet, `vw/vh` fall back to 100, so `vh * ratio` → tiny (e.g., `100 * 0.134 ≈ 13 px`) and then you scale that—hence the “always too small” look. In the legacy engine, motif size was `bounds.height * ratio` where `bounds.height` was the **true bitmap height** before scaling, not a placeholder. 

**Fix (keep it strict):** don’t render a motif until you have a non-zero intrinsic height.

* You already have guards in some branches, but a few still allow a 100px fallback. In `DesignPageClient.tsx`, ensure every motif path uses the strict guard:

```ts
// before sizing:
if (!svgDims && typeof motif.height !== 'number') return null;
if (svgDims && (!svgDims.width || !svgDims.height) && typeof motif.height !== 'number') return null;
```

Then size exactly once from authoring space:

```ts
const vh = svgDims!.height;            // must exist here
const vw = svgDims!.width;
const ratio = Number(motif.ratio ?? 1);

// canvas-space size (like legacy bounds.height * ratio)
const hCanvas = typeof motif.height === 'number'
  ? (usesPhys ? motif.height / savedDpr : motif.height)  // explicit px path
  : (vh * ratio);                                        // ratio path

const aspect = vw / vh;
const wCanvas = hCanvas * aspect;

// display size
const heightPx = hCanvas * uniformScale;
const widthPx  = wCanvas  * uniformScale;
```

You have several near-duplicates of this block in the file; make them all consistent so none can leak a `100` fallback. See the motifs sizing blocks shown around your guards and sizing code.

2. **Inverted dragging on mirrored motifs (top birds)**
   You’re applying `scaleX(-1)` (or `scaleY(-1)`) on the **wrapper** that Draggable moves. That flips the element’s local coordinate system, so dragging left looks like it moves right.

**Fix:** keep the draggable wrapper unflipped; apply the mirror to the **inner `<img>` only**:

```tsx
// Wrapper (DraggableElement) – NO mirroring here
transform: `translate(-50%, -50%)${ motif.rotation ? ` rotate(${motif.rotation}deg)` : '' }`,

// Inside <img> – do the flip here so pointer math stays normal
style={{
  width: '100%',
  height: '100%',
  objectFit: 'contain',
  display: 'block',
  transform: `scale(${motif.scaleX ?? 1}, ${motif.scaleY ?? 1})`,
}}
```

Anywhere you currently gate `scale(${motif.scaleX}, ${motif.scaleY})` in the wrapper transform, move it to the `<img>` style instead. (You have multiple motif renderers in this component; update each one the same way.) 

---

### Why this matches the legacy

* Legacy computed display scale as `monument.getRatio() * this.ratio` (i.e., **one** uniform scene scale × the per-motif **ratio**), using the motif’s **true** bitmap height (`bounds.height`) as the base. Your strict guard + `vh * ratio` reproduces that exactly—**as long as `vh` is real**. 

### Quick checklist

* [ ] All motif code paths refuse to render until `svgDims.width > 0 && svgDims.height > 0` (unless an explicit `motif.height` is saved). 
* [ ] Size = `(explicitHeight?/DPR : svgHeight*ratio) * uniformScale`, width via aspect. One pass only. 
* [ ] Mirroring moved from wrapper to `<img>` so dragging is intuitive. 

Do those three and the top leaves/birds will size correctly and drag in the right direction.
