Got it. Here’s a clean, drop-in refinement you can paste into **svg-generator.ts**.
It fixes: (1) over-zoom/cropping, (2) base anchoring, (3) authoring-to-display coordinate mapping (no DPR, consistent scale), (4) centering/offsets, (5) HTML apostrophes, and (6) optional clipping to the stone outline so headers don’t spill outside.

```ts
// svg-generator.ts (refined core helpers)

type Num = number;

interface Viewport {
  w: Num;  // canvas width in px
  h: Num;  // canvas height in px
  pad?: Num; // optional padding inside the canvas
}

interface Authoring {
  w: Num;  // init_width (authoring canvas width, as saved)
  h: Num;  // init_height (authoring canvas height, as saved)
  origin: "topleft" | "center"; // how X/Y were saved in JSON
}

/** ------------------------------------------------------------------ */
/** 1) Utility: decode HTML entities (fixes Heaven&apos;s)              */
/** ------------------------------------------------------------------ */
export function decodeHtmlEntities(str: string): string {
  if (!str) return str;
  // Minimal, fast decode for common cases we actually see
  return str
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>');
}

/** ------------------------------------------------------------------ */
/** 2) Compute a DPR-agnostic, uniform scale that preserves layout     */
/**    exactly as authored, with optional inner padding.               */
/** ------------------------------------------------------------------ */
export function computeUniformScale(vp: Viewport, au: Authoring) {
  const pad = vp.pad ?? 0;
  const availW = Math.max(1, vp.w - pad * 2);
  const availH = Math.max(1, vp.h - pad * 2);

  // Contain the *authoring canvas* inside the viewport.
  const s = Math.min(availW / au.w, availH / au.h);

  // Center the authored canvas within the viewport.
  const ox = (vp.w - au.w * s) / 2;
  const oy = (vp.h - au.h * s) / 2;

  return { s, ox, oy };
}

/** ------------------------------------------------------------------ */
/** 3) Map a saved (authoring) coordinate to display coordinates.      */
/**    Works for both center-origin and top-left-origin JSONs.         */
/** ------------------------------------------------------------------ */
export function mapXY(
  xAuth: Num, yAuth: Num,
  vp: Viewport, au: Authoring,
  t = computeUniformScale(vp, au)
) {
  if (au.origin === "center") {
    // saved X,Y relative to authoring-center
    return {
      x: t.ox + (au.w / 2 + xAuth) * t.s,
      y: t.oy + (au.h / 2 + yAuth) * t.s,
    };
  }
  // saved X,Y are top-left based in authoring pixels
  return {
    x: t.ox + xAuth * t.s,
    y: t.oy + yAuth * t.s,
  };
}

export function mapSize(sizeAuthPx: Num, vp: Viewport, au: Authoring, t = computeUniformScale(vp, au)) {
  return sizeAuthPx * t.s;
}

/** ------------------------------------------------------------------ */
/** 4) Stone fit modes                                                 */
/**    - "contain-authoring": (DEFAULT) preserves the authored crop    */
/**      exactly (fixes motif/text drift across DPRs/devices).         */
/**    - "bottom-anchor-stone": aligns the stone outline to bottom     */
/**      of the authoring frame so the base is always visible.         */
/** ------------------------------------------------------------------ */
export type FitMode = "contain-authoring" | "bottom-anchor-stone";

export function computeTransform(
  vp: Viewport,
  au: Authoring,
  mode: FitMode = "contain-authoring",
  stoneBBoxAuth?: { x: Num; y: Num; w: Num; h: Num } // stone outline in authoring coords (pre-scale)
) {
  const t = computeUniformScale(vp, au);

  if (mode === "bottom-anchor-stone" && stoneBBoxAuth) {
    // Align the bottom of the stone to the bottom inner edge, preserving the authored X centering.
    const innerBottom = vp.h - (vp.pad ?? 0);
    const bottomAfter = t.oy + (stoneBBoxAuth.y + stoneBBoxAuth.h) * t.s;
    const deltaY = innerBottom - bottomAfter; // extra space to push down
    return { ...t, oy: t.oy + deltaY };
  }
  return t;
}

/** ------------------------------------------------------------------ */
/** 5) ClipPath helper so headings/quotes don’t spill off the stone.   */
/**    Pass the same path used to draw the stone.                      */
/** ------------------------------------------------------------------ */
export function stoneClipPath(id: string, stonePathD: string): string {
  return `
    <clipPath id="${id}" clipPathUnits="userSpaceOnUse">
      <path d="${stonePathD}" />
    </clipPath>
  `;
}

/** ------------------------------------------------------------------ */
/** 6) Example usage in your generator (pseudo integration)            */
/** ------------------------------------------------------------------ */
// const vp: Viewport = { w: canvasWidth, h: canvasHeight, pad: 12 };
// const au: Authoring = { w: init_width, h: init_height, origin: "center" }; // or "topleft"
// const tr = computeTransform(vp, au, "bottom-anchor-stone", stoneBBoxAuth);

// // Place a text at saved (x,y) with saved fontSize:
// const p = mapXY(savedX, savedY, vp, au, tr);
// const fontSize = mapSize(savedFontPx, vp, au, tr);

// // When emitting the quote:
// const quote = decodeHtmlEntities(savedQuoteText);

// // When emitting the SVG, clip the inscription/motifs group:
// const clipId = "stone-clip-1";
// const clipMarkup = stoneClipPath(clipId, stoneOutlinePathD);
// <g clip-path={"url(#" + clipId + ")"}> ... </g>
```

### What this fixes (directly tied to the symptoms)

* **Over-zoom & missing base**
  Use `computeTransform(..., "bottom-anchor-stone", stoneBBoxAuth)` so the stone’s **bottom** sits on the inner bottom line. The base no longer gets cropped, and the whole composition stops “floating up.”

* **Layout drift across devices**
  Mapping is now **strictly authoring-pixel → display** with one uniform scale and centered offsets. **No DPR logic** anywhere.

* **Header/quote spilling & `&apos;`**
  `decodeHtmlEntities()` converts `Heaven&apos;s → Heaven’s`.
  If you wrap the inscriptions/motifs in the **clip path** created by `stoneClipPath()`, nothing can render outside the stone silhouette.

* **Motifs/text too high or too close to center**
  Everything uses **the same transform** (`tr`) derived from the authoring canvas. If your JSON was saved with center-origin, set `origin: "center"`. If it was saved with top-left, set `origin: "topleft"`. (You can detect this once from legacy fields and keep it.)

* **Base block misaligned**
  Map the base with the same `mapXY`/`mapSize` pairing as other elements. Anchoring mode ensures the bottom edge is true.

---

#### Integration notes

1. **Choose the correct origin once**

   * Legacy desktop JSONs often saved centered X/Y → use `origin: "center"`.
   * Some mobile (iPhone) JSONs saved top-left → use `origin: "topleft"`.

2. **Pass a stone bbox** (authoring coords) for bottom anchoring.

   * If you have the stone’s path viewBox, you can compute it once when you load the shape. Example: `{x:0,y:0,w:400,h:460}` in authoring pixels.

3. **Apply the same transform to EVERYTHING**
   Headline, quote, names, motifs, base — all use `mapXY` + `mapSize` with the single `tr`.

4. **Optional max width for the quote**
   If you want to guarantee the quote never overflows even before clipping, set an SVG `<text>` `textLength` to `0.9 * vp.w` and `lengthAdjust="spacingAndGlyphs"` or render it as `<foreignObject>` with word-wrap.

---

If you paste these helpers in and switch your placement/rendering calls to use `computeTransform` + `mapXY`/`mapSize` + `decodeHtmlEntities` (and add the optional clipPath), the screenshot you posted will line up with the original screen: base visible, header/quote contained, center figure and name blocks back in their proper lanes.
