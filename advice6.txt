This version implements a high-performance optimization strategy.

Key Changes:

Geometry Resolution Reduction: Reduced curveSegments to 6 (from 24). This reduces the triangle count by ~75% while the roughness texture hides the lower poly count. This is the biggest performance win.

Allocation-Free Slicing: Rewrote sliceGeometryAxis to use Float32Array directly. The previous version created millions of temporary Javascript Objects and Arrays (Garbage Collection thrashing) while dragging. This version does pure math on pre-allocated buffers.

Optimized Caching: The base geometry is computed once and reused.

code
Tsx
download
content_copy
expand_less
/**
 * Bronze Plaque Border Component
 * Renders decorative 3D borders using extruded SVG geometry.
 * Optimized for performance: Reduced poly count & allocation-free geometry slicing.
 */

'use client';

import React, { useEffect, useRef, useState, useMemo } from 'react';
import * as THREE from 'three';
import { SVGLoader, type SVGResult } from 'three/examples/jsm/loaders/SVGLoader.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

interface BronzeBorderProps {
  borderName: string | null;
  plaqueWidth: number;
  plaqueHeight: number;
  unitsPerMeter: number;
  frontZ: number;
  color: string;
  depth: number;
}

// Global cache for base SVG geometries
const GEOMETRY_CACHE = new Map<string, THREE.BufferGeometry>();

const BORDER_SLUG_ALIASES: Record<string, string> = {
  bar: 'border1',
  square: 'border2',
  solidoutline: 'border3',
  solid: 'border4',
  notch: 'border5',
  scallop: 'border6',
  roundoutline: 'border7',
  floral: 'border8',
  decorative: 'border9',
  squareangular: 'border10',
};

// --- CONFIGURATION ---
const BORDER_SCALE = 1.3;
const BORDER_THICKNESS_SCALE = 1.5;
const BORDER_RELIEF_SCALE = 0.33;
const OVERLAP_BUFFER = 1.0; // Overlap slice by 1mm

// --- PERFORMANCE TUNING ---
// Reducing these values massively improves slice performance during drag
const CURVE_SEGMENTS = 6;  // Was 24. 6 is enough for textured metal.
const BEVEL_SEGMENTS = 1;  // Keep minimal bevel

interface BronzeTextures {
  map: THREE.CanvasTexture;
  roughnessMap: THREE.CanvasTexture;
}

// --- Geometry Helpers ---

function normalizeGeometry(geometry: THREE.BufferGeometry) {
  let geom = geometry;
  if (geom.index) {
    const nonIndexed = geom.toNonIndexed();
    geom.dispose();
    geom = nonIndexed;
  }

  if (!geom.getAttribute('normal')) geom.computeVertexNormals();

  if (!geom.getAttribute('uv')) {
    const position = geom.getAttribute('position') as THREE.BufferAttribute;
    const count = position.count;
    const uvs = new Float32Array(count * 2);
    for (let i = 0; i < count; i++) {
        uvs[i * 2] = position.getX(i);
        uvs[i * 2 + 1] = position.getY(i);
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  }

  geom.computeBoundingBox();
  return geom;
}

/**
 * HIGH PERFORMANCE SLICER
 * Uses TypedArrays directly to avoid Garbage Collection pauses during drag.
 * Eliminates all object allocation inside the loop.
 */
function sliceGeometryAxis(
  geometry: THREE.BufferGeometry, 
  axis: 'x' | 'y', 
  limit: number, 
  keepCondition: 'less' | 'greater'
): THREE.BufferGeometry {
  const posAttr = geometry.getAttribute('position');
  const uvAttr = geometry.getAttribute('uv');
  const normAttr = geometry.getAttribute('normal');
  const count = posAttr.count;

  // Pre-allocate output buffers. 
  // In worst case (heavy fragmentation), size could grow, but 1.0x is usually safe for slicing 
  // since we remove more than we add. We use a growth factor just in case.
  const maxVerts = Math.floor(count * 1.2); 
  
  const outPos = new Float32Array(maxVerts * 3);
  const outUV = new Float32Array(maxVerts * 2);
  const outNorm = new Float32Array(maxVerts * 3);
  
  let vIdx = 0; // Vertex index pointer

  const axisIdx = axis === 'x' ? 0 : 1;
  const isKept = (val: number) => keepCondition === 'less' ? val < limit : val > limit;

  // Temporary registers to avoid object creation
  let ax, ay, az, bx, by, bz, cx, cy, cz;
  let au, av, bu, bv, cu, cv;
  let anx, any, anz, bnx, bny, bnz, cnx, cny, cnz;
  let ka, kb, kc; // keep flags
  let t;

  // Helper to push vertex to buffer
  const pushV = (x:number, y:number, z:number, u:number, v:number, nx:number, ny:number, nz:number) => {
    if (vIdx >= maxVerts) return; // Safety check
    const i3 = vIdx * 3;
    const i2 = vIdx * 2;
    outPos[i3] = x; outPos[i3+1] = y; outPos[i3+2] = z;
    outUV[i2] = u; outUV[i2+1] = v;
    outNorm[i3] = nx; outNorm[i3+1] = ny; outNorm[i3+2] = nz;
    vIdx++;
  };

  // Helper to interpolate and push
  const interpPush = (
    x1:number, y1:number, z1:number, u1:number, v1:number, nx1:number, ny1:number, nz1:number,
    x2:number, y2:number, z2:number, u2:number, v2:number, nx2:number, ny2:number, nz2:number,
    val1:number, val2:number
  ) => {
    t = (limit - val1) / (val2 - val1);
    pushV(
      x1 + (x2-x1)*t, y1 + (y2-y1)*t, z1 + (z2-z1)*t,
      u1 + (u2-u1)*t, v1 + (v2-v1)*t,
      nx1 + (nx2-nx1)*t, ny1 + (ny2-ny1)*t, nz1 + (nz2-nz1)*t
    );
  };

  for (let i = 0; i < count; i += 3) {
    // 1. Load Triangle Data
    ax = posAttr.getX(i);   ay = posAttr.getY(i);   az = posAttr.getZ(i);
    bx = posAttr.getX(i+1); by = posAttr.getY(i+1); bz = posAttr.getZ(i+1);
    cx = posAttr.getX(i+2); cy = posAttr.getY(i+2); cz = posAttr.getZ(i+2);

    ka = isKept(axisIdx === 0 ? ax : ay);
    kb = isKept(axisIdx === 0 ? bx : by);
    kc = isKept(axisIdx === 0 ? cx : cy);

    // Fast Path: All Out
    if (!ka && !kb && !kc) continue;

    // Load attributes only if needed
    au = uvAttr.getX(i);   av = uvAttr.getY(i);
    bu = uvAttr.getX(i+1); bv = uvAttr.getY(i+1);
    cu = uvAttr.getX(i+2); cv = uvAttr.getY(i+2);

    anx = normAttr.getX(i);   any = normAttr.getY(i);   anz = normAttr.getZ(i);
    bnx = normAttr.getX(i+1); bny = normAttr.getY(i+1); bnz = normAttr.getZ(i+1);
    cnx = normAttr.getX(i+2); cny = normAttr.getY(i+2); cnz = normAttr.getZ(i+2);

    // Fast Path: All In
    if (ka && kb && kc) {
      pushV(ax, ay, az, au, av, anx, any, anz);
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      continue;
    }

    // Clipping Needed - Rotate triangle so 'A' is strictly 'In' (or 'Out' if 2 are in)
    // We normalize to: A is In.
    // Logic: If 1 In, rotate it to A. If 2 In, rotate the OUT to C (so A, B are In).
    
    // Determine configuration
    // Configurations (1=In, 0=Out): 
    // 001 (C in), 010 (B in), 100 (A in) -> 1 In cases
    // 011 (BC in), 101 (AC in), 110 (AB in) -> 2 In cases

    if (ka && !kb && !kc) { 
      // A in, B out, C out (Triangle -> 1 Triangle)
      pushV(ax, ay, az, au, av, anx, any, anz);
      interpPush(ax,ay,az,au,av,anx,any,anz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?ax:ay, axisIdx===0?bx:by);
      interpPush(ax,ay,az,au,av,anx,any,anz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?ax:ay, axisIdx===0?cx:cy);
    }
    else if (!ka && kb && !kc) {
      // B in (Rotate B->A)
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?bx:by, axisIdx===0?cx:cy);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?bx:by, axisIdx===0?ax:ay);
    }
    else if (!ka && !kb && kc) {
      // C in (Rotate C->A)
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?cx:cy, axisIdx===0?ax:ay);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?cx:cy, axisIdx===0?bx:by);
    }
    else if (ka && kb && !kc) {
      // A, B in, C out (Quad -> 2 Triangles)
      // Tri 1
      pushV(ax, ay, az, au, av, anx, any, anz);
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?bx:by, axisIdx===0?cx:cy);
      // Tri 2
      pushV(ax, ay, az, au, av, anx, any, anz);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?bx:by, axisIdx===0?cx:cy);
      interpPush(ax,ay,az,au,av,anx,any,anz, cx,cy,cz,cu,cv,cnx,cny,cnz, axisIdx===0?ax:ay, axisIdx===0?cx:cy);
    }
    else if (!ka && kb && kc) {
      // B, C in, A out
      // Tri 1
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?cx:cy, axisIdx===0?ax:ay);
      // Tri 2
      pushV(bx, by, bz, bu, bv, bnx, bny, bnz);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?cx:cy, axisIdx===0?ax:ay);
      interpPush(bx,by,bz,bu,bv,bnx,bny,bnz, ax,ay,az,au,av,anx,any,anz, axisIdx===0?bx:by, axisIdx===0?ax:ay);
    }
    else if (ka && !kb && kc) {
      // A, C in, B out
      // Tri 1
      pushV(ax, ay, az, au, av, anx, any, anz);
      interpPush(ax,ay,az,au,av,anx,any,anz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?ax:ay, axisIdx===0?bx:by);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
      // Tri 2
      interpPush(ax,ay,az,au,av,anx,any,anz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?ax:ay, axisIdx===0?bx:by);
      interpPush(cx,cy,cz,cu,cv,cnx,cny,cnz, bx,by,bz,bu,bv,bnx,bny,bnz, axisIdx===0?cx:cy, axisIdx===0?bx:by);
      pushV(cx, cy, cz, cu, cv, cnx, cny, cnz);
    }
  }

  const newGeom = new THREE.BufferGeometry();
  // Trim arrays to actual used size
  newGeom.setAttribute('position', new THREE.BufferAttribute(outPos.slice(0, vIdx * 3), 3));
  newGeom.setAttribute('uv', new THREE.BufferAttribute(outUV.slice(0, vIdx * 2), 2));
  newGeom.setAttribute('normal', new THREE.BufferAttribute(outNorm.slice(0, vIdx * 3), 3));
  
  return newGeom;
}

// --- Textures ---

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));

function shiftLuminance(hex: string, delta: number) {
  const color = new THREE.Color(hex);
  const hsl = { h: 0, s: 0, l: 0 };
  color.getHSL(hsl);
  const next = new THREE.Color();
  next.setHSL(hsl.h, clamp01(hsl.s + delta * 0.15), clamp01(hsl.l + delta));
  return `#${next.getHexString()}`;
}

function createBronzeTextures(baseHex: string): BronzeTextures | null {
  if (typeof document === 'undefined') return null;

  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = mapCanvas.height = 512;
  const mapCtx = mapCanvas.getContext('2d');
  if (!mapCtx) return null;

  const gradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
  gradient.addColorStop(0, shiftLuminance(baseHex, 0.2));
  gradient.addColorStop(0.6, baseHex);
  gradient.addColorStop(1, shiftLuminance(baseHex, -0.2));
  mapCtx.fillStyle = gradient;
  mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

  // Simple noise
  mapCtx.globalAlpha = 0.08;
  mapCtx.fillStyle = '#fff';
  for(let i=0; i<500; i++) mapCtx.fillRect(Math.random()*512, Math.random()*512, 2, 2);

  const mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;

  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = 256;
  const roughCtx = roughCanvas.getContext('2d');
  if(!roughCtx) return { map: mapTexture, roughnessMap: mapTexture };
  
  roughCtx.fillStyle = '#888';
  roughCtx.fillRect(0,0,256,256);
  
  const roughnessMap = new THREE.CanvasTexture(roughCanvas);

  return { map: mapTexture, roughnessMap };
}

export function BronzeBorder({
  borderName,
  plaqueWidth,
  plaqueHeight,
  unitsPerMeter,
  frontZ,
  color,
  depth,
}: BronzeBorderProps) {
  const unitScale = Math.max(1e-6, Math.abs(unitsPerMeter) || 1);
  const localWidth = Math.max(1e-3, Math.abs(plaqueWidth) * unitScale);
  const localHeight = Math.max(1e-3, Math.abs(plaqueHeight) * unitScale);

  const normalizedName = borderName?.toLowerCase() ?? '';
  const effectiveName = normalizedName.includes('no border') ? null : borderName;
  const slug = effectiveName ? toBorderSlug(effectiveName) : null;
  const resolvedSlug = slug ? `${slug}a` : null;
  const usesIntegratedRails = Boolean(resolvedSlug);
  const shouldRender = Boolean(resolvedSlug && localWidth > 0 && localHeight > 0);

  const bronzeTextures = useMemo(() => createBronzeTextures(color), [color]);
  const groupRef = useRef<THREE.Group>(null);
  
  // Debounce State
  const [debouncedDims, setDebouncedDims] = useState({ w: localWidth, h: localHeight });
  const [isResizing, setIsResizing] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Handle Resize Debouncing
  useEffect(() => {
    setIsResizing(true);
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    
    // During drag, user sees scaled geometry (fast).
    // 150ms after drag stops, geometry is rebuilt (slow but accurate).
    timeoutRef.current = setTimeout(() => {
      setDebouncedDims({ w: localWidth, h: localHeight });
      setIsResizing(false);
    }, 150);

    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, [localWidth, localHeight]);

  // Visual scaling during resize (Fast Path)
  useEffect(() => {
    if (groupRef.current && isResizing) {
      const currentScaleX = localWidth / debouncedDims.w;
      const currentScaleY = localHeight / debouncedDims.h;
      groupRef.current.scale.set(currentScaleX, currentScaleY, 1);
    } else if (groupRef.current && !isResizing) {
      groupRef.current.scale.set(1, 1, 1);
    }
  }, [localWidth, localHeight, isResizing, debouncedDims]);


  const [svgData, setSvgData] = useState<SVGResult | null>(null);
  const [borderMesh, setBorderMesh] = useState<THREE.Mesh | null>(null);

  useEffect(() => {
    return () => {
      bronzeTextures?.map.dispose();
      bronzeTextures?.roughnessMap.dispose();
    };
  }, [bronzeTextures]);

  useEffect(() => {
    if (!resolvedSlug) {
      setSvgData(null);
      return;
    }

    const loader = new SVGLoader();
    loader.load(
      `/shapes/borders/${resolvedSlug}.svg`,
      (data) => setSvgData(data),
      undefined,
      (err) => console.warn(err)
    );
  }, [resolvedSlug]);

  useEffect(() => {
    if (!shouldRender || !svgData) {
      setBorderMesh(null);
      return;
    }

    // HEAVY COMPUTATION - Runs on debounced state change
    const result = buildBorderMesh(svgData, {
      plaqueWidth: debouncedDims.w,
      plaqueHeight: debouncedDims.h,
      depth,
      color,
      frontZ,
      textures: bronzeTextures ?? undefined,
      integratedRails: usesIntegratedRails,
      slug: resolvedSlug || ''
    });

    if (result) {
      setBorderMesh(result);
    }
    
    return () => {
      if (result) {
        result.geometry.dispose();
        if (result.material instanceof THREE.Material) result.material.dispose();
      }
    };
  }, [svgData, shouldRender, debouncedDims, depth, color, frontZ, bronzeTextures, resolvedSlug]);

  if (!borderMesh) return null;

  return <primitive object={borderMesh} ref={groupRef} />;
}

function toBorderSlug(name: string) {
  const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const alias = BORDER_SLUG_ALIASES[normalized];
  if (alias) return alias;
  const match = name.match(/\d+/);
  return match ? `border${match[0]}` : normalized || 'border1';
}

function buildBorderMesh(
  data: SVGResult,
  params: {
    plaqueWidth: number;
    plaqueHeight: number;
    depth: number;
    color: string;
    frontZ: number;
    textures?: BronzeTextures;
    integratedRails?: boolean;
    slug: string;
  },
): THREE.Mesh | null {
  const { plaqueWidth, plaqueHeight, color, frontZ, textures, integratedRails, slug } = params;
  const width = Math.max(1e-3, Math.abs(plaqueWidth));
  const height = Math.max(1e-3, Math.abs(plaqueHeight));

  const reliefDepthBase = Math.max(0.001, Math.min(width, height) * 0.003);
  const reliefDepth = reliefDepthBase * BORDER_RELIEF_SCALE;

  // 1. Get Base Geometry (Cached or New)
  let baseGeometry = GEOMETRY_CACHE.get(slug);

  if (!baseGeometry) {
    const extrudeSettings = {
      depth: reliefDepth,
      bevelEnabled: true,
      bevelSegments: BEVEL_SEGMENTS,
      bevelSize: reliefDepth * 0.35,
      bevelThickness: reliefDepth * 0.35,
      steps: 1,
      curveSegments: CURVE_SEGMENTS, // Performance optimization here
    };

    const shapes: THREE.Shape[] = [];
    data.paths.forEach((path) => {
      shapes.push(...SVGLoader.createShapes(path));
    });

    if (shapes.length === 0) return null;

    const rawGeom = new THREE.ExtrudeGeometry(shapes, extrudeSettings);
    baseGeometry = normalizeGeometry(rawGeom);
    
    // Center the base geometry
    baseGeometry.computeBoundingBox();
    const bb = baseGeometry.boundingBox!;
    const cx = (bb.max.x + bb.min.x) / 2;
    const cy = (bb.max.y + bb.min.y) / 2;
    baseGeometry.translate(-cx, -cy, 0);

    GEOMETRY_CACHE.set(slug, baseGeometry);
  }

  // Clone base for manipulation
  const merged = baseGeometry.clone();

  // 2. Scaling Logic
  const bb = merged.boundingBox || new THREE.Box3(); 
  if (!merged.boundingBox) merged.computeBoundingBox();
  const originalWidth = merged.boundingBox!.max.x - merged.boundingBox!.min.x;
  const originalHeight = merged.boundingBox!.max.y - merged.boundingBox!.min.y;

  const edgeThicknessBase = Math.max(0.01, Math.min(width, height) * 0.02 * BORDER_SCALE);
  const edgeThickness = edgeThicknessBase * BORDER_THICKNESS_SCALE;
  const lineThickness = edgeThickness * 0.4;

  if (integratedRails) {
    const uniformScale = Math.min(width / originalWidth, height / originalHeight);
    merged.scale(uniformScale, uniformScale, 1);
  } else {
    const targetCornerSpan = Math.max(lineThickness * 6, Math.min(width, height) * 0.25);
    const baseScale = (targetCornerSpan / Math.max(originalWidth, originalHeight)) * 0.7;
    merged.scale(baseScale, baseScale, 1);
  }

  const textureRepeatX = Math.max(1, width / 120);
  const textureRepeatY = Math.max(1, height / 120);

  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(color),
    metalness: 0.95,
    roughness: 0.28,
    envMapIntensity: 1.5,
    clearcoat: 0.7,
    clearcoatRoughness: 0.18,
    side: THREE.DoubleSide,
  });

  if (textures?.map) {
    textures.map.repeat.set(textureRepeatX, textureRepeatY);
    material.map = textures.map;
  }
  if (textures?.roughnessMap) {
    textures.roughnessMap.repeat.set(textureRepeatX, textureRepeatY);
    material.roughnessMap = textures.roughnessMap;
  }

  const cornerParts: THREE.BufferGeometry[] = [];
  const SURFACE_Z = frontZ + 0.0001;

  const createCornerMesh = (
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    let geom = merged.clone();

    // Orientation
    const flipX = alignX === 'right';
    const flipY = alignY === 'top';
    if (flipX) geom.scale(-1, 1, 1);
    if (flipY) geom.scale(1, -1, 1);

    // Fix Winding Order if flipped asymmetrically to prevent lighting issues
    if (flipX !== flipY) {
      const pos = geom.getAttribute('position');
      for (let i = 0; i < pos.count; i += 3) {
        const x2 = pos.getX(i + 1), y2 = pos.getY(i + 1), z2 = pos.getZ(i + 1);
        const x3 = pos.getX(i + 2), y3 = pos.getY(i + 2), z3 = pos.getZ(i + 2);
        pos.setXYZ(i + 1, x3, y3, z3);
        pos.setXYZ(i + 2, x2, y2, z2);
      }
    }

    geom = normalizeGeometry(geom);
    geom.computeBoundingBox();
    const bounds = geom.boundingBox!;
    const posX = alignX === 'left' ? -width / 2 - bounds.min.x : width / 2 - bounds.max.x;
    const posY = alignY === 'top' ? height - bounds.max.y : 0 - bounds.min.y;
    geom.translate(posX, posY, SURFACE_Z);
    
    // Re-calc UVs for uniform look
    const posAttr = geom.getAttribute('position');
    const uvs = geom.getAttribute('uv');
    for (let i = 0; i < posAttr.count; i++) {
        uvs.setXY(i, posAttr.getX(i), posAttr.getY(i));
    }

    // --- Optimized Slicing with Buffer ---
    // X Cut
    if (alignX === 'left') {
      geom = sliceGeometryAxis(geom, 'x', OVERLAP_BUFFER, 'less');
    } else {
      geom = sliceGeometryAxis(geom, 'x', -OVERLAP_BUFFER, 'greater');
    }

    // Y Cut
    if (alignY === 'top') {
      geom = sliceGeometryAxis(geom, 'y', (height / 2) - OVERLAP_BUFFER, 'greater');
    } else {
      geom = sliceGeometryAxis(geom, 'y', (height / 2) + OVERLAP_BUFFER, 'less');
    }

    geom.computeVertexNormals();
    cornerParts.push(geom);
  };

  createCornerMesh('left', 'top');
  createCornerMesh('right', 'top');
  createCornerMesh('left', 'bottom');
  createCornerMesh('right', 'bottom');

  if (cornerParts.length === 0) return null;

  const finalGeom = mergeGeometries(cornerParts, false);
  merged.dispose(); 
  cornerParts.forEach(g => g.dispose()); 

  const mesh = new THREE.Mesh(finalGeom, material);
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  mesh.renderOrder = 3;

  return mesh;
}