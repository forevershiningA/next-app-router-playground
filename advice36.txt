You’ve done most of the hard work—the slant geometry and a wrapper group meant to carry the inscriptions are correct. The reason it still looks “upright” is almost always one (or more) of these:

1. the wrapper’s quaternion isn’t actually being applied (prop not sticking),
2. a child component is undoing the rotation (billboard/lookAt/Html without transform), or
3. children are being placed on z=0 of the wrapper instead of slightly “out of” the face normal.

Here’s a tight, surgical checklist and patches against your current `SvgHeadstone.tsx`:

---

### A. Force-apply the quaternion (don’t rely on the prop diff)

Sometimes R3F won’t copy a stable Quaternion object on first render. Copy it once after mount.

```ts
// under your refs
const scaledWrapperRef = useRef<THREE.Group>(null!);

// add:
useLayoutEffect(() => {
  if (scaledWrapperRef.current && childWrapperRotation) {
    scaledWrapperRef.current.quaternion.copy(childWrapperRotation);
  }
}, [childWrapperRotation]);
```

(Keep the `quaternion={childWrapperRotation}` prop too—it won’t hurt.) 

---

### B. Prove the wrapper is tilted (debug plane)

Drop a thin plane as a canary inside the wrapper. If this is visibly tilted, the issue is in the child components (not the wrapper).

```tsx
<group ref={scaledWrapperRef} position={childWrapperPos} quaternion={childWrapperRotation}>
  {/* DEBUG: should appear as a tilted, paper-thin card on the face */}
  <mesh position={[0, apiData.worldHeight * 0.5, apiData.frontZ]}>
    <planeGeometry args={[apiData.worldWidth * 0.8, apiData.worldHeight * 0.2]} />
    <meshBasicMaterial color="hotpink" transparent opacity={0.15} depthTest />
  </mesh>

  <group scale={meshScale}>
    {typeof children === 'function' && children(childApi, selectedAdditions)}
  </group>
</group>
```

If this plane is slanted but your inscriptions aren’t, your text/motif components are overriding orientation.

---

### C. Stop children from “standing up” again

In your inscription/motif/addition components, remove anything that re-orients to camera:

* No `<Billboard>` wrappers.
* `<Text>`: ensure `billboard={false}` (default) and no `lookAt`.
* `<Html>`: **must** be `<Html transform ...>` so it respects parent rotation.
* No `useFrame(() => mesh.lookAt(camera.position))`.

If you need 2D UI gizmos, render them in a sibling group, not under the slant wrapper.

---

### D. Place content on the face normal, not the wrapper’s origin

You already expose `apiData.frontZ = 0.001` for slants. Make sure all children use it:

```tsx
// good: a tiny positive Z in the WRAPPER’s local space
<group position={[xLocal, yLocal, api.frontZ]}> ... </group>
```

If they sit at `z=0`, coplanar z-fighting with the granite can make them look “melted” into the face and read as flat.

---

### E. Validate the angle you’re giving the wrapper

Your calculation is right; just confirm the sign and magnitude visually:

```ts
// where you compute the quaternion
const slantAngleRad = Math.atan2(frontTopZOffset, height_svg_units);
// outward face normal (tilts back at top)
const frontNormal = new THREE.Vector3(0, Math.sin(slantAngleRad), Math.cos(slantAngleRad)).normalize();
const childWrapperRotation = new THREE.Quaternion()
  .setFromUnitVectors(new THREE.Vector3(0,0,1), frontNormal);
```

If you log `THREE.MathUtils.radToDeg(slantAngleRad)`, you should see ~10–25° for typical slants. 

---

### F. One quick consumer-side fix (if you can’t edit child code today)

Wrap each inscription/motif in a neutralizing group that prevents internal “lookAt” from winning:

```tsx
// in the children render function
<group rotation={[0,0,0]} /* neutral */ >
  <group position={[x, y, api.frontZ]} rotation={[0,0,0]}>
    {/* your Text/Mesh here, ensure no billboard/lookAt */}
  </group>
</group>
```

---

### G. Sanity test: axes helper

For 10 seconds of certainty, add this under the wrapper:

```tsx
<axesHelper args={[0.2]} />
```

You should see the axes tilt with the face. If not, the quaternion isn’t landing—recheck (A).

---

Follow A+B first. If the debug plane tilts, the fix is C+D in your inscription/motif components. After these, the content will sit flush and visibly follow the slant. 
