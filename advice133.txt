The main reason auto-rotation isn't working is a time reference mismatch.

In useFrame, you are using state.clock.elapsedTime (which starts at 0 when the 3D scene loads). However, in OrbitControls onChange, you are using performance.now() / 1000 (which starts at 0 when the browser tab opens).

Because performance.now() is almost always much larger than clock.elapsedTime, the calculation timeSinceInteraction results in a large negative number, effectively preventing the auto-rotation from ever starting.

Here is the fixed SceneContent component. I have added useThree to get the shared clock instance so both timers are synchronized.

code
Tsx
download
content_copy
expand_less
// ... imports remain the same
import { useThree } from '@react-three/fiber'; // Import useThree

// ... (Constants, Materials, Geometry components remain the same)

// --- Scene Setup ---

const SceneContent = ({ targetRotation }: { targetRotation: number }) => {
  const groupRef = useRef<THREE.Group>(null);
  const lastInteractionTime = useRef(0);
  const controlsRef = useRef<any>(null);
  
  // 1. Get the shared clock from R3F state
  const { clock } = useThree(); 
  
  const textZ = (STONE_THICKNESS / 2) + BEVEL_SIZE + 0.02;

  useFrame((state, delta) => {
    if (groupRef.current) {
      const step = 0.1;
      const diff = targetRotation - groupRef.current.rotation.y;
      
      // Handle Arrow Button Animation
      if (Math.abs(diff) > 0.001) {
        groupRef.current.rotation.y += diff * step;
        // Reset timer to current clock time so it doesn't snap to auto-rotate immediately after
        lastInteractionTime.current = state.clock.elapsedTime; 
        return; 
      }
      
      // Auto-rotation Logic
      const timeSinceInteraction = state.clock.elapsedTime - lastInteractionTime.current;
      const AUTO_ROTATE_DELAY = 3; 
      
      if (timeSinceInteraction > AUTO_ROTATE_DELAY) {
        groupRef.current.rotation.y += delta * 0.15;
      }
    }
  });

  return (
    <>
      <group ref={groupRef} position={[0, -1.35, 0]}>
        <SerpentineHeadstone width={STONE_WIDTH} height={STONE_HEIGHT} thickness={STONE_THICKNESS} />
        <Base stoneWidth={STONE_WIDTH} />
        
        <group position={[0, 0, 0]}>
          <GoldText
            position={[0, BASE_HEIGHT + STONE_HEIGHT * 0.60, textZ]}
            fontSize={0.11}
            text="In Loving Memory"
            font="/fonts/Garamond.ttf"
          />
          
          <GoldText
            position={[0, BASE_HEIGHT + STONE_HEIGHT * 0.50, textZ]}
            fontSize={0.22}
            text="Eleanor Rose"
            font="/fonts/Garamond.ttf"
            fontWeight="bold"
          />
          
          <GoldText
            position={[0, BASE_HEIGHT + STONE_HEIGHT * 0.40, textZ]}
            fontSize={0.11}
            text="☼ 1945   ✟ 2023"
            font="/fonts/Garamond.ttf"
          />
        </group>
      </group>
      
      <ContactShadows 
        position={[0, -1.35, 0]}
        opacity={0.4} 
        scale={10} 
        blur={2} 
        far={3} 
        resolution={512} 
        color="#000000"
      />
      
      <OrbitControls
        ref={controlsRef}
        enablePan={false}
        enableZoom={false}
        enableRotate={true}
        minPolarAngle={0} 
        maxPolarAngle={Math.PI / 2 - 0.05} 
        enableDamping={true}
        dampingFactor={0.05}
        // 2. FIX: Use the shared clock.getElapsedTime() instead of performance.now()
        onChange={() => {
          lastInteractionTime.current = clock.getElapsedTime();
        }}
      />
    </>
  );
};

// ... (Export default HeroCanvas remains the same)