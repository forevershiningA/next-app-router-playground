Short answer: your motifs are still sizing from a **bad intrinsic height** in a few code paths, so `vh * ratio` ends up using the 100-px fallback and then you scale that—hence they stay small. Also, one branch is still applying **an extra scale** after `uniformScale`.

Here’s exactly what to fix.

## What’s wrong

* `getIntrinsicDims()` returns `{vw:100, vh:100}` when it can’t read a `viewBox`. Some motif renders still proceed with those defaults, so `h = vh * ratio` → tiny. Block that fallback and wait for real `vw/vh`. 
* In one motif branch you’re multiplying by **another display scale** after you already applied `uniformScale`. That double-scales *down* the motif.

## Make them bigger (safe + deterministic)

**1) Refuse to render a ratio-sized motif until real intrinsic dims are loaded.**

```ts
// BEFORE any size math for a motif that uses ratio:
const dims = svgDimensionsByMotifId[motif.id]; // or however you store per-motif dims
const hasExplicitPx = typeof motif.height === 'number' || typeof motif.width === 'number';

if (!hasExplicitPx) {
  // Only ratio → must have real viewBox numbers
  if (!dims || !dims.width || !dims.height || dims.width === 100 || dims.height === 100) {
    return null; // don't render yet; avoid 100px fallback
  }
}
```

**2) Size from authoring units once, then scale once.**

```ts
// Inputs you already have:
const dpr       = scalingFactors.designDpr || 1;
const usesPhys  = scalingFactors.usesPhysicalCoords || false;
const { uniformScale, initW, initH, offsetX, offsetY } = scalingFactors;

// ---- position (center-origin to top-left in canvas units) ----
const rawX = motif.x ?? motif.cx ?? 0;
const rawY = motif.y ?? motif.cy ?? 0;
const xCanvas = usesPhys ? rawX / dpr : rawX;
const yCanvas = usesPhys ? rawY / dpr : rawY;

const left = offsetX + (xCanvas + initW/2) * uniformScale;
const top  = offsetY + (yCanvas + initH/2) * uniformScale;

// ---- size ----
const ratio = Number(motif.ratio ?? 1);
const vw = hasExplicitPx ? 0 : dims.width;   // guaranteed real by guard
const vh = hasExplicitPx ? 0 : dims.height;

const hCanvas = hasExplicitPx
  ? (usesPhys ? (motif.height ?? motif.width!) / dpr : (motif.height ?? motif.width!))
  : (vh * ratio);                 // ratio is against intrinsic authoring height

const wCanvas = hasExplicitPx
  ? (typeof motif.width === 'number'
       ? (usesPhys ? motif.width / dpr : motif.width)
       : hCanvas * (vw / vh))
  : hCanvas * (vw / vh);

// Final pixels — SCALE ONCE
const heightPx = hCanvas * uniformScale;
const widthPx  = wCanvas  * uniformScale;

const style: React.CSSProperties = {
  position: 'absolute',
  left, top,
  width: `${widthPx}px`,
  height: `${heightPx}px`,
  transform: 'translate(-50%, -50%)',
  transformOrigin: 'center center',
  pointerEvents: 'none',
};
```

**3) Remove any extra multiplier** (e.g., `displayScale`, `deviceScale`, or another `uniformScale`) in motif code paths. Motifs and inscriptions should both end at:
`final_px = canvas_units * uniformScale` — nothing else.

**4) Make sure the intrinsic loader always tries *both* paths** (cleaned filename and “with spaces”) before giving up; don’t accept 100×100 as “real”. Your helper already supports this—use it everywhere you size motifs. 

## One-line console to verify

```ts
console.log('motif check', {
  ratio, vw: dims?.width, vh: dims?.height,
  hCanvas, heightPx, uniformScale
});
```

Expect `vh` to be the real SVG height (often hundreds/thousands), `hCanvas = vh*ratio` (when no explicit px), and `heightPx = hCanvas*uniformScale`.

Apply those four points and the motifs will jump to the legacy-correct size.
