--- START OF FILE BronzeBorder.tsx ---

/**
 * Bronze Plaque Border Component
 * Renders decorative 3D borders using extruded SVG geometry at plaque scale
 */

'use client';

import React, { useCallback, useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { SVGLoader, type SVGResult } from 'three/examples/jsm/loaders/SVGLoader.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

interface BronzeBorderProps {
  borderName: string | null;
  plaqueWidth: number;
  plaqueHeight: number;
  unitsPerMeter: number;
  frontZ: number;
  color: string;
  depth: number;
}

interface BorderResources {
  geometries: THREE.BufferGeometry[];
  material?: THREE.Material;
}

const BORDER_SLUG_ALIASES: Record<string, string> = {
  bar: 'border1',
  square: 'border2',
  solidoutline: 'border3',
  solid: 'border4',
  notch: 'border5',
  scallop: 'border6',
  roundoutline: 'border7',
  floral: 'border8',
  decorative: 'border9',
  squareangular: 'border10',
};


const BORDER_SCALE = 1.3; // Enlarge decorative border by 30%
const BORDER_THICKNESS_SCALE = 1.5; // Border thickness increased to 150%
const BORDER_RELIEF_SCALE = 0.33; // Border relief depth reduced to 33%

interface BronzeTextures {
  map: THREE.CanvasTexture;
  roughnessMap: THREE.CanvasTexture;
}

function normalizeGeometry(geometry: THREE.BufferGeometry) {
  let geom = geometry;
  if (geom.index) {
    const nonIndexed = geom.toNonIndexed();
    geom.dispose();
    geom = nonIndexed;
  }

  if (!geom.getAttribute('normal')) {
    geom.computeVertexNormals();
  }

  if (!geom.getAttribute('uv')) {
    const position = geom.getAttribute('position') as THREE.BufferAttribute;
    const uvs = new Float32Array(position.count * 2);
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  }

  geom.computeBoundingBox();
  return geom;
}

/**
 * Trims vertices that extend too far in X or Y directions.
 * Used to convert "Full Frame" SVGs with long rails into "Corner" pieces.
 * 300 is chosen because standard corners are ~100px, while rails extend to 1200px.
 */
function trimLongRails(geometry: THREE.BufferGeometry, cutoff: number = 300): THREE.BufferGeometry {
  const nonIndexed = geometry.index ? geometry.toNonIndexed() : geometry;
  const posAttribute = nonIndexed.getAttribute('position');
  const uvAttribute = nonIndexed.getAttribute('uv');
  
  const newPositions: number[] = [];
  const newUVs: number[] = [];
  
  for (let i = 0; i < posAttribute.count; i += 3) {
    // Check triangle vertices
    const x1 = posAttribute.getX(i);
    const y1 = posAttribute.getY(i);
    const x2 = posAttribute.getX(i + 1);
    const y2 = posAttribute.getY(i + 1);
    const x3 = posAttribute.getX(i + 2);
    const y3 = posAttribute.getY(i + 2);

    // If any part of the triangle is inside the cutoff box, keep it.
    // Logic: If ALL vertices are beyond cutoff in X, discard.
    // If ALL vertices are beyond cutoff in Y, discard.
    // SVG coordinates: +X is right, +Y is usually down.
    
    const minX = Math.min(x1, x2, x3);
    const minY = Math.min(y1, y2, y3);
    
    if (minX < cutoff && minY < cutoff) {
      // Keep vertex 1
      newPositions.push(x1, y1, posAttribute.getZ(i));
      // Keep vertex 2
      newPositions.push(x2, y2, posAttribute.getZ(i + 1));
      // Keep vertex 3
      newPositions.push(x3, y3, posAttribute.getZ(i + 2));

      if (uvAttribute) {
        newUVs.push(uvAttribute.getX(i), uvAttribute.getY(i));
        newUVs.push(uvAttribute.getX(i + 1), uvAttribute.getY(i + 1));
        newUVs.push(uvAttribute.getX(i + 2), uvAttribute.getY(i + 2));
      }
    }
  }

  const trimmedGeom = new THREE.BufferGeometry();
  trimmedGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
  if (newUVs.length > 0) {
    trimmedGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUVs, 2));
  }
  trimmedGeom.computeVertexNormals();
  trimmedGeom.computeBoundingBox();
  
  // Clean up the temporary non-indexed copy if we made one
  if (geometry.index) nonIndexed.dispose();
  
  return trimmedGeom;
}

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));

function shiftLuminance(hex: string, delta: number) {
  const color = new THREE.Color(hex);
  const hsl = { h: 0, s: 0, l: 0 };
  color.getHSL(hsl);
  const next = new THREE.Color();
  next.setHSL(hsl.h, clamp01(hsl.s + delta * 0.15), clamp01(hsl.l + delta));
  return `#${next.getHexString()}`;
}

function createBronzeTextures(baseHex: string): BronzeTextures | null {
  if (typeof document === 'undefined') {
    return null;
  }

  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = mapCanvas.height = 512;
  const mapCtx = mapCanvas.getContext('2d');
  if (!mapCtx) return null;

  const gradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
  gradient.addColorStop(0, shiftLuminance(baseHex, 0.2));
  gradient.addColorStop(0.45, shiftLuminance(baseHex, 0.08));
  gradient.addColorStop(0.6, baseHex);
  gradient.addColorStop(1, shiftLuminance(baseHex, -0.2));
  mapCtx.fillStyle = gradient;
  mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

  mapCtx.globalAlpha = 0.08;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.6)';
  for (let y = 0; y < mapCanvas.height; y += 2) {
    mapCtx.beginPath();
    const jitter = Math.random() * 1.5;
    mapCtx.moveTo(0, y + jitter);
    mapCtx.lineTo(mapCanvas.width, y + Math.random() * 1.5);
    mapCtx.stroke();
  }
  mapCtx.globalAlpha = 0.12;
  mapCtx.strokeStyle = 'rgba(0,0,0,0.4)';
  for (let y = 1; y < mapCanvas.height; y += 3) {
    mapCtx.beginPath();
    mapCtx.moveTo(0, y + Math.random());
    mapCtx.lineTo(mapCanvas.width, y + Math.random());
    mapCtx.stroke();
  }

  const mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
  mapTexture.anisotropy = 8;
  mapTexture.needsUpdate = true;

  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = 256;
  const roughCtx = roughCanvas.getContext('2d');
  if (!roughCtx) {
    return {
      map: mapTexture,
      roughnessMap: mapTexture.clone() as THREE.CanvasTexture,
    };
  }
  const roughData = roughCtx.createImageData(roughCanvas.width, roughCanvas.height);
  for (let i = 0; i < roughData.data.length; i += 4) {
    const shade = 130 + Math.random() * 90;
    roughData.data[i] = roughData.data[i + 1] = roughData.data[i + 2] = shade;
    roughData.data[i + 3] = 255;
  }
  roughCtx.putImageData(roughData, 0, 0);
  const roughnessMap = new THREE.CanvasTexture(roughCanvas);
  roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;
  roughnessMap.anisotropy = 4;
  roughnessMap.needsUpdate = true;

  return { map: mapTexture, roughnessMap };
}

export function BronzeBorder({
  borderName,
  plaqueWidth,
  plaqueHeight,
  unitsPerMeter,
  frontZ,
  color,
  depth,
}: BronzeBorderProps) {
  const unitScale = Math.max(1e-6, Math.abs(unitsPerMeter) || 1);
  const localWidth = Math.max(1e-3, Math.abs(plaqueWidth) * unitScale);
  const localHeight = Math.max(1e-3, Math.abs(plaqueHeight) * unitScale);

  const normalizedName = borderName?.toLowerCase() ?? '';
  const effectiveName = normalizedName.includes('no border') ? null : borderName;
  const slug = effectiveName ? toBorderSlug(effectiveName) : null;
  const resolvedSlug = slug ? `${slug}a` : null;
  const shouldRender = Boolean(resolvedSlug && localWidth > 0 && localHeight > 0);

  const bronzeTextures = React.useMemo(() => createBronzeTextures(color), [color]);

  useEffect(() => {
    return () => {
      bronzeTextures?.map.dispose();
      bronzeTextures?.roughnessMap.dispose();
    };
  }, [bronzeTextures]);

  const [svgData, setSvgData] = useState<SVGResult | null>(null);
  const [borderGroup, setBorderGroup] = useState<THREE.Group | null>(null);

  const resourcesRef = useRef<BorderResources | null>(null);
  const svgCacheRef = useRef<Record<string, SVGResult>>({});

  const disposeResources = useCallback(() => {
    if (!resourcesRef.current) return;
    resourcesRef.current.geometries.forEach((geom) => geom.dispose());
    resourcesRef.current.material?.dispose();
    resourcesRef.current = null;
  }, []);

  useEffect(() => disposeResources, [disposeResources]);

  useEffect(() => {
    if (!resolvedSlug) {
      setSvgData(null);
      return;
    }

    if (svgCacheRef.current[resolvedSlug]) {
      setSvgData(svgCacheRef.current[resolvedSlug]);
      return;
    }

    let cancelled = false;
    const loader = new SVGLoader();

    loader.load(
      `/shapes/borders/${resolvedSlug}.svg`,
      (data) => {
        if (cancelled) return;
        svgCacheRef.current[resolvedSlug] = data;
        setSvgData(data);
      },
      undefined,
      (error) => {
        if (cancelled) return;
        console.warn(`Failed to load border SVG ${resolvedSlug}`, error);
        setSvgData(null);
      },
    );

    return () => {
      cancelled = true;
    };
  }, [resolvedSlug]);

  useEffect(() => {
    if (!shouldRender || !svgData) {
      disposeResources();
      setBorderGroup(null);
      return;
    }

    const built = buildBorderGroup(svgData, {
      plaqueWidth: localWidth,
      plaqueHeight: localHeight,
      depth,
      color,
      frontZ,
      textures: bronzeTextures ?? undefined,
      // Force disable integrated rails to rely on procedural rail generation
      // This is necessary because we are trimming the SVG geometry to remove overlaps
      integratedRails: false, 
    });

    if (!built) {
      disposeResources();
      setBorderGroup(null);
      return;
    }

    disposeResources();
    resourcesRef.current = {
      geometries: built.geometries,
      material: built.material,
    };
    setBorderGroup(built.group);
  }, [svgData, shouldRender, localWidth, localHeight, depth, color, frontZ, bronzeTextures, disposeResources]);

  if (!borderGroup) {
    return null;
  }

  return <primitive object={borderGroup} />;
}

function toBorderSlug(name: string) {
  const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const alias = BORDER_SLUG_ALIASES[normalized];
  if (alias) {
    return alias;
  }
  const match = name.match(/\d+/);
  if (match) {
    return `border${match[0]}`;
  }
  return normalized || 'border1';
}

function buildBorderGroup(
  data: SVGResult,
  params: {
    plaqueWidth: number;
    plaqueHeight: number;
    depth: number;
    color: string;
    frontZ: number;
    textures?: BronzeTextures;
    integratedRails?: boolean;
  },
): {
  group: THREE.Group;
  geometries: THREE.BufferGeometry[];
  material: THREE.MeshStandardMaterial;
} | null {
  const { plaqueWidth, plaqueHeight, depth, color, frontZ, textures, integratedRails = false } = params;
  const width = Math.max(1e-3, Math.abs(plaqueWidth));
  const height = Math.max(1e-3, Math.abs(plaqueHeight));

  const reliefDepthBase = Math.max(0.001, Math.min(width, height) * 0.003);
  const reliefDepth = reliefDepthBase * BORDER_RELIEF_SCALE;
  const extrudeSettings = {
    depth: reliefDepth,
    bevelEnabled: true,
    bevelSegments: 2,
    bevelSize: reliefDepth * 0.35,
    bevelThickness: reliefDepth * 0.35,
    steps: 1,
    curveSegments: 24,
  } satisfies THREE.ExtrudeGeometryOptions;

  const tempGeometries: THREE.BufferGeometry[] = [];

  for (const path of data.paths) {
    const shapes = SVGLoader.createShapes(path);
    for (const shape of shapes) {
      if (!shape.curves.length) continue;
      const raw = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      
      // FIX: Trim long rails from the SVG to prevent overlap glitches
      // This converts "Full Frame" SVGs into "Corner" geometry
      const trimmed = trimLongRails(raw, 300); // 300 is a safe cutoff for corners vs 1200 rails
      
      const geom = normalizeGeometry(trimmed);
      raw.dispose(); // Dispose original
      
      tempGeometries.push(geom);
    }
  }

  if (!tempGeometries.length || tempGeometries.some((geom) => !geom.getAttribute('position'))) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  const merged = mergeGeometries(tempGeometries, false);
  if (!merged) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  merged.computeBoundingBox();
  const centeredBounds = merged.boundingBox;
  if (!centeredBounds) {
    merged.dispose();
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  const originalWidth = Math.max(1e-3, centeredBounds.max.x - centeredBounds.min.x);
  const originalHeight = Math.max(1e-3, centeredBounds.max.y - centeredBounds.min.y);
  const centerX = (centeredBounds.min.x + centeredBounds.max.x) / 2;
  const centerY = (centeredBounds.min.y + centeredBounds.max.y) / 2;

  merged.translate(-centerX, -centerY, 0);

  // Calculate line thickness first so we can match corner size to it
  const edgeThicknessBase = Math.max(0.01, Math.min(width, height) * 0.02 * BORDER_SCALE);
  const edgeThickness = edgeThicknessBase * BORDER_THICKNESS_SCALE;
  const lineThickness = edgeThickness * 0.4;
  const lineGap = lineThickness * 0.6;

  // Scale logic
  // Since we trimmed the geometry, 'originalWidth' is now small (approx corner size).
  // We use the non-integrated logic to maintain correct visual proportions for the corner.
  if (integratedRails) {
    const uniformScale = Math.min(width / originalWidth, height / originalHeight);
    merged.scale(uniformScale, uniformScale, 1);
  } else {
    // Standard corner scaling logic based on plaque size and thickness
    const targetCornerSpan = Math.max(lineThickness * 6, Math.min(width, height) * 0.25);
    const baseScale = (targetCornerSpan / Math.max(originalWidth, originalHeight)) * 0.7;
    merged.scale(baseScale, baseScale, 1);
  }
  merged.computeVertexNormals();
  merged.computeBoundingBox();
  const scaledBounds = merged.boundingBox!;
  const cornerSpanX = scaledBounds.max.x - scaledBounds.min.x;
  const cornerSpanY = scaledBounds.max.y - scaledBounds.min.y;

  const textureRepeatX = Math.max(1, width / 120);
  const textureRepeatY = Math.max(1, height / 120);

  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(color),
    metalness: 0.95,
    roughness: 0.28,
    envMapIntensity: 1.5,
    clearcoat: 0.7,
    clearcoatRoughness: 0.18,
    side: THREE.DoubleSide,
  });

  if (textures?.map) {
    textures.map.repeat.set(textureRepeatX, textureRepeatY);
    textures.map.needsUpdate = true;
    material.map = textures.map;
  }

  if (textures?.roughnessMap) {
    textures.roughnessMap.repeat.set(textureRepeatX, textureRepeatY);
    textures.roughnessMap.needsUpdate = true;
    material.roughnessMap = textures.roughnessMap;
  }

  let topEdgeStartX: number | null = null;
  let topEdgeEndX: number | null = null;
  let bottomEdgeStartX: number | null = null;
  let bottomEdgeEndX: number | null = null;
  let topInnerEdgeY: number | null = null;
  let bottomInnerEdgeY: number | null = null;
  let leftEdgeTopInnerY: number | null = null;
  let leftEdgeBottomInnerY: number | null = null;
  let rightEdgeTopInnerY: number | null = null;
  let rightEdgeBottomInnerY: number | null = null;
  let leftInnerEdgeX: number | null = null;
  let rightInnerEdgeX: number | null = null;

  const group = new THREE.Group();
  const resourceGeometries: THREE.BufferGeometry[] = [];
  const SURFACE_Z = frontZ + 0.0001;
  const borderParts: THREE.BufferGeometry[] = [];
  const lineAnchors = {
    top: null as [number, number] | null,
    bottom: null as [number, number] | null,
    left: null as [number, number] | null,
    right: null as [number, number] | null,
  };

  const axisTolerance = Math.max(width, height) * 0.0005;

  const extractUniqueAxisValues = (geom: THREE.BufferGeometry, axis: 'x' | 'y') => {
    const attr = geom.getAttribute('position') as THREE.BufferAttribute;
    const values: number[] = [];
    for (let i = 0; i < attr.count; i += 1) {
      values.push(axis === 'x' ? attr.getX(i) : attr.getY(i));
    }
    values.sort((a, b) => a - b);
    const uniques: number[] = [];
    for (const value of values) {
      if (!uniques.length || Math.abs(uniques[uniques.length - 1] - value) > axisTolerance) {
        uniques.push(value);
      }
    }
    return uniques;
  };

  const captureAnchors = (
    geom: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    const toPair = (values: number[], reverse = false): [number, number] | null => {
      if (!values.length) {
        return null;
      }
      const list = reverse ? [...values].reverse() : values;
      if (list.length === 1) {
        return [list[0], list[0]];
      }
      return [list[0], list[1]];
    };

    const yValues = extractUniqueAxisValues(geom, 'y');
    if (alignY === 'top' && !lineAnchors.top) {
      const anchors = toPair(yValues.slice(-2), true);
      if (anchors) {
        lineAnchors.top = anchors;
      }
    }
    if (alignY === 'bottom' && !lineAnchors.bottom) {
      const anchors = toPair(yValues.slice(0, 2));
      if (anchors) {
        lineAnchors.bottom = anchors;
      }
    }

    const xValues = extractUniqueAxisValues(geom, 'x');
    if (alignX === 'left' && !lineAnchors.left) {
      const anchors = toPair(xValues.slice(0, 2));
      if (anchors) {
        lineAnchors.left = anchors;
      }
    }
    if (alignX === 'right' && !lineAnchors.right) {
      const anchors = toPair(xValues.slice(-2), true);
      if (anchors) {
        lineAnchors.right = anchors;
      }
    }
  };

  const createCornerMesh = (
    source: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    const geom = source.clone();
    
    // Flip geometry for correct corner orientation
    const flipX = alignX === 'right';
    const flipY = alignY === 'top';
    
    if (flipX) geom.scale(-1, 1, 1);
    if (flipY) geom.scale(1, -1, 1);
    
    const geomNonIndexed = geom.index ? geom.toNonIndexed() : geom;
    if (geom.index && geomNonIndexed !== geom) {
      geom.dispose();
    }
    
    geomNonIndexed.computeVertexNormals();
    geomNonIndexed.computeBoundingBox();
    const bounds = geomNonIndexed.boundingBox!;
    const posX =
      alignX === 'left'
        ? -width / 2 - bounds.min.x
        : width / 2 - bounds.max.x;
    const posY =
      alignY === 'top'
        ? height - bounds.max.y
        : 0 - bounds.min.y;
    const worldMinX = posX + bounds.min.x;
    const worldMaxX = posX + bounds.max.x;
    const worldMinY = posY + bounds.min.y;
    const worldMaxY = posY + bounds.max.y;
    geomNonIndexed.translate(posX, posY, SURFACE_Z);

    captureAnchors(geomNonIndexed, alignX, alignY);
    borderParts.push(geomNonIndexed);

    if (alignY === 'top') {
      const innerY = worldMinY;
      topInnerEdgeY = topInnerEdgeY == null ? innerY : Math.min(topInnerEdgeY, innerY);
      if (alignX === 'left') {
        topEdgeStartX = worldMaxX;
        leftEdgeTopInnerY =
          leftEdgeTopInnerY == null ? innerY : Math.min(leftEdgeTopInnerY, innerY);
        leftInnerEdgeX = leftInnerEdgeX == null ? worldMaxX : Math.max(leftInnerEdgeX, worldMaxX);
      } else {
        topEdgeEndX = worldMinX;
        rightEdgeTopInnerY =
          rightEdgeTopInnerY == null ? innerY : Math.min(rightEdgeTopInnerY, innerY);
        rightInnerEdgeX = rightInnerEdgeX == null ? worldMinX : Math.min(rightInnerEdgeX, worldMinX);
      }
    } else {
      const innerY = worldMaxY;
      bottomInnerEdgeY = bottomInnerEdgeY == null ? innerY : Math.max(bottomInnerEdgeY, innerY);
      if (alignX === 'left') {
        bottomEdgeStartX = worldMaxX;
        leftEdgeBottomInnerY =
          leftEdgeBottomInnerY == null ? innerY : Math.max(leftEdgeBottomInnerY, innerY);
        leftInnerEdgeX = leftInnerEdgeX == null ? worldMaxX : Math.max(leftInnerEdgeX, worldMaxX);
      } else {
        bottomEdgeEndX = worldMinX;
        rightEdgeBottomInnerY =
          rightEdgeBottomInnerY == null ? innerY : Math.max(rightEdgeBottomInnerY, innerY);
        rightInnerEdgeX = rightInnerEdgeX == null ? worldMinX : Math.min(rightInnerEdgeX, worldMinX);
      }
    }

  };

  createCornerMesh(merged, 'left', 'top');
  createCornerMesh(merged, 'right', 'top');
  createCornerMesh(merged, 'left', 'bottom');
  createCornerMesh(merged, 'right', 'bottom');

  const fallbackTopStartX = -width / 2 + cornerSpanX;
  const fallbackTopEndX = width / 2 - cornerSpanX;
  const fallbackBottomStartX = fallbackTopStartX;
  const fallbackBottomEndX = fallbackTopEndX;
  const fallbackTopInnerY = height - cornerSpanY;
  const fallbackBottomInnerY = cornerSpanY;
  const fallbackLeftTopInnerY = fallbackTopInnerY;
  const fallbackLeftBottomInnerY = fallbackBottomInnerY;
  const fallbackRightTopInnerY = fallbackTopInnerY;
  const fallbackRightBottomInnerY = fallbackBottomInnerY;
  const fallbackLeftInnerX = -width / 2 + cornerSpanX;
  const fallbackRightInnerX = width / 2 - cornerSpanX;

  const clampEdgeXValue = (value: number | null) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return null;
    return Math.min(width / 2, Math.max(-width / 2, value));
  };

  const clampEdgeYValue = (value: number | null) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return null;
    return Math.min(height, Math.max(0, value));
  };


  const sortedFallbackTop: readonly [number, number] = [
    Math.min(fallbackTopStartX, fallbackTopEndX),
    Math.max(fallbackTopStartX, fallbackTopEndX),
  ];
  const sortedFallbackBottom: readonly [number, number] = [
    Math.min(fallbackBottomStartX, fallbackBottomEndX),
    Math.max(fallbackBottomStartX, fallbackBottomEndX),
  ];

  const resolveSpan = (
    start: number | null,
    end: number | null,
    fallback: readonly [number, number],
  ): readonly [number, number] => {
    if (start == null || end == null) {
      return fallback;
    }
    const left = Math.min(start, end);
    const right = Math.max(start, end);
    if (!Number.isFinite(left) || !Number.isFinite(right) || right - left < lineThickness * 1.25) {
      return fallback;
    }
    return [left, right] as const;
  };

  const [topStartX, topEndX] = resolveSpan(
    clampEdgeXValue(topEdgeStartX),
    clampEdgeXValue(topEdgeEndX),
    sortedFallbackTop,
  );
  const [bottomStartX, bottomEndX] = resolveSpan(
    clampEdgeXValue(bottomEdgeStartX),
    clampEdgeXValue(bottomEdgeEndX),
    sortedFallbackBottom,
  );

  const resolvedTopInnerY = clampEdgeYValue(topInnerEdgeY) ?? fallbackTopInnerY;
  const resolvedBottomInnerY = clampEdgeYValue(bottomInnerEdgeY) ?? fallbackBottomInnerY;
  const leftTopY = clampEdgeYValue(leftEdgeTopInnerY) ?? fallbackLeftTopInnerY;
  const leftBottomY = clampEdgeYValue(leftEdgeBottomInnerY) ?? fallbackLeftBottomInnerY;
  const rightTopY = clampEdgeYValue(rightEdgeTopInnerY) ?? fallbackRightTopInnerY;
  const rightBottomY = clampEdgeYValue(rightEdgeBottomInnerY) ?? fallbackRightBottomInnerY;
  const resolvedLeftInnerX = clampEdgeXValue(leftInnerEdgeX) ?? fallbackLeftInnerX;
  const resolvedRightInnerX = clampEdgeXValue(rightInnerEdgeX) ?? fallbackRightInnerX;

  const clampSpan = (value: number) => Math.max(lineThickness * 2, Math.max(0.001, value));

  const topSpan = clampSpan(topEndX - topStartX);
  const bottomSpan = clampSpan(bottomEndX - bottomStartX);
  const sortedLeftTopY = Math.max(leftTopY, leftBottomY);
  const sortedLeftBottomY = Math.min(leftTopY, leftBottomY);
  const sortedRightTopY = Math.max(rightTopY, rightBottomY);
  const sortedRightBottomY = Math.min(rightTopY, rightBottomY);
  const leftSpan = clampSpan(sortedLeftTopY - sortedLeftBottomY);
  const rightSpan = clampSpan(sortedRightTopY - sortedRightBottomY);

  const topCenterX = (topStartX + topEndX) / 2;
  const bottomCenterX = (bottomStartX + bottomEndX) / 2;
  const leftCenterY = (sortedLeftTopY + sortedLeftBottomY) / 2;
  const rightCenterY = (sortedRightTopY + sortedRightBottomY) / 2;

  const addEdgeBar = (geom: THREE.BufferGeometry, x: number, y: number) => {
    const part = geom.clone().toNonIndexed();
    part.translate(x, y, SURFACE_Z);
    borderParts.push(part);
  };

  if (!integratedRails) {
    const clampY = (value: number) => Math.min(height, Math.max(0, value));
    const clampX = (value: number) => Math.min(width / 2, Math.max(-width / 2, value));

    const topLineY = clampY(resolvedTopInnerY);
    const bottomLineY = clampY(resolvedBottomInnerY);
    const leftLineX = clampX(resolvedLeftInnerX);
    const rightLineX = clampX(resolvedRightInnerX);

    const resolveAnchors = (
      anchors: [number, number] | null,
      fallbackOuter: number,
      fallbackInner: number,
    ): [number, number] => {
      if (anchors) {
        return anchors;
      }
      return [fallbackOuter, fallbackInner];
    };

    const [topOuterCenterY, topInnerCenterY] = resolveAnchors(
      lineAnchors.top,
      clampY(topLineY + lineThickness / 2),
      clampY(topLineY + lineThickness / 2 - (lineThickness + lineGap)),
    );
    const [bottomOuterCenterY, bottomInnerCenterY] = resolveAnchors(
      lineAnchors.bottom,
      clampY(bottomLineY - lineThickness / 2),
      clampY(bottomLineY - lineThickness / 2 + (lineThickness + lineGap)),
    );
    const [leftOuterCenterX, leftInnerCenterX] = resolveAnchors(
      lineAnchors.left,
      clampX(leftLineX - lineThickness / 2),
      clampX(leftLineX - lineThickness / 2 + (lineThickness + lineGap)),
    );
    const [rightOuterCenterX, rightInnerCenterX] = resolveAnchors(
      lineAnchors.right,
      clampX(rightLineX + lineThickness / 2),
      clampX(rightLineX + lineThickness / 2 - (lineThickness + lineGap)),
    );

    const createDecorativeRails = (
      length: number,
      orientation: 'horizontal' | 'vertical'
    ): THREE.BufferGeometry[] => {
      const rails: THREE.BufferGeometry[] = [];
      
      const outerLine = orientation === 'horizontal' ?
        new THREE.BoxGeometry(length, lineThickness, reliefDepth) :
        new THREE.BoxGeometry(lineThickness, length, reliefDepth);
      outerLine.translate(0, 0, reliefDepth / 2);
      rails.push(outerLine);
      
      const innerLine = orientation === 'horizontal' ?
        new THREE.BoxGeometry(length, lineThickness, reliefDepth) :
        new THREE.BoxGeometry(lineThickness, length, reliefDepth);
      innerLine.translate(0, 0, reliefDepth / 2);
      rails.push(innerLine);
      
      return rails;
    };

    const topRails = createDecorativeRails(topSpan, 'horizontal');
    const bottomRails = createDecorativeRails(bottomSpan, 'horizontal');
    const leftRails = createDecorativeRails(leftSpan, 'vertical');
    const rightRails = createDecorativeRails(rightSpan, 'vertical');

    addEdgeBar(topRails[0], topCenterX, topOuterCenterY);
    addEdgeBar(topRails[1], topCenterX, topInnerCenterY);
    resourceGeometries.push(...topRails);

    addEdgeBar(bottomRails[0], bottomCenterX, bottomOuterCenterY);
    addEdgeBar(bottomRails[1], bottomCenterX, bottomInnerCenterY);
    resourceGeometries.push(...bottomRails);

    addEdgeBar(leftRails[0], leftOuterCenterX, leftCenterY);
    addEdgeBar(leftRails[1], leftInnerCenterX, leftCenterY);
    resourceGeometries.push(...leftRails);

    addEdgeBar(rightRails[0], rightOuterCenterX, rightCenterY);
    addEdgeBar(rightRails[1], rightInnerCenterX, rightCenterY);
    resourceGeometries.push(...rightRails);
  }

  // Merge all parts (trimmed corners + generated rails)
  if (borderParts.length > 0) {
    const mergedBorder = mergeGeometries(borderParts, false);
    borderParts.forEach((geom) => geom.dispose());
    if (mergedBorder) {
      const mesh = new THREE.Mesh(mergedBorder, material);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.renderOrder = 3;
      group.add(mesh);
      resourceGeometries.push(mergedBorder);
    }
  }

  merged.dispose();

  return {
    group,
    geometries: resourceGeometries,
    material,
  };
}