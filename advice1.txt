To recreate that "Rock Pitch" (chiseled/rough) look in Three.js, you have three main approaches depending on your performance needs and whether you want to use external image files or generated code.

Here are the three methods, ranked from easiest to most realistic.

Method 1: Displacement Map (Most Realistic)

This is the industry-standard way. You use a texture to tell Three.js to physically push vertices in and out to create the jagged surface.

What you need:

A highly subdivided mesh: The geometry needs many vertices (polygons) so there are points to move around.

A Displacement Map: A black and white image where white is "high" and black is "low." For rock pitch, you want a texture that looks like "Voronoi" or "Cellular" noise (cracked rock).

The Code:

code
JavaScript
download
content_copy
expand_less
// 1. Create the Geometry
// Width, Height, Depth, WidthSegs, HeightSegs, DepthSegs
// Note: We drastically increase segments (64 or 128) to get detail for the displacement
const geometry = new THREE.BoxGeometry(10, 2, 4, 128, 32, 64);

// 2. Load Textures (You need a rock texture set)
const textureLoader = new THREE.TextureLoader();
const rockColor = textureLoader.load('path/to/granite_color.jpg');
const rockHeight = textureLoader.load('path/to/rock_displacement.jpg'); // Black & white height map
const rockNormal = textureLoader.load('path/to/rock_normal.jpg'); // Purple bump map

// 3. Define Materials
// Top and Bottom should be polished (smooth)
const polishedMaterial = new THREE.MeshStandardMaterial({ 
    map: rockColor,
    roughness: 0.1, // Shiny
    flatShading: false
});

// Sides should be Rock Pitch (rough and displaced)
const pitchedMaterial = new THREE.MeshStandardMaterial({ 
    map: rockColor,
    displacementMap: rockHeight,
    displacementScale: 0.5, // How far the spikes stick out
    normalMap: rockNormal,
    roughness: 0.9, // Matte/Rough
});

// 4. Apply Multi-Material to the Box
// Order: Right, Left, Top, Bottom, Front, Back
const materials = [
    pitchedMaterial, // Right
    pitchedMaterial, // Left
    polishedMaterial, // Top (Polished)
    polishedMaterial, // Bottom
    pitchedMaterial, // Front
    pitchedMaterial  // Back
];

const base = new THREE.Mesh(geometry, materials);
scene.add(base);
Method 2: Procedural Vertex Manipulation (No Textures)

If you don't want to load image files and want to generate the roughness using code, you can manually move the vertices of the geometry. This creates a true jagged silhouette.

The Code:

code
JavaScript
download
content_copy
expand_less
import * as THREE from 'three';
import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise.js'; // Optional, or write simple random

const width = 10;
const height = 2;
const depth = 4;

// High segmentation is required for the jagged look
const geometry = new THREE.BoxGeometry(width, height, depth, 100, 20, 40);

// Access the position attribute
const positionAttribute = geometry.attributes.position;
const vertex = new THREE.Vector3();

// Create a noise generator (or use Math.random() for sharper/uglier noise)
// For "Rock Pitch", jagged randomness is actually okay
for (let i = 0; i < positionAttribute.count; i++) {
    vertex.fromBufferAttribute(positionAttribute, i);

    // LOGIC: Only apply noise to the vertical sides, not the top/bottom flat faces
    // We check if the vertex is on the top or bottom edge
    const isTopOrBottom = Math.abs(vertex.y) >= height / 2 - 0.01;

    if (!isTopOrBottom) {
        // Create jagged noise
        // We use sine waves combined with Math.random for a chiseled look
        const noise = (Math.random() * 0.4) - 0.2; 
        
        // Push vertex outward based on its normal direction roughly
        // Ideally, calculate normal, but for a box, we can just jitter x and z
        if (Math.abs(vertex.x) > width / 2 - 0.1) vertex.x += noise;
        if (Math.abs(vertex.z) > depth / 2 - 0.1) vertex.z += noise;
        if (Math.abs(vertex.x) > width / 2 - 0.1 || Math.abs(vertex.z) > depth / 2 - 0.1) {
             vertex.y += noise * 0.5; // Slight vertical jitter for realism
        }
    }
    
    positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
}

geometry.computeVertexNormals(); // CRITICAL: Re-calculate lighting so it looks rough
const material = new THREE.MeshStandardMaterial({ 
    color: 0x888888, 
    roughness: 0.8,
    flatShading: true // Makes it look faceted like cut stone
});

const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
Method 3: The "Baked" Normal Map (Best Performance)

If you are making a website where performance matters (like a configurator), do not use Method 1 or 2. They require too many polygons (vertices) which will slow down the browser.

The professional workflow is:

Use Blender (free 3D software).

Create a simple box.

Use the "Sculpt" tool in Blender with a rock brush to chip away the edges.

"Bake" this high-detail sculpt onto a Low-Poly box using a Normal Map.

Export as a .GLB file.

Load the GLB into Three.js.

This will look identical to the high-quality version but will run at 60FPS easily on mobile phones.

Summary Checklist for the Look:

To sell the "Rock Pitch" granite look, you need:

Granite Texture: A speckled noise image (black/white/grey dots).

Flat Shading: If generating via code, enable flatShading: true in the material to make the facets look like hard crystals.

Specular Highlights: Granite contains quartz. Even on the rough parts, you want tiny sparkles. A "Roughness Map" where the stone is mostly matte but has tiny dots of black (shiny) helps achieve this.