Got it — the coordinates are right now, but the **sizes are not being re-scaled to the displayed SVG width**. You divided by saved DPR (good), but font sizes and motif W/H then stay in *authoring px* while the headstone SVG is rendered wider — so everything looks small.

Here’s a tight fix you can drop into `DesignPageClient.tsx`:

### 1) Measure the rendered SVG width and compute display scale

Add this once you know `init_width` and after the SVG mounts:

```ts
// after you set svgContent or when <img>/<object> with the SVG is on screen:
const headstoneData = designData.find((i:any)=> i.type==='Headstone' || i.type==='HeadStone');
const initW = headstoneData?.init_width || 707;

const svgHostRef = useRef<HTMLDivElement>(null);
const [displayScale, setDisplayScale] = useState(1);

useEffect(() => {
  if (!svgHostRef.current || !initW) return;
  const r = svgHostRef.current.getBoundingClientRect();
  // scale from authoring canvas → on-screen pixels
  const s = r.width / initW;
  if (s > 0 && isFinite(s)) setDisplayScale(s);
}, [svgContent, svgDimensions, screenshotDimensions, initW]);
```

Wrap the SVG (or its container) with the ref:

```jsx
<div ref={svgHostRef} className="relative">
  {/* your headstone SVG/image goes here */}
</div>
```

### 2) Normalize coords **then** scale sizes (fonts & motifs) by `displayScale`

Use your coord-space detector (you already have it), but **do not** divide sizes by DPR unless the design was saved in physical px; and regardless of that, multiply sizes by `displayScale`:

```ts
const savedDpr = Number(headstoneData?.dpr) || 1;
const items = designData.filter((i:any)=> i.type==='Inscription' || i.type==='Motif');
const usesPhysical = designUsesPhysicalCoords(items, initW, headstoneData?.init_height || 476); // you already have this helper

const normXY = (x:number, y:number) => ({
  x: usesPhysical ? x / savedDpr : x,
  y: usesPhysical ? y / savedDpr : y
});

// sizes are authoring px; only divide if physical, then ALWAYS multiply by displayScale
const normFont = (px:number) => ((usesPhysical ? px / savedDpr : px) * displayScale);
const normLen  = (px:number) => ((usesPhysical ? px / savedDpr : px) * displayScale);

// map inscriptions
const mappedInscriptions = inscriptions.map((ins:any) => {
  const { x, y } = normXY(ins.x ?? ins.cx ?? 0, ins.y ?? ins.cy ?? 0);
  const fontPx = normFont(ins.fontSize || ins.size || 24);
  return { ...ins, canvasX: x, canvasY: y, fontSizePx: Math.max(1, fontPx) };
});

// map motifs
const mappedMotifs = motifs.map((m:any) => {
  const { x, y } = normXY(m.x ?? m.cx ?? 0, m.y ?? m.cy ?? 0);
  const w = m.width  != null ? normLen(m.width)  : undefined;
  const h = m.height != null ? normLen(m.height) : undefined;
  return { ...m, canvasX: x, canvasY: y, widthPx: w, heightPx: h, strokeWidthPx: normLen(m.strokeWidth || 1) };
});
```

Then use `fontSize: ins.fontSizePx` in your text style, and `width/height` (or a `transform: scale(...)`) for motifs.

### 3) Order of operations (avoid double scaling)

1. Detect coord space → divide XY (and sizes) by `savedDpr` **only** if `usesPhysical`.
2. Apply **crop offsets** (if any).
3. Convert center-origin → top-left (if you do this).
4. Multiply **sizes** (not positions) by `displayScale`.

Add a sanity log to verify everything in one place:

```ts
console.log('FINAL mapping SEHOVIC', {
  initW,
  savedDpr,
  usesPhysical,
  displayScale: +displayScale.toFixed(4),
  sample: {
    fontRaw: inscriptions[0]?.fontSize,
    fontPx: mappedInscriptions[0]?.fontSizePx,
    motifRawW: motifs[0]?.width,
    motifWpx: mappedMotifs[0]?.widthPx,
  }
});
```

This keeps your coordinates correct and makes the **visual size** match the rendered SVG width, eliminating the “too small” look in your screenshot. The patch fits directly into your current file and helpers. 

If it still looks off after this, ping me with the console block above (initW / displayScale / sample sizes) and I’ll zero it in.
