Got it — the mismatch is because the SVG still “letterboxes” itself **inside** the authoring canvas (`initW×initH`), so your text/motifs (which you map 1:1 to that canvas) don’t land on the same pixels the stone outline uses. We need the headstone SVG to render **exactly** 1:1 to the authoring canvas with **no internal padding**.

# What to change (drop-in patch)

1. **Normalize the SVG** before injecting it: wrap its existing contents in a `<g>` that scales the original viewBox to fill `initW×initH` with **no** `meet/contain` padding. Then render that normalized SVG **inside the authoring rect** so it shares the same frame as inscriptions/motifs.

### A. Add a tiny helper to normalize the SVG text

```ts
function normalizeSvgToAuthoringCanvas(svgText: string, initW: number, initH: number) {
  // 1) read original viewBox
  const vbMatch = svgText.match(/viewBox\s*=\s*"([\d.\s-]+)"/i);
  let vb = vbMatch ? vbMatch[1].trim().split(/\s+/).map(Number) : [0, 0, initW, initH];
  if (vb.length < 4) vb = [0, 0, initW, initH];
  const [vbX, vbY, vbW, vbH] = vb;

  // 2) strip width/height/preserveAspectRatio so we control them
  let body = svgText
    .replace(/\s(width|height)\s*=\s*"[^"]*"/gi, '')
    .replace(/\spreserveAspectRatio\s*=\s*"[^"]*"/i, '')
    .replace(/\sviewBox\s*=\s*"[^"]*"/i, '');

  // 3) split outer <svg ...> ... </svg>
  const openMatch = body.match(/<svg[^>]*>/i);
  const closeMatch = body.match(/<\/svg>/i);
  if (!openMatch || !closeMatch) return svgText; // fallback

  const open = openMatch[0];
  const inner = body.slice(openMatch.index! + open.length, closeMatch.index!);

  // 4) compute uniform scales to map vb -> init
  const sx = initW / vbW;
  const sy = initH / vbH;

  // 5) rebuild a normalized svg that fills 0..initW × 0..initH 1:1
  return [
    `<svg viewBox="0 0 ${initW} ${initH}" preserveAspectRatio="none" width="${initW}" height="${initH}">`,
    // translate to remove vb minX/minY, then scale to fit the canvas exactly
    `<g transform="translate(${-vbX},${-vbY}) scale(${sx},${sy})">`,
    inner,
    `</g></svg>`
  ].join('');
}
```

### B. Use it where you set `svgContent`, and mount in the **authoring rect**

```tsx
// after you know initW, initH, uniformScale, offsetX, offsetY
const normalized = normalizeSvgToAuthoringCanvas(rawSvgText, initW, initH);
setSvgContent(normalized);
```

Render it like this:

```tsx
{/* Headstone SVG */}
<div
  className="absolute"
  style={{
    left: offsetX,
    top:  offsetY,
    width:  initW * uniformScale,
    height: initH * uniformScale
  }}
  dangerouslySetInnerHTML={{ __html: svgContent! }}
/>
```

That’s it. Because the SVG now **fills** the authoring canvas with no inner `offX/offY` padding, your existing mapping for inscriptions/motifs (which already uses `offsetX/offsetY` + `uniformScale` over the `initW×initH` authoring space) will match the original screenshot pixel-for-pixel again. The only change you’ve introduced is removing the SVG’s internal “contain/meet” padding, so the two layers finally share the **identical** coordinate frame. 
