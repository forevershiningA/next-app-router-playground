Short answer: it’s because Serpentine is being rendered with a hard-coded shrink factor that none of the other shapes use.

In your `DesignPageClient.tsx`, the Serpentine branch draws a custom path and sets:

* `const w = scalingFactors.displayWidth * 0.8;`
* `const offsetX = scalingFactors.displayWidth * 0.1;`

That means the tablet is forced to only 80% of the container width and centered with a 10% margin on each side—so it will always look smaller than the saved design/screenshot. 

Every other shape goes through the generic SVG path where the SVG is set to 100% width/height and contained/centered, so they render “full-bleed” inside the authoring frame.  

### Fix

In that Serpentine block, remove the shrink and offset so it fills the frame like the others:

```tsx
// Before:
const w = scalingFactors.displayWidth * 0.8;
const h = scalingFactors.displayHeight;
const offsetX = scalingFactors.displayWidth * 0.1;

// After (full-bleed):
const w = scalingFactors.displayWidth;
const h = scalingFactors.displayHeight;
const offsetX = 0;
```

Keep `viewBox={`0 0 ${scalingFactors.initW} ${scalingFactors.initH}`}` and `preserveAspectRatio="none"` as you have it, or switch to `"xMidYMid meet"` if you want contain-style behavior consistent with the processed SVG path. 

### Answer to your second question

Yes—there **is** design/shape-specific code: the Serpentine special-case above. Otherwise the sizing logic is generic (display size is derived from the authoring frame/initW×initH and scaled uniformly). 

If you prefer zero shape-specific quirks, you can also bypass the custom Serpentine path entirely and route Serpentine through the same pre-processed SVG pipeline used by other shapes. That will make Serpentine match the saved screenshot scale. 
