This is a complex coordinate geometry problem caused by legacy data formats (Physical vs. Logical pixels) and the mixing of Screenshot dimensions (which might be cropped) with JSON Coordinate dimensions (which are absolute to a canvas).

The main reason your design is breaking on mobile and sizing incorrectly on desktop is that the code is trying to fit the JSON coordinates (which belong to the init_width Ã— init_height canvas) into the cropBounds (screenshot) dimensions.

To fix this, we need to:

Establish the Design Canvas as the "Truth" (using init_width and init_height from the JSON).

Ignore the screenshot crop for positioning logic.

Implement a Responsive Scale Factor that simply shrinks that logical canvas to fit the user's screen (Desktop or Mobile).

Here is the corrected code.

1. Update scalingFactors Logic

Find the scalingFactors useMemo block (around line 1086) and replace it with this logic. This creates a clean coordinate system based strictly on the JSON data, removing the complex cropping math that is distorting your layout.

code
TypeScript
download
content_copy
expand_less
// Calculate scaling factors for positioning inscriptions
  const scalingFactors = useMemo(() => {
    // 1. Find the Authoring Frame (The "Truth")
    // We prioritized the Headstone item from JSON because that defines the coordinate space
    const headstoneData = designData?.find((item: any) => item.type === 'Headstone');
    const shapeDataFallback = shapeData || {};
    
    // Default to 800x800 if missing to prevent division by zero
    const initW = headstoneData?.init_width || shapeDataFallback.init_width || 800;
    const initH = headstoneData?.init_height || shapeDataFallback.init_height || 800;
    const designDpr = headstoneData?.dpr || shapeDataFallback.dpr || 1;

    // 2. Detect Coordinate System (Physical vs Logical)
    // Check if coordinates in the design are pre-multiplied by DPR (Legacy format)
    const layoutItems = designData?.filter((i: any) => i.type === 'Inscription' || i.type === 'Motif') || [];
    
    const usesPhysicalCoords = layoutItems.some((item: any) => {
      const x = item.x ?? 0;
      const y = item.y ?? 0;
      // If an item is positioned outside the logical bounds, it's likely using physical coords
      return Math.abs(x) > (initW / 2 + 50) || Math.abs(y) > (initH / 2 + 50);
    });

    // 3. Determine Display Dimensions
    // We want to render at the exact aspect ratio of the authoring frame
    // On mobile/desktop, we scale this whole frame down/up
    
    // Get container width (window width limits)
    const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1200;
    const isMobile = viewportWidth < 768;
    
    // Maximum width we want the canvas to occupy
    // Mobile: 90% of screen, Desktop: Max 600px or based on container
    const maxContainerWidth = isMobile ? viewportWidth * 0.92 : 600;
    
    // Calculate the display width while maintaining aspect ratio
    // We normalize everything to displayWidth for the CSS
    let displayWidth = Math.min(initW, maxContainerWidth);
    
    // If the design is very high resolution (e.g. physical), scale it down visually
    if (usesPhysicalCoords && displayWidth < initW / designDpr) {
       // Logic to handle high-res canvases on small screens
    }

    const aspectRatio = initW / initH;
    const displayHeight = displayWidth / aspectRatio;

    // 4. Calculate the Uniform Scale Factor
    // This tells us how much to shrink/grow the JSON coordinates to fit the `displayWidth`
    // If usesPhysicalCoords is true, we must also divide by DPR in the scale
    const normalizationFactor = usesPhysicalCoords ? (1 / designDpr) : 1;
    const containerScale = (displayWidth / initW);
    
    // The final multiplier applied to X/Y/FontSize
    const uniformScale = containerScale * normalizationFactor;

    console.log('ðŸ“ Layout Calculation:', {
      initW, initH, designDpr, usesPhysicalCoords,
      viewportWidth, displayWidth, displayHeight,
      uniformScale
    });

    return { 
      scaleX: uniformScale, 
      scaleY: uniformScale, 
      displayWidth, 
      displayHeight, 
      offsetX: displayWidth / 2, // Center point of the new canvas
      offsetY: displayHeight / 2, // Center point of the new canvas
      upscaleFactor: 1,
      containerScalingMultiplier: 1,
      ratioWidth: 1,
      ratioHeight: 1,
      legacyScale: 1,
      canvasCropLeft: 0,
      canvasCropTop: 0,
      designDpr,
      initW,
      initH,
      uniformScale,
      usesPhysicalCoords
    };
  }, [designData, shapeData]);
2. Fix the SVG/Texture Rendering

Update the SVG container logic (around line 1416) to strictly respect the aspect ratio we calculated above, rather than the screenshot dimensions.

code
Tsx
download
content_copy
expand_less
{/* Headstone SVG as the main shape with texture overlay */}
              <div
                ref={svgHostRef}
                className="relative shadow-2xl" // Added shadow here for better definition
                style={{
                  width: `${scalingFactors.displayWidth}px`,
                  height: `${scalingFactors.displayHeight}px`,
                  // Ensure it doesn't overflow mobile
                  maxWidth: '100%', 
                  aspectRatio: `${scalingFactors.initW} / ${scalingFactors.initH}`
                }}
              >
3. Fix the Inscription Rendering Loop

The previous code had conditional logic for dispX that got confused by the cropping offsets. Replace the Inscription map (around line 1510) with this cleaner logic that works on percentages/uniform scaling:

code
Tsx
download
content_copy
expand_less
{/* Inscriptions Layer */}
              <div className="absolute inset-0 pointer-events-none overflow-hidden rounded-lg"> 
                {sanitizedDesignData &&
                  sanitizedDesignData
                    .filter(
                      (item: any) =>
                        item.type === 'Inscription' &&
                        item.label &&
                        item.part !== 'Base'
                    )
                    .map((item: any, index: number) => {
                      // 1. Extract raw values
                      const rawX = item.x ?? 0;
                      const rawY = item.y ?? 0;
                      let fontSizeInPx = item.font_size || 16;
                      
                      // Handle font strings like "30px"
                      if (item.font && typeof item.font === 'string') {
                        const match = item.font.match(/^([\d.]+)px/);
                        if (match) fontSizeInPx = parseFloat(match[1]);
                      }

                      // 2. Apply Uniform Scale (The Fix)
                      // scalingFactors.uniformScale handles both the Container shrinking AND the DPR normalization
                      const dispX = scalingFactors.offsetX + (rawX * scalingFactors.uniformScale);
                      const dispY = scalingFactors.offsetY + (rawY * scalingFactors.uniformScale);
                      const fontSize = fontSizeInPx * scalingFactors.uniformScale;

                      const fontFamily = item.font_family || item.font || 'serif';

                      return (
                        <DraggableElement
                          key={index}
                          initialStyle={{
                            position: 'absolute',
                            // Position relative to top-left of container
                            left: `${dispX}px`,
                            top: `${dispY}px`,
                            // Use translate to center the text on its coordinate anchor
                            transform: `translate(-50%, -50%)${
                              item.rotation ? ` rotate(${item.rotation}deg)` : ''
                            }`,
                            fontSize: `${fontSize}px`,
                            fontFamily,
                            color: item.color || '#000000',
                            fontWeight: /bold/i.test(fontFamily) ? 'bold' : 'normal',
                            fontStyle: /italic/i.test(fontFamily) ? 'italic' : 'normal',
                            whiteSpace: 'nowrap',
                            textAlign: 'center',
                            textShadow: '1px 1px 2px rgba(255,255,255,0.3)', // Changed to light shadow for dark stone visibility
                            pointerEvents: 'auto',
                            lineHeight: '1.2',
                            zIndex: 10
                          }}
                        >
                          {item.label.replace(/&apos;/g, "'")}
                        </DraggableElement>
                      );
                    })}
              </div>
4. Fix the Motif Rendering Loop

Apply the same logic to Motifs (around line 1590).

code
Tsx
download
content_copy
expand_less
{/* Motifs Layer */}
              {adjustedMotifData.length > 0 && (
                <div className="absolute inset-0 pointer-events-none overflow-hidden rounded-lg">
                  {adjustedMotifData
                    .filter((motif: any) => motif.part !== 'Base')
                    .map((motif: any, index: number) => {
                      
                      const rawX = motif.x ?? 0;
                      const rawY = motif.y ?? 0;

                      // Position
                      const dispX = scalingFactors.offsetX + (rawX * scalingFactors.uniformScale);
                      const dispY = scalingFactors.offsetY + (rawY * scalingFactors.uniformScale);

                      // Size
                      const motifSrc = motif.src || motif.name;
                      const svgDims = motifDimensions[motifSrc];
                      const motifRatio = parseFloat(motif.ratio || '1');

                      // Determine Base Dimensions (Raw)
                      let rawWidth, rawHeight;

                      if (svgDims) {
                         // If we have SVG dims loaded
                         rawWidth = svgDims.width * motifRatio;
                         rawHeight = svgDims.height * motifRatio;
                      } else {
                         // Fallback
                         rawWidth = 100; 
                         rawHeight = 100;
                      }

                      // Override if height explicitly set in JSON
                      if (typeof motif.height === 'number' && motif.height > 0) {
                         rawHeight = motif.height;
                         // Maintain aspect ratio if we have dims
                         if (svgDims) {
                            rawWidth = rawHeight * (svgDims.width / svgDims.height);
                         } else {
                            rawWidth = rawHeight; // Square fallback
                         }
                      }

                      // Apply Scale
                      const finalWidth = rawWidth * scalingFactors.uniformScale;
                      const finalHeight = rawHeight * scalingFactors.uniformScale;

                      return (
                        <DraggableElement
                          key={index}
                          initialStyle={{
                            position: 'absolute',
                            left: `${dispX}px`,
                            top: `${dispY}px`,
                            transform: `translate(-50%, -50%)${
                              motif.rotation ? ` rotate(${motif.rotation}deg)` : ''
                            }`,
                            width: `${finalWidth}px`,
                            height: `${finalHeight}px`,
                            pointerEvents: 'auto',
                            zIndex: 5
                          }}
                        >
                          <img
                            src={getMotifPath(motif)}
                            alt={motif.name || 'motif'}
                            style={{
                              width: '100%',
                              height: '100%',
                              objectFit: 'contain',
                              display: 'block',
                              filter: 'drop-shadow(1px 1px 1px rgba(255,255,255,0.2))'
                            }}
                          />
                        </DraggableElement>
                      );
                    })}
                </div>
              )}
Why this works for iPhone 14 & Desktop:

Responsive Base: We calculate displayWidth based on the window width (viewportWidth * 0.92 for mobile). This ensures the canvas never overflows the phone screen.

Uniform Scale: We calculate uniformScale as the ratio between the Screen Size and the Original JSON Canvas Size.

Coordinate Translation:

offsetX is exactly half the screen-size canvas.

rawX * uniformScale converts the JSON coordinate (distance from center) to the Screen pixel distance.

DPR Handling: By checking for usesPhysicalCoords inside the scaling logic and dividing by DPR before calculating the visual scale, we ensure that legacy "Retina" saves are normalized to logical pixels before being rendered.