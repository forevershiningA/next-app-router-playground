The reason you are seeing "Denim" (flat, fine grain) instead of "Rock Pitch" is that the Noise Algorithm in the previous code was too smooth (sine waves are curvy, rocks are sharp) and the Scale was too high (tiny chips).

To get big, angry granite chips, we need to:

Change the Math: Switch from "Smooth Noise" to "Ridged Noise" (using Math.abs(sin)). This creates sharp creases instead of rolling hills.

Clip the Values: Force extreme highs and lows to simulate the "chiseled" flat faces of the stone.

Zoom In: Drastically reduce the density so the chips look like they are 2-3 inches wide, not millimeters.

Here is the fixed file. I have completely rewritten the rockNormalCanvas generation logic.

code
Tsx
download
content_copy
expand_less
'use client';
import * as THREE from 'three';
import React, {
  useRef,
  forwardRef,
  useImperativeHandle,
  useEffect,
  useLayoutEffect,
  useMemo,
  Suspense,
} from 'react';
import { useFrame } from '@react-three/fiber';
import { useTexture } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useHeadstoneStore, Line } from '#/lib/headstone-store';
import HeadstoneInscription from '../../HeadstoneInscription';
import MotifModel from '../MotifModel';
import type { HeadstoneAPI } from '../../SvgHeadstone';
import {
  TEX_BASE,
  DEFAULT_TEX,
  BASE_WIDTH_MULTIPLIER,
  BASE_DEPTH_MULTIPLIER,
  BASE_MIN_DEPTH,
  LERP_FACTOR,
  EPSILON,
} from '#/lib/headstone-constants';

type HeadstoneBaseAutoProps = {
  headstoneObject: React.RefObject<THREE.Object3D>;
  wrapper: React.RefObject<THREE.Object3D>;
  onClick?: (e: any) => void;
  height?: number;
  name?: string;
};

function PreloadTexture({
  url,
  onReady,
}: {
  url: string;
  onReady?: () => void;
}) {
  useTexture(url);
  React.useEffect(() => {
    const id = requestAnimationFrame(() => onReady?.());
    return () => cancelAnimationFrame(id);
  }, [onReady]);
  return null;
}

/**
 * Helper to fix Multi-Material support on RoundedBoxGeometry
 */
function fixRoundedBoxUVs(geometry: THREE.BufferGeometry) {
  if (!geometry.attributes.position || !geometry.index) return;
  geometry.clearGroups();
  const normal = geometry.attributes.normal;
  const index = geometry.index;

  // 0: Right (+x), 1: Left (-x), 2: Top (+y), 3: Bottom (-y), 4: Front (+z), 5: Back (-z)
  for (let i = 0; i < index.count; i += 3) {
    const a = index.getX(i);
    const nx = normal.getX(a);
    const ny = normal.getY(a);
    const nz = normal.getZ(a);
    let matIdx = 0;
    if (Math.abs(nx) > Math.abs(ny) && Math.abs(nx) > Math.abs(nz)) {
      matIdx = nx > 0 ? 0 : 1; // Right : Left
    } else if (Math.abs(ny) > Math.abs(nx) && Math.abs(ny) > Math.abs(nz)) {
      matIdx = ny > 0 ? 2 : 3; // Top : Bottom
    } else {
      matIdx = nz > 0 ? 4 : 5; // Front : Back
    }
    geometry.addGroup(i, 3, matIdx);
  }
}

function BaseMesh({
  baseRef,
  baseTexture,
  onClick,
  name,
  dimensions,
  finish,
}: {
  baseRef: React.RefObject<THREE.Mesh | null>;
  baseTexture: THREE.Texture;
  onClick?: (e: any) => void;
  name?: string;
  dimensions: { width: number; height: number; depth: number };
  finish: 'default' | 'rock-pitch';
}) {
  // 1. Generate the Source Canvas (Memoized)
  const rockNormalCanvas = useMemo(() => {
    if (finish !== 'rock-pitch') return null;

    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;

    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    // NEW LOGIC: Ridged Multifractal Noise
    // Creates sharp peaks and valleys (V-shapes) instead of rolling hills (U-shapes)
    const sharpNoise = (x: number, y: number) => {
      let total = 0;
      let amplitude = 1;
      let frequency = 1;
      let maxAmplitude = 0;

      // 3 Octaves is enough for rock chips. Too many adds "fuzz".
      for (let i = 0; i < 3; i++) {
        const nx = x * frequency * 0.02; // Much lower frequency = Bigger shapes
        const ny = y * frequency * 0.02;

        // "Ridged" noise formula: 1.0 - abs(sin(x))
        // This creates sharp creases at 0
        const n = 1.0 - Math.abs(Math.sin(nx * 3.0 + ny * 0.5) * Math.cos(ny * 2.5 - nx * 0.5));
        
        // Square it to make the ridges sharper and plateaus flatter
        const sharp = n * n; 

        total += sharp * amplitude;
        maxAmplitude += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
      }
      return total / maxAmplitude;
    };

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        
        // Base structure (Big chips)
        let noiseVal = sharpNoise(x, y);
        
        // Contrast Boost: Push values to extremes (Chisel effect)
        // If it's a bit high, make it very high. If low, very low.
        noiseVal = (noiseVal - 0.5) * 2.5 + 0.5; 
        
        // Add tiny amount of grit (Sand) so it's not plastic
        const grit = (Math.random() - 0.5) * 0.1;
        const finalH = Math.max(0, Math.min(1, noiseVal + grit));

        // Convert Height to Normal (Slope)
        // We approximate standard Normal Map colors (Purple-ish)
        // xSlope and ySlope calculate how fast the height changes
        const hRight = sharpNoise(x + 1, y);
        const hDown = sharpNoise(x, y + 1);
        
        const scale = 30.0; // Strength of the bump
        const dX = (noiseVal - hRight) * scale;
        const dY = (noiseVal - hDown) * scale;
        const dZ = 1.0; // Up vector

        // Normalize
        const len = Math.sqrt(dX * dX + dY * dY + dZ * dZ);
        const nx = (dX / len) * 0.5 + 0.5; // Map -1..1 to 0..1
        const ny = (dY / len) * 0.5 + 0.5;
        const nz = (dZ / len) * 0.5 + 0.5;

        data[idx] = nx * 255;     // R
        data[idx + 1] = ny * 255; // G
        data[idx + 2] = nz * 255; // B (Blue is usually high)
        data[idx + 3] = 255;      // Alpha
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }, [finish]);

  // 2. Manage Base Texture Settings
  useLayoutEffect(() => {
    if (baseTexture) {
      baseTexture.wrapS = THREE.RepeatWrapping;
      baseTexture.wrapT = THREE.RepeatWrapping;
      const textureScale = 0.15;
      baseTexture.repeat.set(
        dimensions.width / textureScale,
        dimensions.height / textureScale
      );
      baseTexture.anisotropy = 16;
      baseTexture.needsUpdate = true;
    }
  }, [baseTexture, dimensions.width, dimensions.height]);

  // 3. Create Materials
  const materials = useMemo(() => {
    // Shared Polish Material
    const polishedMaterial = new THREE.MeshPhysicalMaterial({
      map: baseTexture,
      color: 0x888888,
      metalness: 0.0,
      roughness: 0.15,
      envMapIntensity: 1.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
    });

    if (finish === 'rock-pitch' && rockNormalCanvas) {
      const texShort = new THREE.CanvasTexture(rockNormalCanvas);
      const texLong = new THREE.CanvasTexture(rockNormalCanvas);

      [texShort, texLong].forEach(tex => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.colorSpace = THREE.NoColorSpace; // CRITICAL for Normal Maps
        tex.needsUpdate = true;
      });

      // Darker color + Higher roughness for contrast
      const rockColor = 0x333333; 

      const matShort = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texShort,
        normalScale: new THREE.Vector2(4, 4), // Aggressive depth
        color: rockColor, 
        metalness: 0.0,
        roughness: 0.85, 
        envMapIntensity: 0.8,
      });

      const matLong = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texLong,
        normalScale: new THREE.Vector2(4, 4),
        color: rockColor,
        metalness: 0.0,
        roughness: 0.85,
        envMapIntensity: 0.8,
      });

      return [matShort, matShort, polishedMaterial, polishedMaterial, matLong, matLong];
    }

    return polishedMaterial;
  }, [baseTexture, finish, rockNormalCanvas]);

  // 4. Update Material Repeats
  useLayoutEffect(() => {
    if (Array.isArray(materials) && finish === 'rock-pitch') {
      // DENSITY: Lower number = Bigger chips.
      // 2.5 seems to be the sweet spot for "Hand Chipped" look.
      const density = 2.5; 
      
      const matRight = materials[0] as THREE.MeshStandardMaterial;
      const matFront = materials[4] as THREE.MeshStandardMaterial;

      if (matRight.normalMap) {
        matRight.normalMap.repeat.set(
          Math.max(1, dimensions.depth * density),
          Math.max(1, dimensions.height * 2) 
        );
      }

      if (matFront.normalMap) {
        matFront.normalMap.repeat.set(
          Math.max(1, dimensions.width * density),
          Math.max(1, dimensions.height * 2)
        );
      }
    }
  }, [materials, dimensions, finish]);

  // Clean up
  useEffect(() => {
    return () => {
      if (Array.isArray(materials)) {
        materials.forEach(m => {
          if (m instanceof THREE.MeshStandardMaterial && m.normalMap) {
            m.normalMap.dispose();
          }
        });
      }
    };
  }, [materials]);

  // 5. Geometry Logic
  const geometry = useMemo(() => {
    if (finish === 'rock-pitch') {
      const geo = new RoundedBoxGeometry(1, 1, 1, 8, 0.03);
      fixRoundedBoxUVs(geo);
      return geo;
    }
    return new THREE.BoxGeometry(1, 1, 1);
  }, [finish]);

  return (
    <mesh
      ref={baseRef}
      name={name}
      onClick={onClick}
      castShadow
      receiveShadow
      geometry={geometry}
      onUpdate={(self) => {
        if (self.geometry) self.geometry.computeBoundingBox();
      }}
    >
      {Array.isArray(materials) ? (
        materials.map((mat, i) => (
          <primitive key={i} object={mat} attach={`material-${i}`} />
        ))
      ) : (
        <primitive object={materials} attach="material" />
      )}
    </mesh>
  );
}

const HeadstoneBaseAuto = forwardRef<THREE.Mesh, HeadstoneBaseAutoProps>(
  ({ headstoneObject, wrapper, onClick, height = 0.1, name }, ref) => {
    const baseRef = useRef<THREE.Mesh>(null);
    useImperativeHandle(ref, () => baseRef.current!);

    const dummyGroupRef = useRef<THREE.Group>(null);

    const baseMaterialUrl = useHeadstoneStore((s) => s.baseMaterialUrl);
    const setBaseSwapping = useHeadstoneStore((s) => s.setBaseSwapping);
    const hasStatue = useHeadstoneStore((s) => s.hasStatue);
    const widthMm = useHeadstoneStore((s) => s.widthMm);
    const heightMm = useHeadstoneStore((s) => s.heightMm);
    const baseWidthMm = useHeadstoneStore((s) => s.baseWidthMm);
    const baseHeightMm = useHeadstoneStore((s) => s.baseHeightMm);
    const baseFinish = useHeadstoneStore((s) => s.baseFinish);
    const inscriptions = useHeadstoneStore((s) => s.inscriptions);
    const selectedMotifs = useHeadstoneStore((s) => s.selectedMotifs);
    const motifOffsets = useHeadstoneStore((s) => s.motifOffsets);

    const baseHeightMeters = baseHeightMm / 1000;
    const selectedInscriptionId = useHeadstoneStore((s) => s.selectedInscriptionId);
    const setSelectedInscriptionId = useHeadstoneStore(
      (s) => s.setSelectedInscriptionId
    );
    const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);
    const setSelected = useHeadstoneStore((s) => s.setSelected);
    const setSelectedAdditionId = useHeadstoneStore(
      (s) => s.setSelectedAdditionId
    );
    const setActivePanel = useHeadstoneStore((s) => s.setActivePanel);

    const baseAPI: HeadstoneAPI = useMemo(() => {
      const baseDepth = 0.2 * BASE_DEPTH_MULTIPLIER;
      return {
        group: dummyGroupRef as React.RefObject<THREE.Group>,
        mesh: baseRef as React.RefObject<THREE.Mesh>,
        frontZ: baseDepth / 2,
        unitsPerMeter: 1000,
        version: 1,
        worldWidth: (widthMm / 1000) * BASE_WIDTH_MULTIPLIER,
        worldHeight: height,
      };
    }, [widthMm, height]);

    const requestedBaseTex = useMemo(() => {
      const file = baseMaterialUrl?.split('/').pop() ?? DEFAULT_TEX;
      const webp = file.replace(/\.jpg$/i, '.webp');
      return TEX_BASE + webp;
    }, [baseMaterialUrl]);

    const [visibleBaseTex, setVisibleBaseTex] = React.useState(requestedBaseTex);

    const baseSwapping = requestedBaseTex !== visibleBaseTex;

    useEffect(() => {
      setBaseSwapping(baseSwapping);
    }, [baseSwapping, setBaseSwapping]);

    const baseTexture = useTexture(visibleBaseTex);

    const hasTx = useRef(false);
    const targetPos = useRef(new THREE.Vector3());
    const targetScale = useRef(new THREE.Vector3(1, height, 1));
    const invMatrix = useRef(new THREE.Matrix4());
    const [baseDimensions, setBaseDimensions] = React.useState({
      width: 1,
      height: height,
      depth: 1,
    });

    useFrame(() => {
      const t = headstoneObject.current;
      const w = wrapper.current;
      const b = baseRef.current;
      if (!t || !w || !b) return;

      const baseW = baseWidthMm / 1000;
      const baseD = Math.max(0.2 * BASE_DEPTH_MULTIPLIER, BASE_MIN_DEPTH);
      const statueExtension = hasStatue() ? 0.2 : 0;
      const xOffset = statueExtension / 2;
      const headstoneDepth = 0.15;
      const baseZCenter = -(headstoneDepth / 2) + baseD / 2;

      const centerW = new THREE.Vector3(
        -xOffset,
        baseHeightMeters * 0.5 + EPSILON,
        baseZCenter
      );

      w.updateWorldMatrix(true, false);
      invMatrix.current.copy(w.matrixWorld).invert();
      const posLocal = centerW.applyMatrix4(invMatrix.current);

      targetPos.current.copy(posLocal);
      targetScale.current.set(baseW, baseHeightMeters, baseD);

      if (
        baseDimensions.width !== baseW ||
        baseDimensions.height !== baseHeightMeters ||
        baseDimensions.depth !== baseD
      ) {
        setBaseDimensions({
          width: baseW,
          height: baseHeightMeters,
          depth: baseD,
        });
      }

      if (!hasTx.current) {
        b.position.copy(targetPos.current);
        b.scale.copy(targetScale.current);
        hasTx.current = true;
      }

      b.visible = true;

      if (!hasTx.current) {
        return;
      }

      if (!baseSwapping) {
        b.position.lerp(targetPos.current, LERP_FACTOR);
        b.scale.lerp(targetScale.current, LERP_FACTOR);
      }

      b.visible = true;
    });

    return (
      <React.Fragment>
        <Suspense fallback={null}>
          <BaseMesh
            baseRef={baseRef}
            baseTexture={baseTexture}
            onClick={(e) => {
              e.stopPropagation();
              if (onClick && (!e.delta || e.delta < 2)) {
                onClick(e);
              }
            }}
            name={name}
            dimensions={baseDimensions}
            finish={baseFinish}
          />
        </Suspense>

        {inscriptions
          .filter((line: Line) => line.target === 'base')
          .map((line: Line, i: number) => {
            const zBump = (inscriptions.length - 1 - i) * 0.00005;
            return (
              <Suspense key={line.id} fallback={null}>
                <HeadstoneInscription
                  id={line.id}
                  headstone={baseAPI}
                  font={`/fonts/${line.font}.woff2`}
                  editable
                  selected={selectedInscriptionId === line.id}
                  onSelectInscription={() => {
                    setSelected('base');
                    setSelectedMotifId(null);
                    setSelectedAdditionId(null);
                    setSelectedInscriptionId(line.id);
                    setActivePanel('inscription');
                  }}
                  color={line.color}
                  lift={0.002}
                  xPos={line.xPos}
                  yPos={line.yPos}
                  rotationDeg={line.rotationDeg}
                  height={line.sizeMm}
                  text={line.text}
                  zBump={zBump}
                />
              </Suspense>
            );
          })}

        {selectedMotifs
          .filter((motif) => {
            const offset = motifOffsets[motif.id];
            return offset?.target === 'base';
          })
          .map((motif, i) => (
            <Suspense key={`${motif.id}-${i}`} fallback={null}>
              <MotifModel
                id={motif.id}
                svgPath={motif.svgPath}
                color={motif.color}
                headstone={baseAPI}
                index={i}
              />
            </Suspense>
          ))}

        {requestedBaseTex !== visibleBaseTex && (
          <Suspense fallback={null}>
            <PreloadTexture
              url={requestedBaseTex}
              onReady={() => {
                setVisibleBaseTex(requestedBaseTex);
              }}
            />
          </Suspense>
        )}
      </React.Fragment>
    );
  }
);

HeadstoneBaseAuto.displayName = 'HeadstoneBaseAuto';
export default HeadstoneBaseAuto;