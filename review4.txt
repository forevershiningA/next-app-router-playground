Thanks—this output tells me three things are still off:

1. the **marble headstone bitmap is being placed in the display box** (or with a wrong crop), not in the **authoring frame** (414×660),
2. you’re still **over-correcting X** on some items, and
3. the **uniform scale + offset** aren’t applied identically to background + all items.

Here’s a tight, drop-in pattern that fixes what your screenshot shows.

---

# 1) Always render in the authoring frame, then scale once

```ts
// AUTHORING frame (where the user placed things)
const initW = Number(design.init_width);   // 414
const initH = Number(design.init_height);  // 660

// DISPLAY box (where you show it now, CSS px)
const dispW = dyo.w, dispH = dyo.h;

// uniform "contain" scale + offsets
const s = Math.min(dispW / initW, dispH / initH);
const offX = Math.round((dispW - initW * s) / 2);
const offY = Math.round((dispH - initH * s) / 2);
```

## Headstone bitmap / mask (the marble)

Do **not** size this to `dispW×dispH`. Clip and draw it in authoring coords, then apply `(offX, offY, s)`.

```ts
ctx.save();
ctx.translate(offX, offY);
ctx.scale(s, s);

// 1) draw the shape path in authoring units (0..initW, 0..initH)
drawCurvedTopPath(ctx, initW, initH);

// 2) clip to the shape
ctx.clip();

// 3) draw the marble image in authoring units — full frame
//    (if you have a crop from the save, apply it here BEFORE scaling)
ctx.drawImage(marbleImg, 0, 0, initW, initH);

ctx.restore();
```

> The misaligned semicircle in your screenshot is almost certainly from drawing the marble at `(0,0)` **in display space** or from subtracting the crop after scaling. The sequence above prevents that.

---

# 2) Undo legacy “xy scaled with ratioHeight” once (not only X)

```ts
// Detect legacy once per design
function isLegacyScaledXY(x:number, y:number, iw:number, ih:number) {
  return Math.max(Math.abs(x), Math.abs(y)) > Math.max(iw, ih) * 1.15;
}
const legacy = isLegacyScaledXY(items[0].x, items[0].y, initW, initH);
const legacyScale = legacy ? Number(design.legacy_scale || design.ratio_height || 1) : 1;

function authoringXY(xSaved:number, ySaved:number) {
  if (!legacy) return { x: xSaved, y: ySaved };
  // old bug used same scale for both axes
  return { x: xSaved / legacyScale, y: ySaved / legacyScale };
}
```

---

# 3) Place **everything** with the same affine map

```ts
function toDisplay(xAuth:number, yAuth:number) {
  return { x: Math.round(offX + xAuth * s), y: Math.round(offY + yAuth * s) };
}

function sizeToDisplay(wAuth:number, hAuth:number) {
  return { w: Math.round(wAuth * s), h: Math.round(hAuth * s) };
}
```

Use it for inscriptions, motifs, and any boxes:

```ts
const {x: ax, y: ay} = authoringXY(item.x, item.y);
const {x, y} = toDisplay(ax, ay);

// fonts: px were authored in authoring units
const savedPx = parseFloat(String(item.font).split("px")[0] ?? item.font_size);
const fontPxDisplay = savedPx * s;

// motifs: use saved authoring w/h or SVG AR
const mwAuth = motif.width ?? (motif.height * svgAR);
const mhAuth = motif.height;
const {w: mw, h: mh} = sizeToDisplay(mwAuth, mhAuth);
```

> In your screenshot the heart motif is huge and shifted because some items still use `x / ratioHeight` (pinching to the center) or **don’t** add `(offX, offY)` the same way the background does.

---

# 4) Applying crop correctly (if you saved one)

If you trimmed whitespace when you saved the screenshot and stored a crop like `{left,top,width,height}` in **authoring CSS px**:

```ts
const cropL = crop?.left  ?? 0;
const cropT = crop?.top   ?? 0;

// 1) shift all authoring coordinates by -crop before scaling:
const ax = (legacy ? item.x / legacyScale : item.x) - cropL;
const ay = (legacy ? item.y / legacyScale : item.y) - cropT;

// 2) draw background with the same crop shift:
ctx.drawImage(marbleImg, -cropL, -cropT, initW, initH);
```

Do **not** convert crop using DPR here. You already chose to keep layout in CSS/authoring units.

---

# 5) Common pitfalls that match your image

* Drawing the marble at `(0,0, dispW, dispH)` → left–right drift & arc cut.
* Using `x / ratioHeight` for X (or mixing per-axis stretch) → top motifs pinch inward, heart shifts left.
* Adding `(offX, offY)` to items but **not** to the headstone bitmap (or vice-versa) → everything appears “slid” against the mask.
* Applying crop after scaling → offsets double or go the wrong way.

---

## Minimal patch where you place/render

```ts
// ---- frame ----
const initW = +design.init_width, initH = +design.init_height;
const s = Math.min(dyo.w / initW, dyo.h / initH);
const offX = Math.round((dyo.w - initW * s) / 2);
const offY = Math.round((dyo.h - initH * s) / 2);

// ---- legacy ----
const legacy = isLegacyScaledXY(items[0].x, items[0].y, initW, initH);
const legacyScale = legacy ? +(design.legacy_scale || 1) : 1;

// ---- draw headstone ----
ctx.save();
ctx.translate(offX, offY);
ctx.scale(s, s);
drawCurvedTopPath(ctx, initW, initH);
ctx.clip();
ctx.drawImage(marbleImg, 0, 0, initW, initH);
ctx.restore();

// ---- each item ----
for (const it of items) {
  const ax = (legacy ? it.x / legacyScale : it.x);
  const ay = (legacy ? it.y / legacyScale : it.y);
  const x  = Math.round(offX + ax * s);
  const y  = Math.round(offY + ay * s);

  if (it.type === 'Inscription') {
    const px = parseFloat(String(it.font).split('px')[0] ?? it.font_size);
    ctx.font = `${px * s}px ${it.font_family}`;
    drawText(it, x, y);
  } else if (it.type === 'Motif') {
    const {w, h} = sizeToDisplay(it.width ?? it.height * svgAR, it.height);
    drawMotif(it, x, y, w, h);
  }
}
```

Run with this structure and the marble will center correctly, the arc will be where it was when the user authored it on the iPhone, and the inscriptions/motifs will keep their relative spacing. If anything still drifts, log these five numbers per render: `initW, initH, s, offX, offY` and confirm you use the same `(offX, offY, s)` for the **background and all items**.
