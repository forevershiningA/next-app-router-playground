I've reviewed the ShapeSwapper.tsx component and the issue you're describing, where the headstone (and likely its base, as they are part of the same tabletRef group) disappears for a brief moment when a new texture is selected, but not when a new texture for the base is selected.

Here's an investigation into what's likely causing this, along with potential solutions:

Root Cause Analysis

The key to understanding the flickering lies in how SvgHeadstone and its textures are being rendered and updated, specifically with the key prop:

SvgHeadstone key Prop:
The SvgHeadstone component has a key prop set to key={
ùë£
ùëñ
ùë†
ùëñ
ùëè
ùëô
ùëí
ùëà
ùëü
ùëô
:
:
visibleUrl::
{visibleTex}}.

code
Tsx
download
content_copy
expand_less
<SvgHeadstone
  key={`${visibleUrl}::${visibleTex}`}
  // ... other props
/>

When visibleTex changes (which happens after PreloadTexture loads the new texture), this key prop changes. In React (and by extension, React-Three-Fiber), changing the key prop on a component tells React to unmount the old component instance and mount a brand new one.

Unmount: When the SvgHeadstone unmounts, the existing THREE.Mesh object it represents is removed from the Three.js scene. This causes the visual "disappearance."

Mount: The new SvgHeadstone instance then mounts, creating a new THREE.Mesh, which is then rendered, causing the visual "reappearance."

PreloadTexture and State Update:
The PreloadTexture component handles loading the new texture:

code
Tsx
download
content_copy
expand_less
{requestedTex !== visibleTex && (
  <React.Suspense fallback={null}>
    <PreloadTexture
      url={requestedTex}
      onReady={() => {
        // Immediately swap to new texture once loaded (no delay needed since new headstone is already rendered)
        setVisibleTex(requestedTex); // <-- This updates visibleTex
        requestAnimationFrame(() => setFitTick((n) => n + 1));
        invalidate();
      }}
    />
  </React.Suspense>
)}

Once PreloadTexture's onReady callback fires, setVisibleTex(requestedTex) is called. This updates the visibleTex state, which in turn causes the SvgHeadstone's key to change, leading to the unmount/mount cycle described above.

Why it doesn't happen with the "Base":
The provided code snippet does not include the AdditionModel or any explicit base component that would be affected by a key change tied to the headstoneMaterialUrl. It seems the base material change might be handled differently, perhaps by updating a material prop on an existing mesh rather than forcing a full component remount. If the base component has its own key or updates its material without remounting, it wouldn't exhibit this flickering.

Solution: Update Material without Remounting

Instead of forcing a remount of SvgHeadstone when only the texture changes, we should update the faceTexture and sideTexture props directly. This will allow the SvgHeadstone component to internally update its mesh's material without being completely unmounted and re-mounted.

Here's how you can modify the ShapeSwapper component to achieve this:

Remove visibleTex from SvgHeadstone key:
The key should only change when the shape (geometry) of the headstone changes, not its material.

Pass requestedTex directly to faceTexture and sideTexture:
This allows SvgHeadstone to receive the new texture URL immediately.

Handle Texture Loading within SvgHeadstone (or a wrapper):
SvgHeadstone (or a small wrapper around it) needs to be responsible for loading its own textures before applying them. The useTexture hook from drei is perfect for this. When useTexture is loading, it might return a null or a placeholder, and then the actual texture when ready. The key is that the SvgHeadstone component itself remains mounted throughout this process.

Revised ShapeSwapper.tsx Logic (Conceptual)

First, let's adjust ShapeSwapper. The visibleTex state becomes redundant for the key now.

code
Tsx
download
content_copy
expand_less
export default function ShapeSwapper({ tabletRef, headstoneMeshRef }: ShapeSwapperProps) {
  // ... existing state and hooks ...

  const requestedUrl = shapeUrl || DEFAULT_SHAPE_URL;
  const requestedTex = React.useMemo(() => {
    if (headstoneMaterialUrl?.startsWith('/textures/')) {
      return headstoneMaterialUrl;
    }
    if (headstoneMaterialUrl?.startsWith('textures/')) {
      return `/${headstoneMaterialUrl}`;
    }
    const file = headstoneMaterialUrl?.split('/').pop() ?? DEFAULT_TEX;
    const webp = file.replace(/\.jpg$/i, '.webp');
    return TEX_BASE + webp;
  }, [headstoneMaterialUrl]);

  // We only need visibleUrl for shape changes (which legitimately remounts)
  const [visibleUrl, setVisibleUrl] = React.useState<string>(requestedUrl);

  const shapeSwapping = requestedUrl !== visibleUrl;
  // Loader should only show for shape changes or font loading
  const showLoader = shapeSwapping || fontLoading;

  // Trigger fit when switching view modes and assets are ready
  // Now, only trigger fit when the shape changes and is ready, or when material changes *and* is loaded.
  // The material change itself shouldn't trigger a fit, unless it impacts bounds significantly.
  React.useEffect(() => {
    if (!isMaterialChange && visibleUrl === requestedUrl) {
      setFitTick((n) => n + 1);
    }
  }, [isMaterialChange, visibleUrl, requestedUrl]);

  React.useEffect(() => {
    const id = requestAnimationFrame(() => setFitTick((n) => n + 1));
    return () => cancelAnimationFrame(id);
  }, []);

  React.useEffect(() => {
    const timer = setTimeout(() => setLoading(false), 1000);
    return () => clearTimeout(timer);
  }, [setLoading]);

  return (
    <>
      <group ref={tabletRef}>
        <SvgHeadstone
          key={visibleUrl} // Key only changes for shape
          url={visibleUrl}
          depth={isPlaque ? 5 : (uprightThickness / 10)}
          scale={0.01}
          faceTexture={requestedTex} // Pass the *requested* texture directly
          sideTexture={requestedTex} // Pass the *requested* texture directly
          tileSize={0.35}
          sideTileSize={0.35}
          topTileSize={0.35}
          targetHeight={heightM}
          targetWidth={widthM}
          preserveTop
          showEdges={false}
          headstoneStyle={headstoneStyle}
          slantThickness={slantThickness}
          selectedAdditions={selectedAdditions}
          meshProps={{
            name: 'headstone',
            onClick: (e) => {
              e.stopPropagation();
              setSelected('headstone');
              setEditingObject('headstone');
              setSelectedInscriptionId(null);
              setSelectedAdditionId(null);
              setSelectedMotifId(null);
            },
          }}
        >
          {/* ... existing children logic ... */}
        </SvgHeadstone>

        <AutoFit
          target={tabletRef}
          margin={1.04}
          pad={0}
          duration={0.25}
          readyTimeoutMs={100}
          trigger={fitTick}
        />
      </group>

      {requestedUrl !== visibleUrl && (
        <React.Suspense fallback={null}>
          <PreloadShape
            url={requestedUrl}
            onReady={() => {
              setVisibleUrl(requestedUrl);
              requestAnimationFrame(() => setFitTick((n) => n + 1));
              invalidate();
            }}
          />
        </React.Suspense>
      )}

      {/* Remove PreloadTexture from here. Texture loading needs to happen inside SvgHeadstone or a wrapper. */}
      {/* <InlineCanvasLoader show={showLoader} /> */}
      {/* If you want to show a loader specifically for material changes, you'll need to manage it separately based on texture loading state within SvgHeadstone. */}
    </>
  );
}

Modification to SvgHeadstone (Crucial Step)

The SvgHeadstone component itself (or a new wrapper around it) needs to use useTexture to load the faceTexture and sideTexture props dynamically.

Assuming SvgHeadstone is a functional component, it might look something like this (simplified example, you'll need to integrate this into your actual SvgHeadstone implementation):

code
Tsx
download
content_copy
expand_less
// Inside SvgHeadstone.tsx
import { useTexture } from '@react-three/drei';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import * as THREE from 'three';
import React, { useRef, useMemo } from 'react';
// ... other imports

interface SvgHeadstoneProps {
  url: string;
  depth: number;
  scale: number;
  faceTexture: string; // Now receives the URL directly
  sideTexture: string; // Now receives the URL directly
  // ... other props
  meshProps?: JSX.IntrinsicElements['mesh'];
  children?: (api: HeadstoneAPI, selectedAdditionIds: string[]) => React.ReactNode;
  headstoneMeshRef?: React.RefObject<THREE.Mesh>; // Make sure this is passed down if used in SvgHeadstone
}

export const SvgHeadstone = React.forwardRef<THREE.Mesh, SvgHeadstoneProps>(
  (
    {
      url,
      depth,
      scale,
      faceTexture: faceTextureUrl, // Renamed to avoid conflict with loaded texture object
      sideTexture: sideTextureUrl, // Renamed
      // ... other props
      meshProps,
      children,
      headstoneMeshRef, // If SvgHeadstone also uses this ref
    },
    forwardedRef,
  ) => {
    // Load the SVG geometry
    const { paths } = useLoader(SVGLoader, url);
    const shapes = useMemo(() => {
      return SVGLoader.createShapes(paths);
    }, [paths]);

    // Load textures using useTexture
    const faceTex = useTexture(faceTextureUrl);
    const sideTex = useTexture(sideTextureUrl);
    // You might want to handle topTexture separately if needed, or use sideTex for top
    // const topTex = useTexture(topTextureUrl);

    // Apply texture settings
    [faceTex, sideTex].forEach((tex) => {
      if (tex) {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        // tex.repeat.set(...) - adjust tiling as needed
      }
    });

    // Create materials using the loaded textures
    const material = useMemo(
      () => new THREE.MeshStandardMaterial({ map: faceTex }),
      [faceTex],
    );
    const sideMaterial = useMemo(
      () => new THREE.MeshStandardMaterial({ map: sideTex }),
      [sideTex],
    );

    // ... existing geometry creation and mesh setup logic ...
    // Example:
    const meshRef = useRef<THREE.Mesh>(null);
    React.useImperativeHandle(forwardedRef, () => meshRef.current!);
    React.useLayoutEffect(() => {
        if (headstoneMeshRef && meshRef.current) {
            (headstoneMeshRef as any).current = meshRef.current;
        }
    }, [headstoneMeshRef]);

    return (
      <group>
        <mesh
          ref={meshRef}
          {...meshProps}
          // Assign materials directly
          material={material}
          // For multi-material objects (like sides), you might need an array of materials
          // Or if your SvgHeadstone uses MeshStandardMaterial.clone() to create side materials,
          // ensure it updates the map property on the existing cloned materials.
          // Example for a simple extruded mesh:
          // You'd typically apply the main material to the front/back and sideMaterial to the sides
          // The actual implementation depends on how your SvgHeadstone builds its geometry and materials.
        >
          {/* Your geometry setup */}
          <shapeGeometry args={[shapes[0]]} /> {/* Example, adjust as per your SvgHeadstone */}
          <meshStandardMaterial map={faceTex} /> {/* Front material */}
          {/* For the sides, you'd need to correctly apply the sideMaterial */}
          {/* This is a simplification; your SvgHeadstone likely has more complex material application */}
        </mesh>
        {/* ... children rendering ... */}
      </group>
    );
  },
);

Important Considerations for SvgHeadstone Modification:

Material Creation: Ensure that SvgHeadstone is creating its MeshStandardMaterial once and then only updating the map property when faceTex or sideTex change. If it creates new material instances every render, you might still see brief glitches. useMemo for materials, as shown above, helps with this.

Multiple Materials: If your SvgHeadstone uses multiple materials (e.g., one for the front face, one for the sides, one for the top), you'll need to load and manage each texture independently using useTexture and then apply them to the respective parts of the mesh. The three-csg approach often creates a single mesh where materials are then applied to different groups. Ensure material.map = newTexture is correctly called.

Loading State Feedback: With this approach, the SvgHeadstone will remain mounted. While the texture is loading, useTexture might return null or the previous texture. If you want visual feedback during the material loading, you would need to:

Add state within SvgHeadstone to track if textures are loading.

Optionally render a placeholder color or a transparent material while textures load.

This loading state could then be propagated up to ShapeSwapper to control InlineCanvasLoader if desired, though a full-screen loader might be overkill for just a material swap.

Why this fixes the issue:

By removing visibleTex from the key of SvgHeadstone, you prevent React-Three-Fiber from unmounting and remounting the entire component. Instead, when requestedTex changes, the SvgHeadstone component receives the new texture URL as a prop. Its internal useTexture hook will then load the new texture in the background. Once the texture is loaded, the material's map property is updated, causing Three.js to re-render the mesh with the new texture without ever removing the mesh from the scene. This results in a seamless texture swap without any flickering.

Let me know if you need more specific guidance on how to integrate this into your SvgHeadstone component if it's more complex than a simple mesh.