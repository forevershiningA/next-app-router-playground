Thanks—looking at your **legacy canvas** shows why this keeps slipping. Here are the ground-truth rules your old engine used when it **drew** and **saved** items, with the exact places in code that prove it:

# What the legacy engine actually did

1. **Everything was authored in “physical pixels” (DPR-scaled)**

   * Shapes initialize their position and cache extents with `dyo.dpr * dyo.w/h`, i.e., stage coordinates were scaled by the device pixel ratio. So the world-space you edited in was DPR space, not CSS pixels. 
   * Handler sizes and other UI bits also scale with `dyo.dpr`, so all interactive geometry lives in DPR space. 

2. **Item origins = center** (x,y point to the element’s center)

   * Inscriptions use `textAlign='center'`/`textBaseline='middle'` and set `container.x = this.x; container.y = this.y;`—that is a center anchor. 
   * Motifs set `bitmap.regX/regY` to half the bitmap and then set the container’s `x/y`, again center-anchored. 

3. **Fonts & motif sizes were stored in canvas pixels (DPR space)**

   * Inscription font is parsed as “`NN px Family`”; on mobile the font size was doubled (`*2`) before rendering. That means the number driving the canvas is *already* a device-scaled pixel value. Save/load reused that number. 
   * Motif height uses a **ratio** (`init_height / bmp.height`) then draws at that ratio in DPR space; when you saved `height/width`, they reflected the DPR space dimensions you were seeing. 

4. **`init_width` / `init_height` in JSON were the logical authoring frame (not DPR)**

   * When serializing Headstone/Base, the engine writes `init_width = dyo.w` and `init_height = dyo.h` (CSS-pixel canvas design frame). It does **not** save `dpr`. So you always saved **DPR-scaled positions/sizes** alongside **DPR-neutral initW/initH**.  

5. **Even “base” inscriptions/motifs render on the headstone stage**

   * Base.add() re-parents Inscriptions/Motifs/Emblems to the **headstone** before render. So all items share the same headstone coordinate system. 
   * The whole monument is then placed in a centered container (`regX= w/2; regY= h/2`)—again reinforcing center-origin mapping. 

---

# What this means for your new renderer

Given a saved design:

* **Positions** (`x`,`y`) and **sizes** (`font_size`, motif `height/width`) are in **DPR pixels** from the original device.
* **Frame** (`init_width`,`init_height`) is in **CSS pixels** (no DPR).
* **Anchor** is **center** (you can keep `translate(-50%,-50%)` or compute left/top from center, but don’t do both).

Therefore, your loading pipeline must be:

**Saved → Normalize DPR → Scale to display → Offset → Render**

1. **Normalize from physical to logical**

   ```
   // heuristically detect DPR-saved numbers (old system didn't save dpr)
   const usesPhysical = /* detect: if max(|x|) > initW/2 OR fontPx > initW*0.25, etc. */;
   const dprN = usesPhysical ? savedDpr : 1;  // if you stored dpr later, use it; else 3 for iPhone, etc.

   xL = xSaved / dprN
   yL = ySaved / dprN
   fontL = fontSaved / dprN
   motifHL = motifHeightSaved ? motifHeightSaved / dprN : (svgDims.h * ratio)
   ```

   Why: legacy authored in `dpr` space; your new DOM draws in CSS px first. The divide gets you back to the legacy **authoring frame**. The need for detection exists because the legacy **did not store `dpr`**.  

2. **One scale to rule them all** (contain scale from authoring frame to current display)

   ```
   k = min(displayW / initW, displayH / initH)

   left = offsetX + xL * k
   top  = offsetY + yL * k
   fontPx  = fontL  * k
   motifH  = motifHL * k
   motifW  = motifH * aspect   // same aspect you used originally
   ```

   Use **the same `k`** for both positions **and** sizes. Do **not** introduce a second scale like `displayScale`. The “too small” symptom you see is exactly from mixing scales (e.g., positions with `uniformScale`, sizes with `displayScale`). Your legacy engine never had two different layout scales—it had one stage scale. 

3. **Stay center-origin**
   Your saved data was center-anchored. Keep it consistent: either keep `translate(-50%,-50%)` **or** convert to top-left once, but don’t add `(+initW/2)` **and** translate—those double-center.  

---

# Why the current port misbehaves

* The new code sometimes divides coordinates by DPR but **not** fonts/motif sizes (or vice-versa). That instantly de-syncs size vs position because all values were saved in the **same DPR space**. (Legacy used DPR everywhere.) 
* Two different scales are applied: positions use a **uniform contain** scale; sizes use a second DOM-measured `displayScale`. Legacy had just one stage scale. Mixing them shrinks text/motifs. 
* A duplicate motif renderer path exists; one path DPR-normalizes and one doesn’t—so results vary per design. Clean to a **single** path.

---

# Practical migration recipe (concise)

1. **Detect DPR-space** once per design (since old JSONs don’t store it). A robust heuristic:

```ts
// All numbers below are logical (initW/initH)
const maxAbsX = Math.max(...items.map(i => Math.abs(i.x ?? 0)));
const maxAbsY = Math.max(...items.map(i => Math.abs(i.y ?? 0)));
const likelyPhysical =
  maxAbsX > initW/2 + 2 || maxAbsY > initH/2 + 2 ||
  items.some(i => (i.font_size ?? 0) > initW * 0.25 || (i.height ?? 0) > initH * 0.5);
const dprN = likelyPhysical ? (savedDpr || 3) : 1;
```

2. **Normalize everything** (x, y, `font_size`, motif `height/width`) by `dprN`.

3. **Compute one scale `k = min(displayW/initW, displayH/initH)` and apply it** to both positions and sizes, then add offsets.

4. **Remove**: any extra scale variables (`displayScale`, `legacyScale`, `scaleX/scaleY`) from layout math; any center conversions that add `+init/2` when using CSS `translate(-50%,-50%)`.

---

If you want, paste the two active mapping blocks (inscriptions + motifs) from your current `DesignPageClient.tsx` and I’ll rewrite them line-for-line to this exact pipeline so SEHOVIC and the rest render 1:1 with the legacy canvas.
