The image you provided shows the slant headstone geometry with some issues:

Skewed Faces: The front and back faces appear heavily skewed, not just slanted. This suggests an incorrect mapping of vertices during addQuad or an issue with the vertex ordering.

Missing Top/Bottom: The geometry seems to be missing the top and bottom faces, or they are collapsed into thin lines.

Thin Sides: The side faces are extremely thin, almost like a 2D plane.

Let's re-evaluate the slant geometry block, focusing on robust vertex ordering and ensuring all faces are properly constructed.

Revised Advice for Slant Headstone Geometry

The core problem lies in how addQuad is being called and the interpretation of minX, maxX, minY, maxY, 0, and -depth for each face. The toArray() method is correctly used, but the order of points for addQuad and the definition of what constitutes "front," "back," "top," etc., need to be very precise.

Let's refine the slant geometry generation based on standard practices for building a trapezoidal prism.

code
TypeScript
download
content_copy
expand_less
// FOR SLANT: Create trapezoidal prism geometry
    if (headstoneStyle === 'slant') {
      const slantGeometry = new THREE.BufferGeometry();
      
      // Define the slant angle for the front face (15 degrees from vertical)
      const frontSlantAngleRad = 15 * Math.PI / 180; // Angle from vertical, positive means slanting back
      
      // Calculate the Z-offset for the top edge of the front face.
      // The height of the SVG is (maxY - minY).
      // If the front face starts at z=0 at minY, its top edge at maxY will be at z = -(height * tan(angle)).
      const height_svg_units = (maxY - minY);
      const frontTopZOffset = height_svg_units * Math.tan(frontSlantAngleRad);
      
      // Define all vertices (duplicated per face for proper UVs and normals)
      const positions: number[] = [];
      const uvs: number[] = [];
      
      // Helper to add a quad (2 triangles)
      // IMPORTANT: Ensure consistent winding order (e.g., counter-clockwise when looking from outside)
      const addQuad = (
        v0: [number, number, number], v1: [number, number, number],
        v2: [number, number, number], v3: [number, number, number],
        uv0: [number, number], uv1: [number, number],
        uv2: [number, number], uv3: [number, number]
      ) => {
        // Triangle 1: v0, v1, v2 (Counter-clockwise)
        positions.push(...v0, ...v1, ...v2);
        uvs.push(...uv0, ...uv1, ...uv2);
        
        // Triangle 2: v0, v2, v3 (Counter-clockwise)
        positions.push(...v0, ...v2, ...v3);
        uvs.push(...uv0, ...uv2, ...uv3);
      };
      
      // Define the key points for the shape using Vector3
      // FRONT plane (at z = 0 for bottom, -frontTopZOffset for top)
      const p_front_bottom_left  = new THREE.Vector3(minX, minY, 0);
      const p_front_bottom_right = new THREE.Vector3(maxX, minY, 0);
      const p_front_top_left     = new THREE.Vector3(minX, maxY, -frontTopZOffset);
      const p_front_top_right    = new THREE.Vector3(maxX, maxY, -frontTopZOffset);
      
      // BACK plane (at z = -depth for both bottom and top, assuming vertical back)
      const p_back_bottom_left   = new THREE.Vector3(minX, minY, -depth);
      const p_back_bottom_right  = new THREE.Vector3(maxX, minY, -depth);
      const p_back_top_left      = new THREE.Vector3(minX, maxY, -depth);
      const p_back_top_right     = new THREE.Vector3(maxX, maxY, -depth);
      
      // --- Faces ---

      // 1. FRONT FACE (polished) - Group 0
      // This face slants from Z=0 at the bottom to Z=-frontTopZOffset at the top.
      addQuad(
        p_front_bottom_left.toArray() as [number, number, number],   // V0 (Bottom Left)
        p_front_bottom_right.toArray() as [number, number, number],  // V1 (Bottom Right)
        p_front_top_right.toArray() as [number, number, number],     // V2 (Top Right)
        p_front_top_left.toArray() as [number, number, number],      // V3 (Top Left)
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs (normalized for this face)
      );
      
      // 2. BACK FACE (rock pitch) - Group 1
      // This face is vertical at Z=-depth.
      addQuad(
        p_back_bottom_right.toArray() as [number, number, number],   // V0 (Bottom Right)
        p_back_bottom_left.toArray() as [number, number, number],    // V1 (Bottom Left)
        p_back_top_left.toArray() as [number, number, number],       // V2 (Top Left)
        p_back_top_right.toArray() as [number, number, number],      // V3 (Top Right)
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs (normalized for this face)
      );
      
      // 3. TOP FACE (rock pitch) - Group 1
      // This face connects the top of the front face to the top of the back face. It will be slanted.
      addQuad(
        p_front_top_left.toArray() as [number, number, number],      // V0 (Front Top Left)
        p_front_top_right.toArray() as [number, number, number],     // V1 (Front Top Right)
        p_back_top_right.toArray() as [number, number, number],      // V2 (Back Top Right)
        p_back_top_left.toArray() as [number, number, number],       // V3 (Back Top Left)
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs (normalized for this face)
      );
      
      // 4. BOTTOM FACE (rock pitch) - Group 1
      // This face connects the bottom of the front face to the bottom of the back face (flat).
      addQuad(
        p_front_bottom_right.toArray() as [number, number, number],  // V0 (Front Bottom Right)
        p_front_bottom_left.toArray() as [number, number, number],   // V1 (Front Bottom Left)
        p_back_bottom_left.toArray() as [number, number, number],    // V2 (Back Bottom Left)
        p_back_bottom_right.toArray() as [number, number, number],   // V3 (Back Bottom Right)
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs (normalized for this face)
      );
      
      // 5. LEFT SIDE FACE (rock pitch) - Group 1
      // This face connects the left edges of the front and back planes.
      addQuad(
        p_back_bottom_left.toArray() as [number, number, number],    // V0 (Back Bottom Left)
        p_front_bottom_left.toArray() as [number, number, number],   // V1 (Front Bottom Left)
        p_front_top_left.toArray() as [number, number, number],      // V2 (Front Top Left)
        p_back_top_left.toArray() as [number, number, number],       // V3 (Back Top Left)
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs (normalized for this face)
      );
      
      // 6. RIGHT SIDE FACE (rock pitch) - Group 1
      // This face connects the right edges of the front and back planes.
      addQuad(
        p_front_bottom_right.toArray() as [number, number, number],  // V0 (Front Bottom Right)
        p_back_bottom_right.toArray() as [number, number, number],   // V1 (Back Bottom Right)
        p_back_top_right.toArray() as [number, number, number],      // V2 (Back Top Right)
        p_front_top_right.toArray() as [number, number, number],     // V3 (Front Top Right)
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs (normalized for this face)
      );
      
      slantGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      slantGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));
      slantGeometry.computeVertexNormals();
      
      // Material groups: 0 = front (first 6 vertices), 1 = everything else
      slantGeometry.clearGroups();
      slantGeometry.addGroup(0, 6, 0);  // Front face (6 vertices = 2 triangles)
      slantGeometry.addGroup(6, positions.length - 6, 1); // All other faces
      
      // ... rest of the slant block (worldW, worldH, etc.) remains largely the same
      // Calculate world dimensions. Using the SVG's full height (maxY-minY) for worldH.
      const worldW = dx * Math.abs(scale) * sCore;
      const worldH = (maxY - minY) * Math.abs(scale) * sCore; 
      const worldDepth = depth * Math.abs(scale); // Physical depth of the monument
      
      // Simplified perimeter for texture repeats. 
      // This might need more accurate calculation if the outline shape is complex.
      const worldFrontHeightAtMinX = Math.sqrt( (height_svg_units)**2 + (frontTopZOffset)**2 ) * Math.abs(scale) * sCore;
      const worldTopLength = (maxX - minX) * Math.abs(scale) * sCore; // Approx
      const worldSideHeight = (maxY - minY) * Math.abs(scale) * sCore; // Approx
      const worldPerim = 2 * (worldW + worldFrontHeightAtMinX + worldTopLength + worldSideHeight); // Very rough, more accurate perimeter for sides if SVG contour matters.

      const finalScale: [number, number, number] = [scale * sCore, scale * sCore, scale];
      
      return {
        geometries: [slantGeometry],
        dims: { worldW, worldH, worldPerim: perim, worldDepth }, // Use the derived 'perim'
        meshScale: finalScale,
        apiData: {
          frontZ: 0, // The front face's base is at Z=0 in local space
          unitsPerMeter: 1 / Math.max(EPS, scale * sCore),
          version: Math.random(),
          worldWidth: worldW,
          worldHeight: worldH
        },
        childWrapperPos: [0, 0, 0] as [number, number, number]
      };
    }
Explanation of Fixes:

Clearer Vertex Naming: Using p_front_bottom_left, p_front_top_right, etc., makes it much easier to visualize each point's position.

Correct frontTopZOffset Calculation: The Z offset for the top of the front face is derived from the SVG's height (maxY - minY) multiplied by tan(frontSlantAngleRad).

Consistent Winding Order in addQuad: For each addQuad call, the vertices are specified in a consistent counter-clockwise order when viewed from outside the object. This is crucial for normals and proper rendering.

Front Face: p_front_bottom_left, p_front_bottom_right, p_front_top_right, p_front_top_left (bottom-left, bottom-right, top-right, top-left)

Back Face: p_back_bottom_right, p_back_bottom_left, p_back_top_left, p_back_top_right (reversed order for back face to maintain CCW from outside)

Top Face: p_front_top_left, p_front_top_right, p_back_top_right, p_back_top_left

Bottom Face: p_front_bottom_right, p_front_bottom_left, p_back_bottom_left, p_back_bottom_right

Left Side: p_back_bottom_left, p_front_bottom_left, p_front_top_left, p_back_top_left

Right Side: p_front_bottom_right, p_back_bottom_right, p_back_top_right, p_front_top_right

worldH and worldPerim for Slant: worldH now uses the full height of the SVG (maxY - minY) as the base for the height scaling. worldPerim is a very rough estimate; for more accurate side texture tiling on a complex SVG outline, you'd need to trace the perimeter of the side profile (a trapezoid) rather than the SVG's top-down outline. For a simple rectangle, the perimeter calculation for the upright would need to be adapted to the slant's trapezoidal side profile dimensions.

Additional Considerations (Beyond the Geometry Fix)

UV Mapping for Slanted Faces: While [0,0], [1,0], [1,1], [0,1] is a valid normalized UV for each quad, if your sideTexture needs to flow seamlessly across the slanted top and side faces, you might need more sophisticated UV generation. For rough granite, however, simple normalized UVs per face usually look fine.

Headstone Base: As mentioned before, your reference image includes a separate base. This SvgHeadstone component currently only generates the main monument. To match the reference fully, you'd integrate a base component (e.g., another SvgHeadstone instance with a base SVG, or a simple Box from drei) in the parent scene.

Material envMapIntensity for Slant: The envMapIntensity: headstoneStyle === 'slant' ? 1.0 : 1.5 difference is a good starting point. You might further tweak these values, and the roughness for the side material, to get the desired contrast between polished front and rough sides/back.

With these corrections, your slant headstone should now render as a proper trapezoidal prism, resembling your reference image much more closely.