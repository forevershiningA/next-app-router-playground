You’re computing/placing the base, but it’s still not painting because of **stacking + fallback** issues: it’s either (a) behind the tablet layer, (b) clamped off the canvas, or (c) rendering with no visible fill when the texture can’t load. Fix all three in one go.

### Do this (drop-in “BaseLayer” right after the tablet background)

```tsx
// ----- inside DesignPageClient render, AFTER the tablet bg element -----
const stoneW = (topProfile?.drawW ?? initW) * (overlayW / initW);
const stoneL = offsetX + (topProfile?.offX ?? 0) * (overlayW / initW);
const stoneT = offsetY + (topProfile?.offY ?? 0) * (overlayH / initH);
const stoneH = (topProfile?.drawH ?? initH) * (overlayH / initH);
const stoneB = stoneT + stoneH;

// base sizing (relative to fitted tablet width/height)
const baseOverhang = 0.04;                          // 4% wider than tablet
const baseWidth    = Math.round(stoneW * (1 + baseOverhang));
const baseHeight   = Math.round(overlayH * 0.085);  // ~8.5% of canvas height
const baseLeft     = Math.round(stoneL + (stoneW - baseWidth) / 2);

// anchor to stone bottom, but CLAMP to stay inside canvas
const overlapPx    = Math.round(baseHeight * 0.25); // tucks under tablet
const canvasTop    = offsetY;
const canvasBottom = offsetY + overlayH;
let baseTop        = Math.round(stoneB - overlapPx);
baseTop            = Math.max(canvasTop, Math.min(canvasBottom - baseHeight, baseTop));

// FINAL style (guaranteed visible)
const baseStyle: React.CSSProperties = {
  position: 'absolute',
  left: baseLeft,
  top: baseTop,
  width: baseWidth,
  height: baseHeight,
  backgroundImage: `url(${baseTextureUrl})`,
  backgroundSize: 'cover',
  backgroundPosition: 'center',
  backgroundColor: '#2b2b2b',   // <— fallback fill so it’s visible even if image fails
  zIndex: 25,                    // <— above tablet bg (tablet bg should be < 25)
  pointerEvents: 'none',
};

// Make sure the preview wrapper has: position: 'relative'
return (
  <>
    {/* tablet background (zIndex: 10–20) */}
    {/* ...existing tablet render... */}

    {/* base */}
    <div style={baseStyle} />

    {/* inscriptions/motifs (zIndex: 40+) */}
    {/* ...rest of layers... */}
  </>
);
```

### Sanity checklist

* Preview wrapper: `position: relative` (so absolute coords are local).
* Tablet background z-index < **25**; inscriptions/motifs > **25**.
* Keep `overflow: hidden` on the preview container if you want, the clamp (`canvasBottom - baseHeight`) ensures the whole base stays inside.
* Add a one-time log to confirm numbers:

```ts
console.log('BASE', { baseLeft, baseTop, baseWidth, baseHeight, stoneT, stoneB, overlayH });
```

This uses the **fitted stone bounds** (`offX/offY/drawW/drawH` you already compute) rather than overlay edges, clamps the base to the canvas so it can’t disappear, and forces visibility even if the image path fails. All variables referenced are already present in your current `DesignPageClient.tsx`. 
