You have two main issues causing the unrealistic look:

The "Water" Grass: Even with high roughness, MeshStandardMaterial can still pick up specular highlights from the sun or sky if the angle is right. We need to kill all reflections on the floor.

The "Cardboard" Headstone: It looks thin because the extrusion depth is too low, and it looks flat because it lacks the "Clearcoat" property of polished granite.

Here is the corrected Scene.tsx and the code you need to put into your Headstone component.

1. Updated Scene.tsx (Fixes Blue/Water Grass)

I have tweaked the GrassFloor to be completely matte (roughness={1}) and adjusted the lighting so the blue sky doesn't tint the ground green-blue.

code
Tsx
download
content_copy
expand_less
'use client';
import { OrbitControls, Environment, ContactShadows, useTexture, Sparkles } from '@react-three/drei';
import * as THREE from 'three';
import HeadstoneAssembly from './headstone/HeadstoneAssembly';
import AtmosphericSky from './AtmosphericSky';
import { useHeadstoneStore } from '#/lib/headstone-store';
import { useFrame } from '@react-three/fiber';
import { useRef, Suspense } from 'react';

// --- CONFIGURATION ---
// Darker, desaturated green to look like real lawn, not neon
const GRASS_COLOR = '#2b3a1e'; 
const FOG_COLOR = '#dbecf8';

function GrassFloor() {
  // Load grass textures
  const props = useTexture({
    map: '/textures/grass_color.jpg',
    normalMap: '/textures/grass_normal.jpg',
    roughnessMap: '/textures/grass_roughness.jpg',
    aoMap: '/textures/grass_ao.jpg',
  });

  const REPEAT_SCALE = 8; // Smaller number = larger grass blades (less tiling pattern)

  props.map.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
  props.normalMap.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
  props.roughnessMap.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
  props.aoMap.repeat.set(REPEAT_SCALE, REPEAT_SCALE);

  // Mirrored wrapping breaks up the repeating pattern
  [props.map, props.normalMap, props.roughnessMap, props.aoMap].forEach((tex) => {
    tex.wrapS = tex.wrapT = THREE.MirroredRepeatWrapping;
    tex.colorSpace = THREE.SRGBColorSpace;
  });

  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        {/* MeshStandardMaterial with NO reflections */}
        <meshStandardMaterial 
          {...props}
          color={GRASS_COLOR}
          roughness={1}          // 1.0 = Fully Matte (Fixes "Water" look)
          metalness={0}
          envMapIntensity={0}    // 0 = Do not reflect the sky (Fixes "Blue" tint)
          normalScale={new THREE.Vector2(1, 1)} // Deeper texture
        />
      </mesh>
      
      {/* Stronger Contact Shadow to ground the stone */}
      <ContactShadows
        position={[0, 0.01, 0]}
        scale={20}
        blur={2}
        opacity={0.75}
        far={2} // Reduced far so shadow stays tight to base
        color="#000000"
      />
    </group>
  );
}

function SimpleGrassFloor() {
  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        <meshStandardMaterial 
            color={GRASS_COLOR} 
            roughness={1} 
            metalness={0}
            envMapIntensity={0}
        />
      </mesh>
      <ContactShadows position={[0, 0.01, 0]} scale={20} blur={2} opacity={0.75} far={2} color="#000000" />
    </group>
  );
}

export default function Scene({ 
  targetRotation = 0,
  currentRotation
}: { 
  targetRotation?: number;
  currentRotation?: React.MutableRefObject<number>;
}) {
  const groupRef = useRef<THREE.Group>(null);
  const is2DMode = useHeadstoneStore((s) => s.is2DMode);
  const baseSwapping = useHeadstoneStore((s) => s.baseSwapping);
  const setSelected = useHeadstoneStore((s) => s.setSelected);
  const setEditingObject = useHeadstoneStore((s) => s.setEditingObject);
  const setSelectedInscriptionId = useHeadstoneStore((s) => s.setSelectedInscriptionId);
  const setSelectedAdditionId = useHeadstoneStore((s) => s.setSelectedAdditionId);
  const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);

  useFrame(() => {
    if (groupRef.current && currentRotation) {
      const diff = targetRotation - currentRotation.current;
      const delta = diff * 0.1;
      if (Math.abs(diff) > 0.001) {
        currentRotation.current += delta;
        groupRef.current.rotation.y = currentRotation.current;
      }
    }
  });

  const handleCanvasClick = (e: any) => {
    if (e.eventObject === e.object) {
      setSelected(null);
      setEditingObject('headstone');
      setSelectedInscriptionId(null);
      setSelectedAdditionId(null);
      setSelectedMotifId(null);
    }
  };

  return (
    <>
      {is2DMode && <color attach="background" args={['#CFE8FC']} />}
      {!is2DMode && <fog attach="fog" args={[FOG_COLOR, 60, 140]} />}
      
      <mesh position={[0, 0, 0]} rotation={[-Math.PI / 2, 0, 0]} onClick={handleCanvasClick}>
        <planeGeometry args={[200, 200]} />
        <meshBasicMaterial transparent opacity={0} side={THREE.DoubleSide} />
      </mesh>
      
      {!is2DMode && (
         <Sparkles count={30} scale={10} size={2} speed={0.4} opacity={0.3} color="#fff" position={[0, 2, 0]} />
      )}
      
      {/* --- LIGHTING IMPROVEMENTS --- */}
      <ambientLight intensity={0.4} color="#ffffff" />
      
      {/* Reduced Blue intensity in Hemisphere to stop tinting the grass */}
      <hemisphereLight args={['#ffffff', '#2d4c1e']} intensity={0.3} />
      
      {/* Main Sun - Crisp shadows */}
      <directionalLight 
        position={[-5, 10, 8]}
        intensity={2.0}
        castShadow
        shadow-mapSize={[2048, 2048]}
        shadow-bias={-0.0001}
      />

      {/* Rim light to separate stone from background */}
      <spotLight color="#ffffff" intensity={3} position={[5, 4, -5]} angle={0.5} distance={20} />

      {/* 
         Environment: "park" or "forest" works best for stone.
         blur={0.6} ensures reflections on the stone are realistic, not mirror-perfect.
      */}
      <Environment preset="forest" background={false} blur={0.6} />

      <group ref={groupRef}>
        <HeadstoneAssembly />
        <Suspense fallback={<SimpleGrassFloor />}>
          <GrassFloor />
        </Suspense>
      </group>
      
      {!is2DMode && <AtmosphericSky />}

      <OrbitControls
        makeDefault
        enabled={!baseSwapping}
        enableDamping={true}
        dampingFactor={0.05}
        enableRotate={!is2DMode}
        enableZoom={!is2DMode}
        enablePan={!is2DMode}
        minPolarAngle={Math.PI / 4} // Don't let user go too high
        maxPolarAngle={Math.PI / 2 - 0.02} // Don't let user go below ground
      />
    </>
  );
}
2. How to Fix the Headstone "Cardboard" Look

You didn't provide HeadstoneAssembly.tsx, but you must make these two changes in that file (or wherever the ExtrudeGeometry is created) to fix the thickness and material.

Step A: Increase Thickness (Geometry)

Find where you use ExtrudeGeometry or shape.extrude. Change depth (or amount in older Three versions) to 150mm.

code
Tsx
download
content_copy
expand_less
// Inside HeadstoneAssembly.tsx (or similar)

const extrudeSettings = {
  steps: 2,
  depth: 0.15, // <--- CHANGE THIS. 0.15 meters = 150mm (approx 6 inches). 
               // If you were using 0.01, that was only 1cm thick!
  bevelEnabled: true,
  bevelThickness: 0.01,
  bevelSize: 0.01,
  bevelSegments: 3
};
Step B: Premium Granite Material

Replace <meshStandardMaterial> with <meshPhysicalMaterial>. This adds the "Clearcoat" (polish) layer that makes granite look deep and premium.

code
Tsx
download
content_copy
expand_less
// Inside your Headstone Mesh

<mesh castShadow receiveShadow geometry={yourGeometry}>
  <meshPhysicalMaterial 
    color="#1a1a1a"          // Dark charcoal (never use pure #000000)
    roughness={0.2}          // The underlying stone texture
    metalness={0.1}          // Slight metalness for dark stone
    
    // THE MAGIC SAUCE FOR GRANITE:
    clearcoat={1.0}          // Adds a clear varnish layer
    clearcoatRoughness={0.1} // The varnish is perfectly smooth
    reflectivity={0.5}
    
    side={THREE.DoubleSide} 
  />
</mesh>