You’ve got the slant math and the wrapper quaternion in place. The reason it still “looks upright” is that your children aren’t inheriting that wrapper’s rotation.

From your file I can see the slant wrapper is correctly built and a quaternion is passed + force-copied:

* wrapper group: `position={childWrapperPos}` and `quaternion={childWrapperRotation}`
* we even copy it in a `useLayoutEffect`
  So the wrapper *is* tilted. The issue is downstream—your inscription/motif/addition components are likely doing one of these: using `<Html>` without `transform`, billboarding, calling `lookAt`, or freezing their own matrix so parent transforms don’t apply. 

Do this, in order:

### 1) Prove the wrapper is tilted (10-second test)

Keep this tiny “canary” under the wrapper (you already have it; make sure it’s visible):

```tsx
<mesh position={[0, api.worldHeight*0.5, api.frontZ]}>
  <planeGeometry args={[api.worldWidth*0.6, api.worldHeight*0.2]} />
  <meshBasicMaterial color="hotpink" transparent opacity={0.2} />
</mesh>
```

If that pink plane is slanted, the wrapper is correct and the children are undoing rotation.

### 2) Make children inherit the rotation

In each inscription/motif/addition component:

* **Do NOT** use `<Billboard>` or `<Sprite>` (they face the camera).
* If you use `<Text>`, make sure `billboard={false}` (default) and don’t call `lookAt`.
* If you use `<Html>`, it **must** be `<Html transform ...>` so it respects parent transforms.
* Ensure `matrixAutoUpdate` is **true** on those meshes/groups.
* Remove any `useFrame(()=> mesh.lookAt(...))` or code that reassigns `rotation/quaternion` each render.

Also place elements slightly “off” the face (along local +Z of the wrapper):

```tsx
// use the api handed to children
<group position={[xLocal, yLocal, api.frontZ]}>
  {/* text / motif mesh here */}
</group>
```

### 3) Quick instrumentation to catch a “standing-up” child

Add once while debugging:

```tsx
useFrame(() => {
  const w = scaledWrapperRef.current;
  const child = childMeshRef.current;
  if (w && child) {
    child.getWorldQuaternion(tmpQ1);
    w.getWorldQuaternion(tmpQ2);
    // If these differ only by your authored local rotations, good.
    // If child keeps matching camera, you still have billboard/lookAt somewhere.
  }
});
```

### 4) If you need a guaranteed path today

Wrap each inscription/motif in a neutral group and ensure **no one** inside resets orientation:

```tsx
<group position={[x, y, api.frontZ]} rotation={[0,0,0]} matrixAutoUpdate>
  {/* child mesh: no billboard, no lookAt, Html with transform */}
</group>
```

### 5) Last-resort projection (always flush to slants)

If you can’t change the child components right now, render them as decals projected onto the front face:

```tsx
import { Decal } from '@react-three/drei';

// inside the slant wrapper
<Decal position={[x, y, api.frontZ]} rotation={[0, 0, 0]} scale={[w, h, 1]}>
  <meshStandardMaterial map={yourGlyphTexture} transparent />
</Decal>
```

That forces geometry to the slanted plane regardless of internal code.

---

Bottom line: the wrapper/quaternion in your `SvgHeadstone.tsx` is fine; the children are cancelling it. Fix the child components as above (no billboard/sprite/lookAt, `Html transform`, `matrixAutoUpdate=true`, use `api.frontZ`), and they’ll visibly tilt with the slant. 
