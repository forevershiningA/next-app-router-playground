The issue is how the UV mapping (texture coordinates) is calculated for the sides.

In the current code:

U-coordinate: is calculated based on the perimeter position (nearestS).

V-coordinate: is calculated based on the Height (Y).

Because the "Sides" of the headstone span from the front face (Z positive) to the back face (Z negative), vertices at the same height (
ùëå
Y
) and position on the curve (
ùëã
X
) have identical texture coordinates, regardless of their depth (
ùëç
Z
).

This causes the texture pixel at the front edge to be stretched/smeared all the way to the back edge, creating those horizontal "speed lines" or streaks you see in the screenshot.

The Fix

For the side faces (the thickness of the stone), one of the texture axes needs to map to the Depth (Z), not the Height.

We need to change the mapping so that:

U (Axis 1): Wraps around the perimeter (keeps nearestS).

V (Axis 2): Maps across the thickness (zFront to zBack).

Here is the fixed code.

1. Update the Geometry Generation Logic

Look for the useMemo block where uvArr is generated (around line 324) and the scale variables are defined (around line 352).

Replace the relevant sections with this updated logic:

code
Tsx
download
content_copy
expand_less
// ... inside useMemo ...

    // Stats & Output
    const worldW = (maxX - minX) * Math.abs(scale) * sCore;
    const worldH = (bottomTarget_SV - minY) * Math.abs(scale) * sCore;
    const worldPerim = outline.total * Math.abs(scale) * sCore;
    const worldDepth = Math.abs(depth * scale);

    // Calculate texture scaling for sides (world units to UV units)
    const usePhysical = autoRepeat || tileSize != null || sideTileSize != null;
    const sideTile = sideTileSize ?? tileSize ?? 0.1;
    
    // FIX 1: Scaling
    // sideScaleU scales along the perimeter (Width + Height + Width...)
    const sideScaleU = usePhysical ? worldPerim / sideTile : (sideRepeatX ?? 8);
    // sideScaleV now scales along the Z-DEPTH, not height.
    const sideScaleV = usePhysical ? worldDepth / sideTile : (sideRepeatY ?? 1); 

    // Generate UVs
    for (let i = 0; i < pos.count; i += 3) {
      const z0 = pos.getZ(i), z1 = pos.getZ(i+1), z2 = pos.getZ(i+2);
      const isCap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol && Math.abs(z2 - zFront) <= zTol) || 
                    (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol && Math.abs(z2 - zBack) <= zTol);
      
      if (isCap) {
        // Face/Back Logic (unchanged)
        for (let j = 0; j < 3; j++) {
          const u = (pos.getX(i + j) - x0) / dxU;
          const v = (pos.getY(i + j) - y0) / dyU; 
          uvArr[2 * (i + j)] = u;
          uvArr[2 * (i + j) + 1] = v;
        }
      } else {
        // Side faces: use perimeter wrapping + Z-depth
        for (let j = 0; j < 3; j++) {
          const px = pos.getX(i + j);
          const py = pos.getY(i + j);
          const pz = pos.getZ(i + j);
          
          // Map 3D Y (0 to H) back to SVG Y for finding position on outline
          const originalSvgY = svgTotalHeight - py + minY;
          
          // U: Position around perimeter (0 to 1)
          const s = nearestS(px + centerX, originalSvgY, outline.pts, outline.cum, outline.total);
          
          // FIX 2: Map V to Z-Depth instead of Y-Height
          // This prevents the texture from streaking front-to-back
          const v = (pz - zBack) / (zFront - zBack);
          
          // Apply scaling immediately
          uvArr[2 * (i + j)] = s * sideScaleU;
          uvArr[2 * (i + j) + 1] = v * sideScaleV;
        }
      }
    }
    
    // Remove the separate re-scale loop since we applied it above
    merged.setAttribute('uv', new THREE.BufferAttribute(uvArr, 2));

    // ... remainder of useMemo ...
Summary of Changes

Mapping Change: inside the else (side face) block, changed v calculation from (py - y0) / dyU to (pz - zBack) / (zFront - zBack). This maps the texture across the thickness of the stone.

Scale Change: Changed sideScaleV to use worldDepth instead of worldH. This ensures that if you have tiling enabled, the texture tiles correctly based on the 10cm-20cm thickness, rather than stretching a 1 meter texture into that small space.

Optimization: I moved the scaling multiplication directly into the generation loop to save an iteration, though keeping it separate is also fine if you prefer the old structure.

This will result in the granite grain wrapping around the perimeter (U) and spanning cleanly across the thickness (V) without streaking.