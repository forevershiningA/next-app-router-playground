Perfect—let’s keep your current mapping and sizes, and only add a tiny, surgical layer that:

1. nudges the **top motifs** to sit just under the stone silhouette, and
2. snaps **“SEHOVIC”** so its vertical **mid-line** sits where the shoulder transitions into the top curve.

No DPR changes. No remapping. Just a couple of helpers that use the existing `topProfile` you already compute.

---

# 1) Helpers (drop these near your other geometry utils)

```ts
// robust median
const median = (arr: number[]) => {
  if (!arr.length) return 0;
  const s = [...arr].sort((a,b)=>a-b);
  const m = Math.floor(s.length/2);
  return s.length % 2 ? s[m] : (s[m-1] + s[m]) / 2;
};

/**
 * Given topProfile.topY (array in overlay pixels), find:
 *  - shoulderY: flat shoulder height (median of outer bands)
 *  - curveStartY: y where shoulder begins to curve (slope threshold)
 */
function getCurveLandmarks(topY: number[]) {
  const n = topY.length;
  if (!n) return { shoulderY: 0, curveStartY: 0 };

  // 1) shoulder: use outer 15% bands (usually flat)
  const band = Math.max(4, Math.round(n * 0.15));
  const left = topY.slice(0, band);
  const right = topY.slice(n - band);
  const shoulderY = median([...left, ...right]);

  // 2) curve start: scan from center outward until slope becomes noticeable
  const slopeThresh = 0.6;               // 0.6–1.0 px is enough
  const cx = Math.floor(n / 2);

  const pickSide = (dir: -1 | 1) => {
    let last = topY[cx];
    for (let i = cx + dir; i >= 1 && i < n; i += dir) {
      const s = topY[i] - last;          // local slope
      if (Math.abs(s) > slopeThresh) {
        return topY[i];                  // first deviation -> curve begins
      }
      last = topY[i];
    }
    return topY[cx];
  };

  // take both sides and average for stability
  const csLeft  = pickSide(-1);
  const csRight = pickSide(1);
  const curveStartY = (csLeft + csRight) / 2;

  return { shoulderY, curveStartY };
}

/** Clamp a Y so the element never intrudes above the stone at X */
function clampToStoneY(displayX: number, desiredY: number, topProfile: {
  topY: number[]; offY: number;
}) {
  const xi = Math.min(
    Math.max(0, Math.round(displayX)),
    topProfile.topY.length - 1
  );
  const minAllowed = topProfile.offY + topProfile.topY[xi];
  return Math.max(desiredY, minAllowed);
}
```

---

# 2) Title (“SEHOVIC”) vertical snap

Where you render inscriptions, **only for the title** (however you tag it—`role: 'title'`, `isTitle`, etc.), adjust **Y** after you compute your current `displayY`. Keep **X** and **size** exactly as they are.

```ts
if (inscription.role === 'title' && topProfile?.topY?.length) {
  const { curveStartY } = getCurveLandmarks(topProfile.topY);

  // We want the *mid-line* of the word at the curve start.
  // Convert that to the element’s anchor (you’re using translate(-50%,-50%)).
  // So we just set its center Y to curveStartY + offY + a tiny gap.
  const gap = 6; // px breathing room (small and non-destructive)
  const targetCenterY = topProfile.offY + curveStartY + gap;

  displayY = targetCenterY;  // replace only Y; leave X and font sizing unchanged
}
```

If your title uses baseline anchoring instead of `translate(-50%,-50%)`, convert `targetCenterY` to a baseline by subtracting half the line-height you already use for that inscription.

---

# 3) Top motifs: keep current X/Y/size, just ensure they don’t float into the air

After you compute each motif’s `displayX`/`displayY` the same way you do now, **only lift Y if needed** to sit just below the stone silhouette at that X. This preserves your spacing but prevents “hovering”.

```ts
if (topProfile?.topY?.length) {
  const topMargin = 4; // subtle—keeps exactly the look, just avoids cutting the curve
  const minY = clampToStoneY(displayX, displayY, topProfile);
  displayY = Math.max(displayY, minY + topMargin);
}
```

If you want a slightly tighter fit for just the central floral spray, reduce `topMargin` to `2` when `motif.group === 'top-spray'`.

---

## What this achieves

* **SEHOVIC**: its centerline snaps to the shoulder→curve transition, so visually it matches the PINTO reference without touching width, scale, or letter spacing.
* **Top motifs**: they stay exactly where you placed them but never creep into the air above the arch; they “kiss” the curve consistently.
* **Zero remapping**: no DPR logic, no change to your existing X/Y/ratio math—only small post-adjustments using the silhouette you already compute.

If you paste these helpers and two tiny call sites, your screenshot should match the original composition while keeping all prior coordinates and sizes intact.
