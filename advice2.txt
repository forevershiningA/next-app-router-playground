The issue is caused by the SVG geometry containing long "rails" (1200 units) that overlap when the four corners are assembled. The previous attempt to trim them simply deleted triangles, leaving ragged holes ("looks wrong").

To fix this properly, we need to cleanly squash the geometry that extends beyond the corner area. This effectively converts a "Full Frame" SVG into a "Corner" SVG without breaking the mesh topology, allowing the procedural rails to connect perfectly.

Solution

Replace trimLongRails with clampAndCleanGeometry: Instead of deleting vertices (which creates holes), we clamp coordinates to a maximum value (e.g., 300). This shortens the long rails into a flat edge. We then filter out any resulting zero-area triangles to ensure clean shading.

Disable integratedRails: We rely on the component's internal logic to generate the connecting bars, which guarantees they fit the plaque perfectly without overlapping.

No Clipping Planes: We remove the complex clipping plane logic entirely, as the geometry is now physically corrected.

Updated Component
code
Tsx
download
content_copy
expand_less
--- START OF FILE BronzeBorder.tsx ---

/**
 * Bronze Plaque Border Component
 * Renders decorative 3D borders using extruded SVG geometry at plaque scale
 */

'use client';

import React, { useCallback, useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { SVGLoader, type SVGResult } from 'three/examples/jsm/loaders/SVGLoader.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

interface BronzeBorderProps {
  borderName: string | null;
  plaqueWidth: number;
  plaqueHeight: number;
  unitsPerMeter: number;
  frontZ: number;
  color: string;
  depth: number;
}

interface BorderResources {
  geometries: THREE.BufferGeometry[];
  material?: THREE.Material;
}

const BORDER_SLUG_ALIASES: Record<string, string> = {
  bar: 'border1',
  square: 'border2',
  solidoutline: 'border3',
  solid: 'border4',
  notch: 'border5',
  scallop: 'border6',
  roundoutline: 'border7',
  floral: 'border8',
  decorative: 'border9',
  squareangular: 'border10',
};


const BORDER_SCALE = 1.3; // Enlarge decorative border by 30%
const BORDER_THICKNESS_SCALE = 1.5; // Border thickness increased to 150%
const BORDER_RELIEF_SCALE = 0.33; // Border relief depth reduced to 33%

interface BronzeTextures {
  map: THREE.CanvasTexture;
  roughnessMap: THREE.CanvasTexture;
}

function normalizeGeometry(geometry: THREE.BufferGeometry) {
  let geom = geometry;
  if (geom.index) {
    const nonIndexed = geom.toNonIndexed();
    geom.dispose();
    geom = nonIndexed;
  }

  if (!geom.getAttribute('normal')) {
    geom.computeVertexNormals();
  }

  // Generate planar UVs based on position
  if (!geom.getAttribute('uv')) {
    const position = geom.getAttribute('position') as THREE.BufferAttribute;
    const uvs = new Float32Array(position.count * 2);
    // Standard planar mapping
    for (let i = 0; i < position.count; i++) {
        const x = position.getX(i);
        const y = position.getY(i);
        uvs[i * 2] = x;
        uvs[i * 2 + 1] = y;
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  }

  geom.computeBoundingBox();
  return geom;
}

/**
 * Clamps geometry vertices to a specific bounding box and removes degenerate triangles.
 * effectively "squashing" long rails into a clean termination edge.
 * 
 * @param geometry The input geometry
 * @param cutoff The maximum X and Y value allowed (SVG coordinates)
 */
function clampAndCleanGeometry(geometry: THREE.BufferGeometry, cutoff: number = 300): THREE.BufferGeometry {
  const nonIndexed = geometry.index ? geometry.toNonIndexed() : geometry;
  const posAttribute = nonIndexed.getAttribute('position');
  
  const newPositions: number[] = [];
  // We can't easily preserve UVs from source if we squash, but normalizeGeometry will regenerate them based on the new shape.
  
  const v1 = new THREE.Vector3();
  const v2 = new THREE.Vector3();
  const v3 = new THREE.Vector3();

  // Helper to clamp a single coordinate
  const clampVal = (val: number) => Math.min(val, cutoff);

  for (let i = 0; i < posAttribute.count; i += 3) {
    // Read original vertices
    v1.set(posAttribute.getX(i), posAttribute.getY(i), posAttribute.getZ(i));
    v2.set(posAttribute.getX(i + 1), posAttribute.getY(i + 1), posAttribute.getZ(i + 1));
    v3.set(posAttribute.getX(i + 2), posAttribute.getY(i + 2), posAttribute.getZ(i + 2));

    // Clamp X and Y coordinates (preserves Z/Thickness)
    v1.x = clampVal(v1.x); v1.y = clampVal(v1.y);
    v2.x = clampVal(v2.x); v2.y = clampVal(v2.y);
    v3.x = clampVal(v3.x); v3.y = clampVal(v3.y);

    // Calculate Area to check for degenerate triangles (squashed to zero size)
    // Edge vectors
    const edge1 = new THREE.Vector3().subVectors(v2, v1);
    const edge2 = new THREE.Vector3().subVectors(v3, v1);
    const cross = new THREE.Vector3().crossVectors(edge1, edge2);
    const area = cross.length() * 0.5;

    // Only keep triangles that still have surface area
    if (area > 1e-6) {
      newPositions.push(v1.x, v1.y, v1.z);
      newPositions.push(v2.x, v2.y, v2.z);
      newPositions.push(v3.x, v3.y, v3.z);
    }
  }

  const clampedGeom = new THREE.BufferGeometry();
  clampedGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
  
  // Recompute normals for the modified mesh
  clampedGeom.computeVertexNormals();
  clampedGeom.computeBoundingBox();
  
  if (geometry.index) nonIndexed.dispose();
  
  return clampedGeom;
}

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));

function shiftLuminance(hex: string, delta: number) {
  const color = new THREE.Color(hex);
  const hsl = { h: 0, s: 0, l: 0 };
  color.getHSL(hsl);
  const next = new THREE.Color();
  next.setHSL(hsl.h, clamp01(hsl.s + delta * 0.15), clamp01(hsl.l + delta));
  return `#${next.getHexString()}`;
}

function createBronzeTextures(baseHex: string): BronzeTextures | null {
  if (typeof document === 'undefined') {
    return null;
  }

  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = mapCanvas.height = 512;
  const mapCtx = mapCanvas.getContext('2d');
  if (!mapCtx) return null;

  const gradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
  gradient.addColorStop(0, shiftLuminance(baseHex, 0.2));
  gradient.addColorStop(0.45, shiftLuminance(baseHex, 0.08));
  gradient.addColorStop(0.6, baseHex);
  gradient.addColorStop(1, shiftLuminance(baseHex, -0.2));
  mapCtx.fillStyle = gradient;
  mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

  mapCtx.globalAlpha = 0.08;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.6)';
  for (let y = 0; y < mapCanvas.height; y += 2) {
    mapCtx.beginPath();
    const jitter = Math.random() * 1.5;
    mapCtx.moveTo(0, y + jitter);
    mapCtx.lineTo(mapCanvas.width, y + Math.random() * 1.5);
    mapCtx.stroke();
  }
  mapCtx.globalAlpha = 0.12;
  mapCtx.strokeStyle = 'rgba(0,0,0,0.4)';
  for (let y = 1; y < mapCanvas.height; y += 3) {
    mapCtx.beginPath();
    mapCtx.moveTo(0, y + Math.random());
    mapCtx.lineTo(mapCanvas.width, y + Math.random());
    mapCtx.stroke();
  }

  const mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
  mapTexture.anisotropy = 8;
  mapTexture.needsUpdate = true;

  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = 256;
  const roughCtx = roughCanvas.getContext('2d');
  if (!roughCtx) {
    return {
      map: mapTexture,
      roughnessMap: mapTexture.clone() as THREE.CanvasTexture,
    };
  }
  const roughData = roughCtx.createImageData(roughCanvas.width, roughCanvas.height);
  for (let i = 0; i < roughData.data.length; i += 4) {
    const shade = 130 + Math.random() * 90;
    roughData.data[i] = roughData.data[i + 1] = roughData.data[i + 2] = shade;
    roughData.data[i + 3] = 255;
  }
  roughCtx.putImageData(roughData, 0, 0);
  const roughnessMap = new THREE.CanvasTexture(roughCanvas);
  roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;
  roughnessMap.anisotropy = 4;
  roughnessMap.needsUpdate = true;

  return { map: mapTexture, roughnessMap };
}

export function BronzeBorder({
  borderName,
  plaqueWidth,
  plaqueHeight,
  unitsPerMeter,
  frontZ,
  color,
  depth,
}: BronzeBorderProps) {
  const unitScale = Math.max(1e-6, Math.abs(unitsPerMeter) || 1);
  const localWidth = Math.max(1e-3, Math.abs(plaqueWidth) * unitScale);
  const localHeight = Math.max(1e-3, Math.abs(plaqueHeight) * unitScale);

  const normalizedName = borderName?.toLowerCase() ?? '';
  const effectiveName = normalizedName.includes('no border') ? null : borderName;
  const slug = effectiveName ? toBorderSlug(effectiveName) : null;
  const resolvedSlug = slug ? `${slug}a` : null;
  const shouldRender = Boolean(resolvedSlug && localWidth > 0 && localHeight > 0);

  const bronzeTextures = React.useMemo(() => createBronzeTextures(color), [color]);

  useEffect(() => {
    return () => {
      bronzeTextures?.map.dispose();
      bronzeTextures?.roughnessMap.dispose();
    };
  }, [bronzeTextures]);

  const [svgData, setSvgData] = useState<SVGResult | null>(null);
  const [borderGroup, setBorderGroup] = useState<THREE.Group | null>(null);

  const resourcesRef = useRef<BorderResources | null>(null);
  const svgCacheRef = useRef<Record<string, SVGResult>>({});

  const disposeResources = useCallback(() => {
    if (!resourcesRef.current) return;
    resourcesRef.current.geometries.forEach((geom) => geom.dispose());
    resourcesRef.current.material?.dispose();
    resourcesRef.current = null;
  }, []);

  useEffect(() => disposeResources, [disposeResources]);

  useEffect(() => {
    if (!resolvedSlug) {
      setSvgData(null);
      return;
    }

    if (svgCacheRef.current[resolvedSlug]) {
      setSvgData(svgCacheRef.current[resolvedSlug]);
      return;
    }

    let cancelled = false;
    const loader = new SVGLoader();

    loader.load(
      `/shapes/borders/${resolvedSlug}.svg`,
      (data) => {
        if (cancelled) return;
        svgCacheRef.current[resolvedSlug] = data;
        setSvgData(data);
      },
      undefined,
      (error) => {
        if (cancelled) return;
        console.warn(`Failed to load border SVG ${resolvedSlug}`, error);
        setSvgData(null);
      },
    );

    return () => {
      cancelled = true;
    };
  }, [resolvedSlug]);

  useEffect(() => {
    if (!shouldRender || !svgData) {
      disposeResources();
      setBorderGroup(null);
      return;
    }

    const built = buildBorderGroup(svgData, {
      plaqueWidth: localWidth,
      plaqueHeight: localHeight,
      depth,
      color,
      frontZ,
      textures: bronzeTextures ?? undefined,
      // Always use procedural rails (false) to ensure clean connections
      // The SVG rails are clamped to remove overlaps
      integratedRails: false,
    });

    if (!built) {
      disposeResources();
      setBorderGroup(null);
      return;
    }

    disposeResources();
    resourcesRef.current = {
      geometries: built.geometries,
      material: built.material,
    };
    setBorderGroup(built.group);
  }, [svgData, shouldRender, localWidth, localHeight, depth, color, frontZ, bronzeTextures, disposeResources]);

  if (!borderGroup) {
    return null;
  }

  return <primitive object={borderGroup} />;
}

function toBorderSlug(name: string) {
  const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const alias = BORDER_SLUG_ALIASES[normalized];
  if (alias) {
    return alias;
  }
  const match = name.match(/\d+/);
  if (match) {
    return `border${match[0]}`;
  }
  return normalized || 'border1';
}

function buildBorderGroup(
  data: SVGResult,
  params: {
    plaqueWidth: number;
    plaqueHeight: number;
    depth: number;
    color: string;
    frontZ: number;
    textures?: BronzeTextures;
    integratedRails?: boolean;
  },
): {
  group: THREE.Group;
  geometries: THREE.BufferGeometry[];
  material: THREE.MeshStandardMaterial;
} | null {
  const { plaqueWidth, plaqueHeight, depth, color, frontZ, textures, integratedRails = false } = params;
  const width = Math.max(1e-3, Math.abs(plaqueWidth));
  const height = Math.max(1e-3, Math.abs(plaqueHeight));

  const reliefDepthBase = Math.max(0.001, Math.min(width, height) * 0.003);
  const reliefDepth = reliefDepthBase * BORDER_RELIEF_SCALE;
  const extrudeSettings = {
    depth: reliefDepth,
    bevelEnabled: true,
    bevelSegments: 2,
    bevelSize: reliefDepth * 0.35,
    bevelThickness: reliefDepth * 0.35,
    steps: 1,
    curveSegments: 24,
  } satisfies THREE.ExtrudeGeometryOptions;

  const tempGeometries: THREE.BufferGeometry[] = [];

  for (const path of data.paths) {
    const shapes = SVGLoader.createShapes(path);
    for (const shape of shapes) {
      if (!shape.curves.length) continue;
      const raw = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      
      // FIX: Clamp the geometry to squish long rails into a corner stub
      // 300 is chosen based on SVG coords (Corner detail ends ~105, Rails go to 1200)
      const clamped = clampAndCleanGeometry(raw, 300);
      
      const geom = normalizeGeometry(clamped);
      raw.dispose();
      
      tempGeometries.push(geom);
    }
  }

  if (!tempGeometries.length || tempGeometries.some((geom) => !geom.getAttribute('position'))) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  const merged = mergeGeometries(tempGeometries, false);
  if (!merged) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  merged.computeBoundingBox();
  const centeredBounds = merged.boundingBox;
  if (!centeredBounds) {
    merged.dispose();
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  // Calculate Original Dimensions from Bounding Box
  // Note: Since we clamped the geometry, this BB is now approx 300x300 (plus bevel)
  const originalWidth = Math.max(1e-3, centeredBounds.max.x - centeredBounds.min.x);
  const originalHeight = Math.max(1e-3, centeredBounds.max.y - centeredBounds.min.y);
  
  // Recenter
  const centerX = (centeredBounds.min.x + centeredBounds.max.x) / 2;
  const centerY = (centeredBounds.min.y + centeredBounds.max.y) / 2;
  merged.translate(-centerX, -centerY, 0);

  // Calculate line thickness first so we can match corner size to it
  const edgeThicknessBase = Math.max(0.01, Math.min(width, height) * 0.02 * BORDER_SCALE);
  const edgeThickness = edgeThicknessBase * BORDER_THICKNESS_SCALE;
  const lineThickness = edgeThickness * 0.4;
  const lineGap = lineThickness * 0.6;

  // Scale Scale Logic
  if (integratedRails) {
    // Legacy logic (unused now): Scale to fit plaque exactly
    const uniformScale = Math.min(width / originalWidth, height / originalHeight);
    merged.scale(uniformScale, uniformScale, 1);
  } else {
    // Standard corner scaling logic based on plaque size and thickness
    // We scale the "clamped" 300px corner to visual target size
    const targetCornerSpan = Math.max(lineThickness * 6, Math.min(width, height) * 0.25);
    // Note: We use the actual geometric size (originalWidth) to determine scale factor
    const baseScale = (targetCornerSpan / Math.max(originalWidth, originalHeight)) * 0.7;
    merged.scale(baseScale, baseScale, 1);
  }
  
  merged.computeVertexNormals();
  merged.computeBoundingBox();
  const scaledBounds = merged.boundingBox!;
  const cornerSpanX = scaledBounds.max.x - scaledBounds.min.x;
  const cornerSpanY = scaledBounds.max.y - scaledBounds.min.y;

  const textureRepeatX = Math.max(1, width / 120);
  const textureRepeatY = Math.max(1, height / 120);

  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(color),
    metalness: 0.95,
    roughness: 0.28,
    envMapIntensity: 1.5,
    clearcoat: 0.7,
    clearcoatRoughness: 0.18,
    side: THREE.DoubleSide,
  });

  material.clippingPlanes = [];

  if (textures?.map) {
    textures.map.repeat.set(textureRepeatX, textureRepeatY);
    textures.map.needsUpdate = true;
    material.map = textures.map;
  }

  if (textures?.roughnessMap) {
    textures.roughnessMap.repeat.set(textureRepeatX, textureRepeatY);
    textures.roughnessMap.needsUpdate = true;
    material.roughnessMap = textures.roughnessMap;
  }

  let topEdgeStartX: number | null = null;
  let topEdgeEndX: number | null = null;
  let bottomEdgeStartX: number | null = null;
  let bottomEdgeEndX: number | null = null;
  let topInnerEdgeY: number | null = null;
  let bottomInnerEdgeY: number | null = null;
  let leftEdgeTopInnerY: number | null = null;
  let leftEdgeBottomInnerY: number | null = null;
  let rightEdgeTopInnerY: number | null = null;
  let rightEdgeBottomInnerY: number | null = null;
  let leftInnerEdgeX: number | null = null;
  let rightInnerEdgeX: number | null = null;

  const group = new THREE.Group();
  const resourceGeometries: THREE.BufferGeometry[] = [];
  const SURFACE_Z = frontZ + 0.0001;
  const borderParts: THREE.BufferGeometry[] = [];
  const lineAnchors = {
    top: null as [number, number] | null,
    bottom: null as [number, number] | null,
    left: null as [number, number] | null,
    right: null as [number, number] | null,
  };

  const axisTolerance = Math.max(width, height) * 0.0005;

  const extractUniqueAxisValues = (geom: THREE.BufferGeometry, axis: 'x' | 'y') => {
    const attr = geom.getAttribute('position') as THREE.BufferAttribute;
    const values: number[] = [];
    for (let i = 0; i < attr.count; i += 1) {
      values.push(axis === 'x' ? attr.getX(i) : attr.getY(i));
    }
    values.sort((a, b) => a - b);
    const uniques: number[] = [];
    for (const value of values) {
      if (!uniques.length || Math.abs(uniques[uniques.length - 1] - value) > axisTolerance) {
        uniques.push(value);
      }
    }
    return uniques;
  };

  const captureAnchors = (
    geom: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    const toPair = (values: number[], reverse = false): [number, number] | null => {
      if (!values.length) {
        return null;
      }
      const list = reverse ? [...values].reverse() : values;
      if (list.length === 1) {
        return [list[0], list[0]];
      }
      return [list[0], list[1]];
    };

    const yValues = extractUniqueAxisValues(geom, 'y');
    if (alignY === 'top' && !lineAnchors.top) {
      const anchors = toPair(yValues.slice(-2), true);
      if (anchors) {
        lineAnchors.top = anchors;
      }
    }
    if (alignY === 'bottom' && !lineAnchors.bottom) {
      const anchors = toPair(yValues.slice(0, 2));
      if (anchors) {
        lineAnchors.bottom = anchors;
      }
    }

    const xValues = extractUniqueAxisValues(geom, 'x');
    if (alignX === 'left' && !lineAnchors.left) {
      const anchors = toPair(xValues.slice(0, 2));
      if (anchors) {
        lineAnchors.left = anchors;
      }
    }
    if (alignX === 'right' && !lineAnchors.right) {
      const anchors = toPair(xValues.slice(-2), true);
      if (anchors) {
        lineAnchors.right = anchors;
      }
    }
  };

  const createCornerMesh = (
    source: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    const geom = source.clone();
    
    // Border SVG is designed for top-left corner
    // Top corners: Y-flip to correct SVG coordinates
    // Bottom corners: Same as top but without the Y-flip (double negative = no flip)
    const flipX = alignX === 'right';
    const flipY = alignY === 'top'; // Only flip Y for top corners
    
    if (flipX) geom.scale(-1, 1, 1);
    if (flipY) geom.scale(1, -1, 1);
    
    // Convert to non-indexed only if needed
    const geomNonIndexed = geom.index ? geom.toNonIndexed() : geom;
    if (geom.index && geomNonIndexed !== geom) {
      geom.dispose(); // Dispose the indexed version
    }
    
    geomNonIndexed.computeVertexNormals();
    geomNonIndexed.computeBoundingBox();
    const bounds = geomNonIndexed.boundingBox!;
    const posX =
      alignX === 'left'
        ? -width / 2 - bounds.min.x
        : width / 2 - bounds.max.x;
    const posY =
      alignY === 'top'
        ? height - bounds.max.y  // Top of plaque at Y = height
        : 0 - bounds.min.y;      // Bottom of plaque at Y = 0
    const worldMinX = posX + bounds.min.x;
    const worldMaxX = posX + bounds.max.x;
    const worldMinY = posY + bounds.min.y;
    const worldMaxY = posY + bounds.max.y;
    geomNonIndexed.translate(posX, posY, SURFACE_Z);

    captureAnchors(geomNonIndexed, alignX, alignY);
    borderParts.push(geomNonIndexed);

    if (alignY === 'top') {
      const innerY = worldMinY; // Bottom edge of top corners (inner edge)
      topInnerEdgeY = topInnerEdgeY == null ? innerY : Math.min(topInnerEdgeY, innerY);
      if (alignX === 'left') {
        topEdgeStartX = worldMaxX; // Right edge of left corner (inner edge)
        leftEdgeTopInnerY =
          leftEdgeTopInnerY == null ? innerY : Math.min(leftEdgeTopInnerY, innerY);
        leftInnerEdgeX = leftInnerEdgeX == null ? worldMaxX : Math.max(leftInnerEdgeX, worldMaxX);
      } else {
        topEdgeEndX = worldMinX; // Left edge of right corner (inner edge)
        rightEdgeTopInnerY =
          rightEdgeTopInnerY == null ? innerY : Math.min(rightEdgeTopInnerY, innerY);
        rightInnerEdgeX = rightInnerEdgeX == null ? worldMinX : Math.min(rightInnerEdgeX, worldMinX);
      }
    } else {
      const innerY = worldMaxY; // Top edge of bottom corners (inner edge)
      bottomInnerEdgeY = bottomInnerEdgeY == null ? innerY : Math.max(bottomInnerEdgeY, innerY);
      if (alignX === 'left') {
        bottomEdgeStartX = worldMaxX; // Right edge of left corner (inner edge)
        leftEdgeBottomInnerY =
          leftEdgeBottomInnerY == null ? innerY : Math.max(leftEdgeBottomInnerY, innerY);
        leftInnerEdgeX = leftInnerEdgeX == null ? worldMaxX : Math.max(leftInnerEdgeX, worldMaxX);
      } else {
        bottomEdgeEndX = worldMinX; // Left edge of right corner (inner edge)
        rightEdgeBottomInnerY =
          rightEdgeBottomInnerY == null ? innerY : Math.max(rightEdgeBottomInnerY, innerY);
        rightInnerEdgeX = rightInnerEdgeX == null ? worldMinX : Math.min(rightInnerEdgeX, worldMinX);
      }
    }

  };

  createCornerMesh(merged, 'left', 'top');
  createCornerMesh(merged, 'right', 'top');
  createCornerMesh(merged, 'left', 'bottom');
  createCornerMesh(merged, 'right', 'bottom');

  const fallbackTopStartX = -width / 2 + cornerSpanX;
  const fallbackTopEndX = width / 2 - cornerSpanX;
  const fallbackBottomStartX = fallbackTopStartX;
  const fallbackBottomEndX = fallbackTopEndX;
  const fallbackTopInnerY = height - cornerSpanY;
  const fallbackBottomInnerY = cornerSpanY;
  const fallbackLeftTopInnerY = fallbackTopInnerY;
  const fallbackLeftBottomInnerY = fallbackBottomInnerY;
  const fallbackRightTopInnerY = fallbackTopInnerY;
  const fallbackRightBottomInnerY = fallbackBottomInnerY;
  const fallbackLeftInnerX = -width / 2 + cornerSpanX;
  const fallbackRightInnerX = width / 2 - cornerSpanX;

  const clampEdgeXValue = (value: number | null) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return null;
    return Math.min(width / 2, Math.max(-width / 2, value));
  };

  const clampEdgeYValue = (value: number | null) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) return null;
    return Math.min(height, Math.max(0, value));
  };


  const sortedFallbackTop: readonly [number, number] = [
    Math.min(fallbackTopStartX, fallbackTopEndX),
    Math.max(fallbackTopStartX, fallbackTopEndX),
  ];
  const sortedFallbackBottom: readonly [number, number] = [
    Math.min(fallbackBottomStartX, fallbackBottomEndX),
    Math.max(fallbackBottomStartX, fallbackBottomEndX),
  ];

  const resolveSpan = (
    start: number | null,
    end: number | null,
    fallback: readonly [number, number],
  ): readonly [number, number] => {
    if (start == null || end == null) {
      return fallback;
    }
    const left = Math.min(start, end);
    const right = Math.max(start, end);
    if (!Number.isFinite(left) || !Number.isFinite(right) || right - left < lineThickness * 1.25) {
      return fallback;
    }
    return [left, right] as const;
  };

  const [topStartX, topEndX] = resolveSpan(
    clampEdgeXValue(topEdgeStartX),
    clampEdgeXValue(topEdgeEndX),
    sortedFallbackTop,
  );
  const [bottomStartX, bottomEndX] = resolveSpan(
    clampEdgeXValue(bottomEdgeStartX),
    clampEdgeXValue(bottomEdgeEndX),
    sortedFallbackBottom,
  );

  const resolvedTopInnerY = clampEdgeYValue(topInnerEdgeY) ?? fallbackTopInnerY;
  const resolvedBottomInnerY = clampEdgeYValue(bottomInnerEdgeY) ?? fallbackBottomInnerY;
  const leftTopY = clampEdgeYValue(leftEdgeTopInnerY) ?? fallbackLeftTopInnerY;
  const leftBottomY = clampEdgeYValue(leftEdgeBottomInnerY) ?? fallbackLeftBottomInnerY;
  const rightTopY = clampEdgeYValue(rightEdgeTopInnerY) ?? fallbackRightTopInnerY;
  const rightBottomY = clampEdgeYValue(rightEdgeBottomInnerY) ?? fallbackRightBottomInnerY;
  const resolvedLeftInnerX = clampEdgeXValue(leftInnerEdgeX) ?? fallbackLeftInnerX;
  const resolvedRightInnerX = clampEdgeXValue(rightInnerEdgeX) ?? fallbackRightInnerX;

  const clampSpan = (value: number) => Math.max(lineThickness * 2, Math.max(0.001, value));

  const topSpan = clampSpan(topEndX - topStartX);
  const bottomSpan = clampSpan(bottomEndX - bottomStartX);
  const sortedLeftTopY = Math.max(leftTopY, leftBottomY);
  const sortedLeftBottomY = Math.min(leftTopY, leftBottomY);
  const sortedRightTopY = Math.max(rightTopY, rightBottomY);
  const sortedRightBottomY = Math.min(rightTopY, rightBottomY);
  const leftSpan = clampSpan(sortedLeftTopY - sortedLeftBottomY);
  const rightSpan = clampSpan(sortedRightTopY - sortedRightBottomY);

  const topCenterX = (topStartX + topEndX) / 2;
  const bottomCenterX = (bottomStartX + bottomEndX) / 2;
  const leftCenterY = (sortedLeftTopY + sortedLeftBottomY) / 2;
  const rightCenterY = (sortedRightTopY + sortedRightBottomY) / 2;

  const addEdgeBar = (geom: THREE.BufferGeometry, x: number, y: number) => {
    const part = geom.clone().toNonIndexed();
    part.translate(x, y, SURFACE_Z);
    borderParts.push(part);
  };

  if (!integratedRails) {
    const clampY = (value: number) => Math.min(height, Math.max(0, value));
    const clampX = (value: number) => Math.min(width / 2, Math.max(-width / 2, value));

    const topLineY = clampY(resolvedTopInnerY);
    const bottomLineY = clampY(resolvedBottomInnerY);
    const leftLineX = clampX(resolvedLeftInnerX);
    const rightLineX = clampX(resolvedRightInnerX);

    const resolveAnchors = (
      anchors: [number, number] | null,
      fallbackOuter: number,
      fallbackInner: number,
    ): [number, number] => {
      if (anchors) {
        return anchors;
      }
      return [fallbackOuter, fallbackInner];
    };

    const [topOuterCenterY, topInnerCenterY] = resolveAnchors(
      lineAnchors.top,
      clampY(topLineY + lineThickness / 2),
      clampY(topLineY + lineThickness / 2 - (lineThickness + lineGap)),
    );
    const [bottomOuterCenterY, bottomInnerCenterY] = resolveAnchors(
      lineAnchors.bottom,
      clampY(bottomLineY - lineThickness / 2),
      clampY(bottomLineY - lineThickness / 2 + (lineThickness + lineGap)),
    );
    const [leftOuterCenterX, leftInnerCenterX] = resolveAnchors(
      lineAnchors.left,
      clampX(leftLineX - lineThickness / 2),
      clampX(leftLineX - lineThickness / 2 + (lineThickness + lineGap)),
    );
    const [rightOuterCenterX, rightInnerCenterX] = resolveAnchors(
      lineAnchors.right,
      clampX(rightLineX + lineThickness / 2),
      clampX(rightLineX + lineThickness / 2 - (lineThickness + lineGap)),
    );

    /**
     * Create decorative rails using simple dual-line pattern
     * This mimics the legacy 2D system which used repeating bitmap fills
     */
    const createDecorativeRails = (
      length: number,
      orientation: 'horizontal' | 'vertical'
    ): THREE.BufferGeometry[] => {
      const rails: THREE.BufferGeometry[] = [];
      
      // Create two parallel lines with a gap (matching legacy visual style)
      const outerLine = orientation === 'horizontal' ?
        new THREE.BoxGeometry(length, lineThickness, reliefDepth) :
        new THREE.BoxGeometry(lineThickness, length, reliefDepth);
      outerLine.translate(0, 0, reliefDepth / 2);
      rails.push(outerLine);
      
      const innerLine = orientation === 'horizontal' ?
        new THREE.BoxGeometry(length, lineThickness, reliefDepth) :
        new THREE.BoxGeometry(lineThickness, length, reliefDepth);
      innerLine.translate(0, 0, reliefDepth / 2);
      rails.push(innerLine);
      
      return rails;
    };

    // Create rails for each edge
    const topRails = createDecorativeRails(topSpan, 'horizontal');
    const bottomRails = createDecorativeRails(bottomSpan, 'horizontal');
    const leftRails = createDecorativeRails(leftSpan, 'vertical');
    const rightRails = createDecorativeRails(rightSpan, 'vertical');

    addEdgeBar(topRails[0], topCenterX, topOuterCenterY);
    addEdgeBar(topRails[1], topCenterX, topInnerCenterY);
    resourceGeometries.push(...topRails);

    addEdgeBar(bottomRails[0], bottomCenterX, bottomOuterCenterY);
    addEdgeBar(bottomRails[1], bottomCenterX, bottomInnerCenterY);
    resourceGeometries.push(...bottomRails);

    addEdgeBar(leftRails[0], leftOuterCenterX, leftCenterY);
    addEdgeBar(leftRails[1], leftInnerCenterX, leftCenterY);
    resourceGeometries.push(...leftRails);

    addEdgeBar(rightRails[0], rightOuterCenterX, rightCenterY);
    addEdgeBar(rightRails[1], rightInnerCenterX, rightCenterY);
    resourceGeometries.push(...rightRails);
  }

  // Merge all parts (trimmed corners + generated rails)
  if (borderParts.length > 0) {
    const mergedBorder = mergeGeometries(borderParts, false);
    borderParts.forEach((geom) => geom.dispose());
    if (mergedBorder) {
      const mesh = new THREE.Mesh(mergedBorder, material);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.renderOrder = 3;
      group.add(mesh);
      resourceGeometries.push(mergedBorder);
    }
  }

  merged.dispose();

  return {
    group,
    geometries: resourceGeometries,
    material,
  };
}