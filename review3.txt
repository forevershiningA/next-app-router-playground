You’ve got a classic iPhone-DPR save: `init_width=414`, `init_height=660`, `dpr=3`, portrait.
What’s going wrong in your render is a mix of (a) per-axis stretch, (b) over-correcting X with `ratioHeight`, and (c) losing the original margins because the “tablet/headstone bitmap” is being fitted to the *display box* instead of the *authoring box* (414×660).

Below is a small, surgical fix that makes iPhone DPR=3 designs line up.

---

# 1) Compute one uniform “contain” scale from the authoring frame

Keep layout in CSS-pixels. DPR is only for undoing legacy saves and for backing-store sharpness.

```ts
// AUTHORING frame (CSS px) = where the user placed things
const initW = Number(item.init_width || this.design_data[0].init_width);   // 414
const initH = Number(item.init_height || this.design_data[0].init_height); // 660

// DISPLAY box (CSS px) = where you render now
const dispW = dyo.w;
const dispH = dyo.h;

// “Contain” so margins and aspect from the original are preserved.
const s = Math.min(dispW / initW, dispH / initH);
const offsetX = Math.round((dispW - initW * s) / 2);
const offsetY = Math.round((dispH - initH * s) / 2);

// Axis ratios if you need them elsewhere (but don’t stretch layout):
const ratioWidth  = s;
const ratioHeight = s;
```

> With this, the headstone bitmap/mask should also be rendered into the **authoring frame** `(offsetX, offsetY, initW*s, initH*s)` — not stretched independently to `dispW×dispH`. That alone fixes most of the “bad display”.

---

# 2) Normalize saved coordinates (DPR=3) and handle the old “x scaled by ratioHeight” bug once

Saved values from iPhone are in CSS px (authoring space). If some older saves multiplied both x and y by a `ratio_height`, undo it once; otherwise, do nothing. Don’t hard-divide X by `ratioHeight` globally — that causes the top motifs to bunch inward when `ratioWidth < ratioHeight`.

```ts
function isLegacyScaledXY(x:number, y:number, initW:number, initH:number) {
  // Heuristic: values larger than the authoring frame suggest pre-scaled saves
  return Math.max(Math.abs(x), Math.abs(y)) > Math.max(initW, initH) * 1.15;
}

function fromSavedToAuthoringXY(xSaved:number, ySaved:number, legacyScale:number, legacy:boolean) {
  if (!legacy) return { x: xSaved, y: ySaved };
  // Old bug used the same scale for both axes; undo it symmetrically
  return { x: xSaved / legacyScale, y: ySaved / legacyScale };
}
```

Apply per item:

```ts
// Detect once per design
const legacy = isLegacyScaledXY(firstItem.x, firstItem.y, initW, initH);
// If you previously computed a “ratioHeight at save time”, pass it here; otherwise use 1.
const legacyScaleAtSave = Number(this.design_data?.[0]?.legacy_scale) || 1;

const { x: ax, y: ay } = fromSavedToAuthoringXY(item.x, item.y, legacyScaleAtSave, legacy);

// Final display position in CSS px:
const xDisp = Math.round(offsetX + ax * s);
const yDisp = Math.round(offsetY + ay * s);
```

---

# 3) Fonts and motif sizes

Fonts: treat saved px as authoring-space px; then scale by the **uniform** `s` (or `ratioHeight` if you want to be explicit).

```ts
const savedPx = parseFloat(String(item.font).split("px")[0] || item.font_size);
const fontPxDisplay = savedPx * s;   // clean and device-independent
```

Motifs (SVG/bitmaps): compute their authoring-space width/height using the SVG’s natural aspect-ratio (or the saved w/h if you already store them), then scale with `s`.

```ts
// authoring space
const motifW = motif.width;    // or motif.height * svgAR
const motifH = motif.height;
// display space
const motifWDisp = motifW * s;
const motifHDisp = motifH * s;
```

> This ensures the three top motifs on the PINTO layout don’t collapse toward the center on tall displays.

---

# 4) Headstone bitmap/mask placement

On the iPhone save the headstone didn’t fill the whole 414×660; there were margins. If you currently size the marble texture “to the available box”, you erase those margins and all text looks too close to the curve.

Render the texture/mask **inside the authoring frame**:

```ts
// draw marble / mask into this rect so margins match the save
drawHeadstoneBitmap({
  x: offsetX,
  y: offsetY,
  width:  initW * s,
  height: initH * s
});
```

If you keep a precomputed crop rectangle from the save (e.g., you trimmed whitespace at save-time), subtract that crop in **authoring space** *before* scaling and then apply `(offsetX, offsetY)`.

---

# 5) One small guard for iPhone DPR=3

Some iOS 15/16 captures report 414×736 in the UA string but you saved `init_height=660`. That is fine — **trust `init_width/height` from the XML**, not the UA. Do not try to “correct” them to 736; that introduces a 10% vertical distortion.

---

## Minimal patch where you place items

Replace your position code with:

```ts
// 1) frame + scale
const initW = Number(this.design_data[0].init_width);
const initH = Number(this.design_data[0].init_height);
const dispW = dyo.w, dispH = dyo.h;
const s = Math.min(dispW / initW, dispH / initH);
const offsetX = Math.round((dispW - initW * s) / 2);
const offsetY = Math.round((dispH - initH * s) / 2);

// 2) legacy detection once per design
const legacy = isLegacyScaledXY(this.items[0].x, this.items[0].y, initW, initH);
const legacyScaleAtSave = Number(this.design_data?.[0]?.legacy_scale) || 1;

// 3) per item
const { x: ax, y: ay } = fromSavedToAuthoringXY(item.x, item.y, legacyScaleAtSave, legacy);
item.displayX = Math.round(offsetX + ax * s);
item.displayY = Math.round(offsetY + ay * s);
item.displayFontPx = parseFloat(pxFrom(item.font)) * s;
item.displayW = item.width  * s; // if motifs
item.displayH = item.height * s;
```

…and render the headstone bitmap into `(offsetX, offsetY, initW*s, initH*s)`.

---

### Why this fixes the shown example

* Keeps the original 414×660 authoring margins (your right/left spacing and the arc apex now match).
* Stops inward “pinching” on tall boxes (no `x / ratioHeight`).
* Makes DPR=3 irrelevant to layout (only sharpness), so iPhones render identically to desktops.
* Backward-compatible with older legacy saves through a single, explicit undo step.

If you share one of the saved JSON blobs for this iPhone design (title + two body text blocks + the heart motif), I’ll run the numbers and tell you the exact `s`, `(offsetX, offsetY)`, and whether the “legacy” flag triggers for that file.
