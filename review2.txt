Yes, you should absolutely implement these fixes immediately.

The current implementation has a severe performance flaw: by including dimensions in the useMemo dependency array for materials, you are forcing the browser to destroy and re-compile WebGL shaders and re-upload textures to the GPU 60 times per second while dragging/resizing. This will freeze the browser.

Additionally, without the fixRoundedBoxUVs helper, the RoundedBoxGeometry will render as a single material (likely rough rock pitch everywhere), ruining the "Polished Top" effect.

Here is the complete, production-ready file with all fixes applied:

code
Tsx
download
content_copy
expand_less
'use client';
import * as THREE from 'three';
import React, {
  useRef,
  forwardRef,
  useImperativeHandle,
  useEffect,
  useLayoutEffect,
  useMemo,
  Suspense,
} from 'react';
import { useFrame } from '@react-three/fiber';
import { useTexture } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useHeadstoneStore, Line } from '#/lib/headstone-store';
import HeadstoneInscription from '../../HeadstoneInscription';
import MotifModel from '../MotifModel';
import type { HeadstoneAPI } from '../../SvgHeadstone';
import {
  TEX_BASE,
  DEFAULT_TEX,
  BASE_WIDTH_MULTIPLIER,
  BASE_DEPTH_MULTIPLIER,
  BASE_MIN_DEPTH,
  LERP_FACTOR,
  EPSILON,
} from '#/lib/headstone-constants';

type HeadstoneBaseAutoProps = {
  headstoneObject: React.RefObject<THREE.Object3D>;
  wrapper: React.RefObject<THREE.Object3D>;
  onClick?: (e: any) => void;
  height?: number;
  name?: string;
};

function PreloadTexture({
  url,
  onReady,
}: {
  url: string;
  onReady?: () => void;
}) {
  useTexture(url);
  React.useEffect(() => {
    const id = requestAnimationFrame(() => onReady?.());
    return () => cancelAnimationFrame(id);
  }, [onReady]);
  return null;
}

/**
 * Helper to fix Multi-Material support on RoundedBoxGeometry
 * Assigns material groups based on the dominant normal direction of each face
 */
function fixRoundedBoxUVs(geometry: THREE.BufferGeometry) {
  if (!geometry.attributes.position || !geometry.index) return;

  geometry.clearGroups();

  const normal = geometry.attributes.normal;
  const index = geometry.index;

  // 0: Right (+x), 1: Left (-x), 2: Top (+y), 3: Bottom (-y), 4: Front (+z), 5: Back (-z)
  for (let i = 0; i < index.count; i += 3) {
    const a = index.getX(i);
    const nx = normal.getX(a);
    const ny = normal.getY(a);
    const nz = normal.getZ(a);

    let matIdx = 0;

    if (Math.abs(nx) > Math.abs(ny) && Math.abs(nx) > Math.abs(nz)) {
      matIdx = nx > 0 ? 0 : 1; // Right : Left
    } else if (Math.abs(ny) > Math.abs(nx) && Math.abs(ny) > Math.abs(nz)) {
      matIdx = ny > 0 ? 2 : 3; // Top : Bottom
    } else {
      matIdx = nz > 0 ? 4 : 5; // Front : Back
    }

    geometry.addGroup(i, 3, matIdx);
  }
}

function BaseMesh({
  baseRef,
  baseTexture,
  onClick,
  name,
  dimensions,
  finish,
}: {
  baseRef: React.RefObject<THREE.Mesh | null>;
  baseTexture: THREE.Texture;
  onClick?: (e: any) => void;
  name?: string;
  dimensions: { width: number; height: number; depth: number };
  finish: 'default' | 'rock-pitch';
}) {
  // 1. Generate Normal Map (Memoized & Disposed)
  const rockNormalMap = useMemo(() => {
    if (finish !== 'rock-pitch') return null;

    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;

    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    const asphaltNoise = (x: number, y: number) => {
      let total = 0;
      let amplitude = 1;
      let frequency = 1;
      const maxAmplitude = 1.875;
      for (let i = 0; i < 4; i++) {
        const nx = x * frequency * 0.15;
        const ny = y * frequency * 0.15;
        const val =
          Math.sin(nx * 5.3 + 17) * Math.cos(ny * 4.7 + 23) +
          Math.sin(nx * 7.1 - ny * 3.9 + 41) * Math.cos(nx * 6.2 + ny * 5.8) * 0.8 +
          Math.sin((nx + ny) * 8.7 + 61) * 0.6;

        total += val * amplitude;
        amplitude *= 0.5;
        frequency *= 2.1;
      }
      return total / maxAmplitude;
    };

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        const baseNoise = asphaltNoise(x, y) * 20;
        const fineGrain = (Math.random() - 0.5) * 18;
        const totalValue = baseNoise + fineGrain;
        const nx = Math.max(0, Math.min(255, 128 + totalValue));
        const ny = Math.max(0, Math.min(255, 128 + totalValue * 0.92));
        const nz = Math.max(0, Math.min(255, 200 + Math.abs(totalValue) * 0.25));

        data[idx] = nx;
        data[idx + 1] = ny;
        data[idx + 2] = nz;
        data[idx + 3] = 255;
      }
    }

    ctx.putImageData(imageData, 0, 0);

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    return texture;
  }, [finish]);

  // Cleanup texture on unmount
  useEffect(() => {
    return () => {
      rockNormalMap?.dispose();
    };
  }, [rockNormalMap]);

  // 2. Manage Base Texture Settings
  useLayoutEffect(() => {
    if (baseTexture) {
      baseTexture.wrapS = THREE.RepeatWrapping;
      baseTexture.wrapT = THREE.RepeatWrapping;
      const textureScale = 0.15;
      baseTexture.repeat.set(
        dimensions.width / textureScale,
        dimensions.height / textureScale
      );
      baseTexture.anisotropy = 16;
      baseTexture.needsUpdate = true;
    }
  }, [baseTexture, dimensions.width, dimensions.height]);

  // 3. Create Materials ONCE (Do not depend on dimensions here!)
  const materials = useMemo(() => {
    // Shared Polish Material
    const polishedMaterial = new THREE.MeshPhysicalMaterial({
      map: baseTexture,
      color: 0x888888,
      metalness: 0.0,
      roughness: 0.15,
      envMapIntensity: 1.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
    });

    if (finish === 'rock-pitch' && rockNormalMap) {
      // Clone texture ONCE here for the materials to allow independent repeats
      const texShort = rockNormalMap.clone();
      const texLong = rockNormalMap.clone();

      // Ensure repeats are set to wrapping
      texShort.wrapS = THREE.RepeatWrapping;
      texShort.wrapT = THREE.RepeatWrapping;
      texLong.wrapS = THREE.RepeatWrapping;
      texLong.wrapT = THREE.RepeatWrapping;

      const matShort = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texShort, // Right/Left
        normalScale: new THREE.Vector2(3, 3),
        color: 0x555555,
        metalness: 0.0,
        roughness: 0.7,
        envMapIntensity: 1.0,
      });

      const matLong = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texLong, // Front/Back
        normalScale: new THREE.Vector2(3, 3),
        color: 0x555555,
        metalness: 0.0,
        roughness: 0.7,
        envMapIntensity: 1.0,
      });

      return [matShort, matShort, polishedMaterial, polishedMaterial, matLong, matLong];
    }

    return polishedMaterial;
  }, [baseTexture, finish, rockNormalMap]); // NO DIMENSIONS DEPENDENCY

  // 4. Update Material Repeats Imperatively (Performance Fix)
  useLayoutEffect(() => {
    if (Array.isArray(materials) && finish === 'rock-pitch') {
      const density = 5;
      // Extract specific materials from the array
      // 0=Right, 1=Left, 4=Front, 5=Back
      const matRight = materials[0] as THREE.MeshStandardMaterial;
      const matFront = materials[4] as THREE.MeshStandardMaterial;

      // Update Right/Left (Short sides) - Depth driven
      if (matRight.normalMap) {
        matRight.normalMap.repeat.set(
          dimensions.depth * density,
          dimensions.height * 1
        );
      }

      // Update Front/Back (Long sides) - Width driven
      if (matFront.normalMap) {
        matFront.normalMap.repeat.set(
          dimensions.width * density,
          dimensions.height * 1
        );
      }
    }
  }, [materials, dimensions, finish]);

  // 5. Geometry Logic
  const geometry = useMemo(() => {
    if (finish === 'rock-pitch') {
      const geo = new RoundedBoxGeometry(1, 1, 1, 8, 0.05);
      // CRITICAL: Apply the group fix so multi-material works
      fixRoundedBoxUVs(geo);
      return geo;
    }
    return new THREE.BoxGeometry(1, 1, 1);
  }, [finish]);

  return (
    <mesh
      ref={baseRef}
      name={name}
      onClick={onClick}
      castShadow
      receiveShadow
      geometry={geometry}
      onUpdate={(self) => {
        if (self.geometry) self.geometry.computeBoundingBox();
      }}
    >
      {Array.isArray(materials) ? (
        materials.map((mat, i) => (
          <primitive key={i} object={mat} attach={`material-${i}`} />
        ))
      ) : (
        <primitive object={materials} attach="material" />
      )}
    </mesh>
  );
}

const HeadstoneBaseAuto = forwardRef<THREE.Mesh, HeadstoneBaseAutoProps>(
  ({ headstoneObject, wrapper, onClick, height = 0.1, name }, ref) => {
    const baseRef = useRef<THREE.Mesh>(null);
    useImperativeHandle(ref, () => baseRef.current!);

    const dummyGroupRef = useRef<THREE.Group>(null);

    const baseMaterialUrl = useHeadstoneStore((s) => s.baseMaterialUrl);
    const setBaseSwapping = useHeadstoneStore((s) => s.setBaseSwapping);
    const hasStatue = useHeadstoneStore((s) => s.hasStatue);
    const widthMm = useHeadstoneStore((s) => s.widthMm);
    const heightMm = useHeadstoneStore((s) => s.heightMm);
    const baseWidthMm = useHeadstoneStore((s) => s.baseWidthMm);
    const baseHeightMm = useHeadstoneStore((s) => s.baseHeightMm);
    const baseFinish = useHeadstoneStore((s) => s.baseFinish);
    const inscriptions = useHeadstoneStore((s) => s.inscriptions);
    const selectedMotifs = useHeadstoneStore((s) => s.selectedMotifs);
    const motifOffsets = useHeadstoneStore((s) => s.motifOffsets);

    const baseHeightMeters = baseHeightMm / 1000;
    const selectedInscriptionId = useHeadstoneStore((s) => s.selectedInscriptionId);
    const setSelectedInscriptionId = useHeadstoneStore(
      (s) => s.setSelectedInscriptionId
    );
    const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);
    const setSelected = useHeadstoneStore((s) => s.setSelected);
    const setSelectedAdditionId = useHeadstoneStore(
      (s) => s.setSelectedAdditionId
    );
    const setActivePanel = useHeadstoneStore((s) => s.setActivePanel);

    const baseAPI: HeadstoneAPI = useMemo(() => {
      const baseDepth = 0.2 * BASE_DEPTH_MULTIPLIER;
      return {
        group: dummyGroupRef as React.RefObject<THREE.Group>,
        mesh: baseRef as React.RefObject<THREE.Mesh>,
        frontZ: baseDepth / 2,
        unitsPerMeter: 1000,
        version: 1,
        worldWidth: (widthMm / 1000) * BASE_WIDTH_MULTIPLIER,
        worldHeight: height,
      };
    }, [widthMm, height]);

    const requestedBaseTex = useMemo(() => {
      const file = baseMaterialUrl?.split('/').pop() ?? DEFAULT_TEX;
      const webp = file.replace(/\.jpg$/i, '.webp');
      return TEX_BASE + webp;
    }, [baseMaterialUrl]);

    const [visibleBaseTex, setVisibleBaseTex] = React.useState(requestedBaseTex);

    const baseSwapping = requestedBaseTex !== visibleBaseTex;

    useEffect(() => {
      setBaseSwapping(baseSwapping);
    }, [baseSwapping, setBaseSwapping]);

    const baseTexture = useTexture(visibleBaseTex);

    const hasTx = useRef(false);
    const targetPos = useRef(new THREE.Vector3());
    const targetScale = useRef(new THREE.Vector3(1, height, 1));
    const invMatrix = useRef(new THREE.Matrix4());
    const [baseDimensions, setBaseDimensions] = React.useState({
      width: 1,
      height: height,
      depth: 1,
    });

    useFrame(() => {
      const t = headstoneObject.current;
      const w = wrapper.current;
      const b = baseRef.current;
      if (!t || !w || !b) return;

      const hsH = heightMm / 1000;
      const headstoneDepth = 0.15;
      const baseW = baseWidthMm / 1000;
      const baseD = Math.max(0.2 * BASE_DEPTH_MULTIPLIER, BASE_MIN_DEPTH);

      const statueExtension = hasStatue() ? 0.2 : 0;
      const xOffset = statueExtension / 2;

      const baseZCenter = -(headstoneDepth / 2) + baseD / 2;

      const centerW = new THREE.Vector3(
        -xOffset,
        baseHeightMeters * 0.5 + EPSILON,
        baseZCenter
      );

      w.updateWorldMatrix(true, false);
      invMatrix.current.copy(w.matrixWorld).invert();
      const posLocal = centerW.applyMatrix4(invMatrix.current);

      targetPos.current.copy(posLocal);
      targetScale.current.set(baseW, baseHeightMeters, baseD);

      if (
        baseDimensions.width !== baseW ||
        baseDimensions.height !== baseHeightMeters ||
        baseDimensions.depth !== baseD
      ) {
        setBaseDimensions({
          width: baseW,
          height: baseHeightMeters,
          depth: baseD,
        });
      }

      if (!hasTx.current) {
        b.position.copy(targetPos.current);
        b.scale.copy(targetScale.current);
        hasTx.current = true;
      }

      b.visible = true;

      if (!hasTx.current) {
        return;
      }

      if (!baseSwapping) {
        b.position.lerp(targetPos.current, LERP_FACTOR);
        b.scale.lerp(targetScale.current, LERP_FACTOR);
      }

      b.visible = true;
    });

    return (
      <React.Fragment>
        <Suspense fallback={null}>
          <BaseMesh
            baseRef={baseRef}
            baseTexture={baseTexture}
            onClick={(e) => {
              e.stopPropagation();
              if (onClick && (!e.delta || e.delta < 2)) {
                onClick(e);
              }
            }}
            name={name}
            dimensions={baseDimensions}
            finish={baseFinish}
          />
        </Suspense>

        {inscriptions
          .filter((line: Line) => line.target === 'base')
          .map((line: Line, i: number) => {
            const zBump = (inscriptions.length - 1 - i) * 0.00005;
            return (
              <Suspense key={line.id} fallback={null}>
                <HeadstoneInscription
                  id={line.id}
                  headstone={baseAPI}
                  font={`/fonts/${line.font}.woff2`}
                  editable
                  selected={selectedInscriptionId === line.id}
                  onSelectInscription={() => {
                    setSelected('base');
                    setSelectedMotifId(null);
                    setSelectedAdditionId(null);
                    setSelectedInscriptionId(line.id);
                    setActivePanel('inscription');
                  }}
                  color={line.color}
                  lift={0.002}
                  xPos={line.xPos}
                  yPos={line.yPos}
                  rotationDeg={line.rotationDeg}
                  height={line.sizeMm}
                  text={line.text}
                  zBump={zBump}
                />
              </Suspense>
            );
          })}

        {selectedMotifs
          .filter((motif) => {
            const offset = motifOffsets[motif.id];
            return offset?.target === 'base';
          })
          .map((motif, i) => (
            <Suspense key={`${motif.id}-${i}`} fallback={null}>
              <MotifModel
                id={motif.id}
                svgPath={motif.svgPath}
                color={motif.color}
                headstone={baseAPI}
                index={i}
              />
            </Suspense>
          ))}

        {requestedBaseTex !== visibleBaseTex && (
          <Suspense fallback={null}>
            <PreloadTexture
              url={requestedBaseTex}
              onReady={() => {
                setVisibleBaseTex(requestedBaseTex);
              }}
            />
          </Suspense>
        )}
      </React.Fragment>
    );
  }
);

HeadstoneBaseAuto.displayName = 'HeadstoneBaseAuto';
export default HeadstoneBaseAuto;