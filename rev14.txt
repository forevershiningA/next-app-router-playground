This iteration solves the coordinate inversion and placement issues by leveraging the Negative Group Scale technique.

Instead of fighting the coordinate system by flipping the geometry upright and then trying to flip the children back, we align everything with the SVG's natural coordinate system (Y-Down).

Group Scale: set to [scale, -scale, scale]. This makes +Y go "Down" visually, matching SVG coordinates perfectly. Moving "Left" (decreasing X) will naturally move Left.

Geometry: We manually Swap Vertices (Winding Order). This is crucial because a negative scale usually turns meshes "inside out" (black faces). By swapping vertices before rendering, the negative scale flips them back to "outside out", ensuring correct lighting.

Child Placement: Because the Group is now Y-Down, the children (Inscriptions/Motifs) don't need complex scaling. We simply offset the wrapper so that (0,0) aligns with the Top-Left of the stone.

code
Tsx
download
content_copy
expand_less
// components/SvgHeadstone.tsx
'use client';

import * as React from 'react';
import { useMemo, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';
import * as THREE from 'three';
import { useLoader } from '@react-three/fiber';
import type { ThreeElements } from '@react-three/fiber';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { Edges, useTexture } from '@react-three/drei';
import { Line } from '#/lib/headstone-store';

export type HeadstoneAPI = {
  group: React.RefObject<THREE.Group>;
  mesh: React.RefObject<THREE.Mesh>;
  frontZ: number;
  unitsPerMeter: number;
  version: number;
  worldWidth: number;
  worldHeight: number;
};

const EPS = 1e-9;

type Props = {
  url: string;
  depth: number;
  scale?: number;
  faceTexture: string;
  sideTexture?: string;
  autoRepeat?: boolean;
  tileSize?: number;
  sideTileSize?: number;
  topTileSize?: number;
  faceRepeatX?: number;
  faceRepeatY?: number;
  sideRepeatX?: number;
  sideRepeatY?: number;
  targetHeight?: number;
  targetWidth?: number;
  preserveTop?: boolean;
  bevel?: boolean;
  doubleSided?: boolean;
  showEdges?: boolean;
  meshProps?: ThreeElements['mesh'];
  children?: (api: HeadstoneAPI, selectedAdditions: string[]) => React.ReactNode;
  inscriptions: Line[];
  selectedAdditions?: string[];
};

/* ---------------- helpers ---------------- */

function shapeBounds(shape: THREE.Shape) {
  const pts = shape.getPoints(256);
  let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
  for (const p of pts) {
    if (p.x < minX) minX = p.x;
    if (p.x > maxX) maxX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  return {
    minX, maxX, minY, maxY,
    dx: Math.max(EPS, maxX - minX),
    dy: Math.max(EPS, maxY - minY),
  };
}

function spacedOutline(shape: THREE.Shape, segments = 1024) {
  const pts = shape.getSpacedPoints(segments).map((p) => new THREE.Vector2(p.x, p.y));
  const cum = new Array<number>(pts.length).fill(0);
  let L = 0;
  for (let i = 1; i < pts.length; i++) {
    L += pts[i].distanceTo(pts[i - 1]);
    cum[i] = L;
  }
  L += pts[0].distanceTo(pts[pts.length - 1]);
  return { pts, cum, total: L };
}

function nearestS(x: number, y: number, pts: THREE.Vector2[], cum: number[], total: number) {
  let bi = 0, bd2 = Infinity;
  for (let i = 0; i < pts.length; i++) {
    const dx = x - pts[i].x, dy = y - pts[i].y;
    const d2 = dx * dx + dy * dy;
    if (d2 < bd2) { bd2 = d2; bi = i; }
  }
  return total > 0 ? cum[bi] / total : 0;
}

const SvgHeadstone = React.forwardRef<THREE.Group, Props>(({
  url,
  depth,
  scale = 0.01,
  faceTexture,
  sideTexture,
  autoRepeat = false,
  tileSize = 0.1,
  sideTileSize,
  faceRepeatX = 6,
  faceRepeatY = 6,
  sideRepeatX = 8,
  sideRepeatY = 1,
  targetHeight,
  targetWidth,
  preserveTop = true,
  bevel = false,
  doubleSided = false,
  showEdges = false,
  meshProps,
  children,
  selectedAdditions = [],
  inscriptions = [],
}, ref) => {
  
  // 1. Load Data
  const svgData = useLoader(SVGLoader, url);
  const textures = useTexture({
    face: faceTexture,
    side: sideTexture ?? faceTexture
  });

  // 2. Clone Textures
  const [clonedFaceMap, clonedSideMap] = useMemo(() => {
    const f = textures.face.clone();
    const s = textures.side.clone();
    
    [f, s].forEach(t => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.minFilter = THREE.LinearMipmapLinearFilter;
      t.magFilter = THREE.LinearFilter;
      (t as any).anisotropy = 8;
      t.generateMipmaps = true;
      t.needsUpdate = true;
    });
    return [f, s];
  }, [textures.face, textures.side]);

  // 3. Generate Geometry
  const { geometries, dims, meshScale, apiData, childWrapperPos } = useMemo(() => {
    const shapes: THREE.Shape[] = [];
    svgData.paths.forEach((p: any) => shapes.push(...SVGLoader.createShapes(p)));
    
    if (!shapes.length) {
      return { 
        geometries: [], 
        dims: null, 
        meshScale: [1, 1, 1] as [number, number, number],
        apiData: { frontZ: 0, unitsPerMeter: 1, version: 0, worldWidth: 1, worldHeight: 1 },
        childWrapperPos: [0, 0, 0] as [number, number, number]
      };
    }

    const base = shapes[0];
    const outline = spacedOutline(base, 1024);
    
    // Bounds and world size
    const { minX, maxX, minY, maxY, dx, dy } = shapeBounds(base);
    const widthW = dx * Math.abs(scale);
    const heightW = dy * Math.abs(scale);

    // Targets
    const wantW = targetWidth ?? widthW;
    const wantH = targetHeight ?? heightW;

    // Uniform scale (width)
    const sCore = wantW / Math.max(EPS, widthW);
    const coreH_world = heightW * sCore;

    // Bottom target (top fixed) in SVG space
    const toSV = (w: number) => w / Math.max(EPS, Math.abs(scale) * sCore);
    const targetH_SV = preserveTop ? toSV(wantH) : dy * sCore;
    const bottomTarget_SV = minY + targetH_SV;

    // Build extrudes
    const extrudeSettings = {
      depth,
      steps: 1,
      bevelEnabled: bevel,
      bevelSegments: bevel ? 2 : 0,
      bevelSize: bevel ? 0.8 : 0,
      bevelThickness: bevel ? 0.8 : 0,
    };

    let coreGeom = new THREE.ExtrudeGeometry(base, extrudeSettings);
    const geoms: THREE.BufferGeometry[] = [coreGeom];

    if (preserveTop && wantH > coreH_world + 1e-9) {
      const s = new THREE.Shape();
      s.moveTo(minX, maxY);
      s.lineTo(maxX, maxY);
      s.lineTo(maxX, bottomTarget_SV);
      s.lineTo(minX, bottomTarget_SV);
      s.closePath();
      geoms.push(new THREE.ExtrudeGeometry(s, extrudeSettings));
    } else if (preserveTop && wantH < coreH_world - 1e-9) {
      const pos = coreGeom.getAttribute('position') as THREE.BufferAttribute;
      const P = pos.array as Float32Array;
      for (let i = 0; i < P.length; i += 3)
        if (P[i + 1] > bottomTarget_SV) P[i + 1] = bottomTarget_SV;
      pos.needsUpdate = true;
    }

    // Merge
    let merged: THREE.BufferGeometry = geoms.length > 1 
      ? BufferGeometryUtils.mergeGeometries(geoms) 
      : geoms[0];

    if (merged.index) merged = merged.toNonIndexed();

    // --- TRANSFORM TO CENTERED SVG SPACE ---
    // 1. Center X. 
    // 2. Align Top to Y=0 (Translate -minY). 
    //    Result: Y goes from 0 (Top) to +Height (Bottom).
    // 3. Center Z.
    merged.translate(-(minX + maxX) / 2, -minY, -depth / 2);

    // --- WINDING ORDER FIX (CRITICAL) ---
    // We will render this with scale.y = -1 (Negative Scale).
    // Negative scale turns "Outside" faces "Inside" (Black/Invisible).
    // To fix this, we manually swap the winding order of vertices here.
    // Inverted Mesh + Inverted Scale = Correct Mesh.
    const posAttr = merged.getAttribute('position');
    for (let i = 0; i < posAttr.count; i += 3) {
       const x1 = posAttr.getX(i + 1), y1 = posAttr.getY(i + 1), z1 = posAttr.getZ(i + 1);
       const x2 = posAttr.getX(i + 2), y2 = posAttr.getY(i + 2), z2 = posAttr.getZ(i + 2);
       posAttr.setXYZ(i + 1, x2, y2, z2);
       posAttr.setXYZ(i + 2, x1, y1, z1);
    }
    merged.computeVertexNormals();

    // Material Groups
    const zFront = -depth / 2;
    const zBack = depth / 2;
    const zTol = Math.max(0.25, Math.abs(depth) * 0.01);
    
    merged.clearGroups();
    const pos = merged.getAttribute('position') as THREE.BufferAttribute;
    const triCount = Math.floor(pos.count / 3);
    let currentMat = -1, start = 0, count = 0;
    const flush = () => { if (count > 0) { merged.addGroup(start, count, currentMat); start += count; count = 0; } };

    for (let t = 0; t < triCount; t++) {
      const i0 = t * 3, i1 = i0 + 1, i2 = i0 + 2;
      const z0 = pos.getZ(i0), z1 = pos.getZ(i1), z2 = pos.getZ(i2);
      const cap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol && Math.abs(z2 - zFront) <= zTol) ||
                  (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol && Math.abs(z2 - zBack) <= zTol);
      const matIndex = cap ? 0 : 1;
      if (currentMat === -1) currentMat = matIndex;
      if (matIndex !== currentMat) { flush(); currentMat = matIndex; }
      count += 3;
    }
    flush();

    // UV Mapping
    merged.computeBoundingBox();
    const x0 = merged.boundingBox!.min.x; 
    const dxU = merged.boundingBox!.max.x - merged.boundingBox!.min.x;
    
    // Y-Range is 0 to Height.
    const y0 = merged.boundingBox!.min.y; // Should be 0
    const dyU = merged.boundingBox!.max.y - merged.boundingBox!.min.y;
    
    const uvArr = new Float32Array(pos.count * 2);
    const centerX = (minX + maxX) / 2;
    
    for (let i = 0; i < pos.count; i += 3) {
      const z0 = pos.getZ(i), z1 = pos.getZ(i+1);
      const isCap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol) ||
                    (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol);
      
      if (isCap) {
        for (let j = 0; j < 3; j++) {
          const u = (pos.getX(i+j) - x0) / dxU;
          // Geometry Y=0 is Top. Texture V=1 is Top.
          // Geometry Y=Max is Bottom. Texture V=0 is Bottom.
          // So V = 1 - (y/H).
          const v = 1 - (pos.getY(i+j) - y0) / dyU; 
          uvArr[2*(i+j)] = u;
          uvArr[2*(i+j)+1] = v;
        }
      } else {
        for (let j = 0; j < 3; j++) {
          const px = pos.getX(i+j);
          const py = pos.getY(i+j);
          const pz = pos.getZ(i+j);
          // Map GeomY back to SVG Absolute Y
          const originalSvgY = py + minY;
          const s = nearestS(px + centerX, originalSvgY, outline.pts, outline.cum, outline.total);
          const t = (pz - zFront) / (zBack - zFront);
          uvArr[2*(i+j)] = s;
          uvArr[2*(i+j)+1] = t;
        }
      }
    }
    merged.setAttribute('uv', new THREE.BufferAttribute(uvArr, 2));

    // Stats & Output
    const worldW = (maxX - minX) * Math.abs(scale) * sCore;
    const worldH = (bottomTarget_SV - minY) * Math.abs(scale) * sCore;
    const worldPerim = outline.total * Math.abs(scale) * sCore;
    const worldDepth = Math.abs(depth * scale);

    // SCALE: Use NEGATIVE Y scale on the mesh/group.
    // This matches SVG coordinate system (Y-Down).
    const finalScale: [number, number, number] = [scale * sCore, -scale * sCore, scale];

    // --- CHILD WRAPPER POSITION ---
    // The group is scaled Y=-1.
    // Local (0,0,0) corresponds to (CenterX, TopY, CenterZ) in SVG logic.
    // But children usually expect (0,0) to be Top-Left.
    // X Offset: Move from Center to Left. = -(Width/2) = -(maxX-minX)/2.
    // Y Offset: At Y=0 (Top).
    // Z Offset: Slightly forward.
    const wrapperX = -(maxX - minX) / 2;
    const wrapperY = 0; 
    const wrapperZ = depth / 2 + 0.05;

    return {
      geometries: [merged],
      dims: { worldW, worldH, worldPerim, worldDepth },
      meshScale: finalScale,
      apiData: {
        frontZ: depth / 2,
        unitsPerMeter: 1 / Math.max(EPS, scale * sCore),
        version: Math.random(),
        worldWidth: worldW,
        worldHeight: worldH
      },
      childWrapperPos: [wrapperX, wrapperY, wrapperZ] as [number, number, number]
    };
  }, [svgData, depth, bevel, scale, targetWidth, targetHeight, preserveTop]);

  // 4. Update Texture Repeats
  useLayoutEffect(() => {
    if (!dims) return;
    const usePhysical = autoRepeat || tileSize != null || sideTileSize != null;
    const faceTile = tileSize ?? 0.1;
    const sideTile = sideTileSize ?? faceTile;
    const repFaceX = usePhysical ? Math.max(1, dims.worldW / faceTile) : (faceRepeatX ?? 6);
    const repFaceY = usePhysical ? Math.max(1, dims.worldH / faceTile) : (faceRepeatY ?? 6);
    const repSideX = usePhysical ? Math.max(1, dims.worldPerim / sideTile) : (sideRepeatX ?? 8);
    const repSideY = usePhysical ? Math.max(1, dims.worldDepth / sideTile) : (sideRepeatY ?? 1);

    clonedFaceMap.repeat.set(repFaceX, repFaceY);
    clonedSideMap.repeat.set(repSideX, repSideY);
    clonedFaceMap.needsUpdate = true;
    clonedSideMap.needsUpdate = true;
  }, [dims, autoRepeat, tileSize, sideTileSize, faceRepeatX, faceRepeatY, sideRepeatX, sideRepeatY, clonedFaceMap, clonedSideMap]);

  // 5. Materials
  const materials = useMemo(() => {
    const common = {
      roughness: 0.15,
      metalness: 0.1,
      color: new THREE.Color(0xffffff),
      side: doubleSided ? THREE.DoubleSide : THREE.FrontSide,
      envMapIntensity: 1.5,
    };
    return [
      new THREE.MeshStandardMaterial({ ...common, map: clonedFaceMap }),
      new THREE.MeshStandardMaterial({ ...common, map: clonedSideMap })
    ];
  }, [clonedFaceMap, clonedSideMap, doubleSided]);

  const meshRef = useRef<THREE.Mesh>(null!);
  const groupRef = useRef<THREE.Group>(null!);
  
  const [isReady, setIsReady] = useState(false);
  useLayoutEffect(() => { setIsReady(true); }, []);

  useImperativeHandle(ref, () => groupRef.current);

  const childApi = useMemo(() => ({
    group: groupRef,
    mesh: meshRef,
    frontZ: apiData?.frontZ ?? 0,
    unitsPerMeter: apiData?.unitsPerMeter ?? 100,
    version: apiData?.version ?? 0,
    worldWidth: apiData?.worldWidth ?? 1,
    worldHeight: apiData?.worldHeight ?? 1
  }), [apiData, isReady]);

  if (!geometries.length || !dims) return null;

  return (
    <group ref={groupRef} scale={meshScale}>
      {geometries.map((geom, i) => (
        <mesh
          key={`hs-${i}`}
          ref={i === 0 ? meshRef : undefined}
          geometry={geom}
          material={materials}
          castShadow
          receiveShadow
          {...meshProps}
        >
          {showEdges && <Edges scale={1.002} threshold={15} color="white" />}
        </mesh>
      ))}

      {/* 
         CHILDREN WRAPPER:
         No Scaling needed here because Parent Group handles Y-Flip.
         Just offset to align (0,0) to Top-Left.
      */}
      <group position={childWrapperPos}>
         {typeof children === 'function' && children(childApi, selectedAdditions)}
      </group>
    </group>
  );
});

SvgHeadstone.displayName = 'SvgHeadstone';

export default SvgHeadstone;