Yep — I see why the motifs jumped off the tablet and still look undersized. Two separate things are happening:

1. **Positioning space mismatch.**
   Some motifs are being mapped from authoring *canvas* coords (center-origin, initW×initH) into a DOM box that isn’t the tablet SVG viewport. When that outer box shifts (padding, crop, base, etc.), left/right “drift” appears — exactly like your last screenshot.

2. **Scale factor is incomplete.**
   Motif size is being multiplied by `ratio` but not by the *uniform* canvas→display scale that comes from `overlayWidth / initWidth` (or you’re using a fallback viewBox of 100×100 when the SVG has a different intrinsic size). That keeps them too small.

Below is a minimal, surgical fix you can drop into **DesignPageClient.tsx**:

---

### 1) Create a true overlay locked to the SVG viewport

Put every inscription/motif inside a positioned overlay that exactly matches the headstone SVG’s client rect (no page margins, no crop bias).

```tsx
// after you know the SVG element:
const svgEl = svgHostRef.current?.querySelector('svg');
const vb = svgEl?.getAttribute('viewBox')?.split(/\s+/).map(Number);
const vbW = vb?.[2] ?? svgEl?.clientWidth ?? 0;
const vbH = vb?.[3] ?? svgEl?.clientHeight ?? 0;

// where you render:
<div ref={overlayRef}
     style={{
       position: 'absolute',
       left: svgEl?.getBoundingClientRect().left ?? 0,
       top: svgEl?.getBoundingClientRect().top ?? 0,
       width: svgEl?.clientWidth ?? 0,
       height: svgEl?.clientHeight ?? 0,
       pointerEvents: 'none'
     }}>
  {/* place all inscriptions & motifs here */}
</div>
```

> Key point: from now on, **all** layout math is relative to this overlay’s **width/height** (the displayed SVG size), not the page.

---

### 2) Use one consistent mapper from authoring → overlay pixels

Authoring JSON uses center-origin `{cx,cy}` (or `{x,y}` equivalent). Map it like this:

```ts
function mapCanvasToOverlay(
  cx: number, cy: number,
  initW: number, initH: number,
  overlayW: number, overlayH: number
) {
  const sx = overlayW / initW;   // uniformScale X
  const sy = overlayH / initH;   // uniformScale Y (same if you preserve aspect)
  return {
    left: overlayW / 2 + cx * sx,
    top:  overlayH / 2 + cy * sy,
    scale: sx // use this for sizing
  };
}
```

When you render an item:

```tsx
const { left, top, scale } = mapCanvasToOverlay(
  item.cx ?? item.x ?? 0,
  item.cy ?? item.y ?? 0,
  initW, initH,
  overlayW, overlayH
);

const baseStyle: React.CSSProperties = {
  position: 'absolute',
  left,
  top,
  transform: 'translate(-50%, -50%)', // center the box on (left, top)
  pointerEvents: 'auto'
};
```

*This removes the left/right inversion and the “flies off the tablet” issue, because we’re no longer mixing page vs. canvas vs. crop spaces.*

---

### 3) Size motifs correctly (viewBox × ratio × uniformScale)

Fetch the intrinsic viewBox once per SVG, then compute pixel size from `ratio`:

```ts
// already in your file:
async function getIntrinsicDims(src: string) { /* ... */ }

// per motif:
const src = getMotifPath(motif) ?? getFallbackMotifPath(motif);
const { vw, vh } = await getIntrinsicDims(src);   // true intrinsic units
const aspect = vh / vw;

const ratio = Number(motif.ratio) || 1;           // from JSON
const widthPx = vw * ratio * scale;               // scale = overlayW / initW
const heightPx = widthPx * aspect;
```

Then apply:

```tsx
<div style={{
  ...baseStyle,
  width: widthPx,
  height: heightPx
}}>
  <img src={src} style={{ width: '100%', height: '100%' }} />
</div>
```

**Do not** multiply by any DPR or screenshot crop numbers. Authoring was done in logical canvas units; `scale = overlayW / initW` is the only display factor you need.

---

### 4) Keep dragging in the same space

Your `DraggableElement` is fine if you keep a **single** centering translate and append the drag offset after it (you already do this). Just be sure you pass the same `scale` you got from `mapCanvasToOverlay` so deltas line up 1:1 with the authoring space.

---

### 5) Common pitfalls to remove (caused the regressions you saw)

* No extra translate/scale from page or crop analysis — **overlay rect only**.
* No sign flips (`cx` is positive → right; negative → left).
* Don’t fall back to `100×100` viewBox unless fetch fails (that makes motifs tiny).
* Don’t mix `%` with pixel math; compute pixel `left/top/width/height` once.

---

If you wire those four pieces, the top-arc motifs will stay anchored over the tablet, grow to the same visual scale as on the authoring canvas, and dragging will feel natural again.

If you want, paste the small block where you currently compute `left/top/width/height` for motifs and I’ll rewrite it verbatim with the mapper above so you can drop it in. 
