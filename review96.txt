You’re close, but the current mapping still risks using the **canvas height** instead of the **stone bbox height** in pixels. That’s exactly why uncropped screenshots break the mm↔px ratio. The fix is simple:

* Derive **pxPerMm from the headstone’s bbox in the authoring canvas**, not from the whole canvas (`init_height`).
* Then use that single `pxPerMm` to convert any physical dimension (height, width, margins in mm) to authoring-pixels.
* Finally, scale authoring-pixels → display-pixels with the same `uniformScale` you already use for the rest of the layout.

Below is a drop-in set of helpers + a tiny integration tweak. It’s self-contained and works even when screenshots aren’t cropped.

---

### 1) Add/confirm these types (or extend your existing ones)

```ts
type ViewBoxMM = { vw: number; vh: number }; // stone viewBox logical units (not mm)
type PhysicalMM = { widthMM: number; heightMM: number }; // real stone physical size in mm

interface AuthoringInfo {
  initW: number;         // authoring canvas width in px (screenshot width)
  initH: number;         // authoring canvas height in px (screenshot height)
  offsetX?: number;
  offsetY?: number;
  // Optional but nice-to-have if you can persist it at save time:
  headstoneBBoxPxH?: number; // exact bbox height of stone within authoring canvas (px)
  headstoneBBoxPxW?: number; // exact bbox width of stone within authoring canvas (px)
}

interface StoneInfo {
  viewBox: { vw: number; vh: number }; // the SVG path coords space for the stone
  physical: { widthMM: number; heightMM: number };
}

interface ContainerInfo { width: number; height: number; pad?: number; }
```

---

### 2) Compute pxPerMm from the stone bbox (robust for uncropped screenshots)

```ts
/**
 * Compute the pixel-per-mm factor *in the authoring canvas*.
 * Priority:
 *   1) Use persisted stone bbox in px if available (best)
 *   2) Else derive bbox from how the stone viewBox fits into the authoring canvas
 */
function computePxPerMmAuthoring(authoring: AuthoringInfo, stone: StoneInfo): {
  pxPerMm: number;
  stoneBBoxPxW: number;
  stoneBBoxPxH: number;
} {
  const { initW, initH, headstoneBBoxPxH, headstoneBBoxPxW } = authoring;
  const { vw, vh } = stone.viewBox;
  const { widthMM, heightMM } = stone.physical;

  // 1) If we have exact bbox from save-time, use it
  if (headstoneBBoxPxH && heightMM > 0) {
    const pxPerMm = headstoneBBoxPxH / heightMM;
    const stoneBBoxPxW2 = headstoneBBoxPxW ?? (widthMM > 0 ? widthMM * pxPerMm : vw * (headstoneBBoxPxH / vh));
    return { pxPerMm, stoneBBoxPxW: stoneBBoxPxW2, stoneBBoxPxH: headstoneBBoxPxH };
  }

  // 2) Derive bbox by fitting the stone viewBox into the authoring canvas
  //    (this is independent of cropping: we only care how the *stone* was scaled to fit)
  const scaleToCanvas = Math.min(initW / vw, initH / vh);
  const stoneBBoxPxW = vw * scaleToCanvas;
  const stoneBBoxPxH = vh * scaleToCanvas;

  // Physical mapping: stoneBBoxPxH corresponds to heightMM
  const pxPerMm = stoneBBoxPxH / heightMM; // <-- This is the critical ratio

  return { pxPerMm, stoneBBoxPxW, stoneBBoxPxH };
}
```

> Why this works when screenshots aren’t cropped: we never divide by `initH` to get mm/px. We compute how the **stone** was fit (its bbox in px) and map that to its **physical mm**. Any added top/bottom margins in the screenshot are irrelevant.

---

### 3) Keep the two pipelines separate

* **Physical pipeline:** mm → authoring px using `pxPerMm` (for anything measured in mm).
* **Layout pipeline:** authoring px → display px using your existing `uniformScale` (for everything that was authored in pixels).

```ts
/** mm (physical) -> authoring px */
function mmToAuthoringPx(mm: number, pxPerMm: number) {
  return mm * pxPerMm;
}

/** authoring px -> display px */
function authoringPxToDisplayPx(px: number, uniformScale: number) {
  return px * uniformScale;
}
```

---

### 4) Integrate where you build your mapping

Right after you know the authoring canvas (`initW/initH`), the stone `viewBox`, and the container size, compute:

```ts
export function buildUniversalMapping(
  authoring: AuthoringInfo,
  container: ContainerInfo,
  stone: StoneInfo
) {
  // 0) Compute pxPerMm from the stone bbox (not from canvas height!)
  const { pxPerMm, stoneBBoxPxW, stoneBBoxPxH } = computePxPerMmAuthoring(authoring, stone);

  // 1) Your existing uniform responsive scale from authoring canvas to display container
  const pad = container.pad ?? 0;
  const availW = Math.max(1, container.width - pad * 2);
  const availH = Math.max(1, container.height - pad * 2);
  const uniformScale = Math.min(availW / authoring.initW, availH / authoring.initH);

  // 2) Helpers to expose downstream
  const mmToDisplayPx = (mm: number) => authoringPxToDisplayPx(mmToAuthoringPx(mm, pxPerMm), uniformScale);
  const authoringToDisplayPx = (px: number) => authoringPxToDisplayPx(px, uniformScale);

  return {
    pxPerMmAuthoring: pxPerMm,
    stoneBBoxPxW,
    stoneBBoxPxH,
    uniformScale,
    // conversions
    mmToDisplayPx,
    authoringToDisplayPx,
  };
}
```

---

### 5) Use it consistently

* To render a **physical** stone height in display px:

  ```ts
  const stoneHeightDisplayPx = mmToDisplayPx(stone.physical.heightMM);
  ```
* To render an **inscription** saved as `fontSizePx` in authoring pixels:

  ```ts
  const fontSizeDisplayPx = authoringToDisplayPx(fontSizePx);
  ```
* To size a **motif** whose physical height is stored in mm (legacy data sometimes does this):

  ```ts
  const motifHDisplayPx = mmToDisplayPx(motif.heightMM);
  const motifWDisplayPx = mmToDisplayPx(motif.widthMM ?? motif.heightMM / motif.ratio);
  ```

---

### 6) Guardrails (recommended)

* Assert that `stoneBBoxPxH / stone.physical.heightMM` ≈ `stoneBBoxPxW / stone.physical.widthMM` (within 1–2%). If not, log a warning (bad inputs).
* If you *must* fall back because physical width isn’t known, compute width via `ratio = vw/vh` and `widthMM = heightMM * (vw/vh)`.

---

### Why your `600/665` works *only sometimes*

It’s correct **only** if `665 px` is the **stone bbox height** in the authoring canvas. If `665 px` is the **entire screenshot/canvas** (with margins), your ratio mixes stone + margin → everything down-stream is off. The above change prevents that by anchoring the ratio to the **stone bbox**.

---

If you want, I can turn this into a tiny PR-style patch against your current `svg-generator.ts`—but the crucial change is to compute `pxPerMm` from the **stone’s bbox in authoring px** (derived via viewBox fit if you didn’t persist it) and never from the raw `init_height`.
