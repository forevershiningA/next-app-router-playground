Getting really close. The last mismatch is still the **top motifs** (size + a slight vertical drift). You’ve mostly fixed fonts/center motif; what’s left is just how you size “ratio-only” motifs.

Here’s a surgical, drop-in patch you can apply in **DesignPageClient.tsx** (the file you uploaded). It replaces the ratio path and removes the last double-scale. 

---

### 1) Add an intrinsic viewBox reader (once, near the top of the file)

```ts
// cache: src -> {vw, vh}
const __intrinsicCache: Record<string,{vw:number;vh:number}> = {};

async function getIntrinsicDims(src: string): Promise<{vw:number;vh:number}> {
  if (__intrinsicCache[src]) return __intrinsicCache[src];
  const txt = await fetch(src).then(r => r.text());
  const m = txt.match(/viewBox\s*=\s*"([\d.\s-]+)"/i);
  if (!m) return (__intrinsicCache[src] = { vw: 100, vh: 100 });
  const [, vb] = m;
  const [, , vw, vh] = vb.trim().split(/\s+/).map(Number);
  return (__intrinsicCache[src] = { vw, vh });
}
```

---

### 2) Use **one scale** for everything (keep `uniformScale`)

Remove any remaining `displayScale` multipliers from motif sizing; positions and sizes must both use `uniformScale` only. (You already compute `uniformScale`, `offsetX`, `offsetY` correctly—keep that.) 

---

### 3) Motif mapping (replace your current ratio sizing block with this)

```ts
// helpers from your existing scalingFactors:
const savedDpr   = scalingFactors.designDpr || 1;
const usesPhys   = scalingFactors.usesPhysicalCoords || false;
const { uniformScale, initW, initH, offsetX, offsetY } = scalingFactors;

// -------------- position (center-origin -> top-left) --------------
const rawX = motif.x ?? motif.cx ?? 0;
const rawY = motif.y ?? motif.cy ?? 0;
const canvasX = usesPhys ? rawX / savedDpr : rawX;
const canvasY = usesPhys ? rawY / savedDpr : rawY;

const left = offsetX + (canvasX + initW / 2) * uniformScale;
const top  = offsetY + (canvasY + initH / 2) * uniformScale;

// -------------- size --------------
const src = getMotifPath(motif);                    // your existing helper
const { vw, vh } = await getIntrinsicDims(src);     // intrinsic authoring units
const ratio = Number(motif.ratio ?? 1);             // dimensionless

// If explicit pixel height/width were saved, normalise DPR once.
// Otherwise, size from intrinsic viewBox * ratio (authoring space).
const hCanvas = typeof motif.height === 'number'
  ? (usesPhys ? motif.height / savedDpr : motif.height)
  : (vh * ratio);

const wCanvas = typeof motif.width === 'number'
  ? (usesPhys ? motif.width / savedDpr : motif.width)
  : (vw * ratio);

// final display size — scale ONCE
const heightPx = hCanvas * uniformScale;
const widthPx  = wCanvas  * uniformScale;

// render style:
const style: React.CSSProperties = {
  position: 'absolute',
  left, top,
  width: `${widthPx}px`,
  height: `${heightPx}px`,
  transform: 'translate(-50%, -50%)',
  // ...pointer, filters, etc.
};
```

**Key points this fixes**

* Uses **intrinsic** SVG size (`viewBox`) in the ratio path → no dependence on DOM-measured size.
* DPR divide only for **pixel** values (`x,y,height,width,font_size`). **Never** divide `ratio`.
* Single scale everywhere: `uniformScale`.

---

### 4) Avoid the 100px fallback flash

When a motif has **only** `ratio`, skip rendering until `{vw,vh}` are loaded:

```ts
if (!vw || !vh) return null; // or a tiny skeleton; prevents tiny placeholder
```

---

### 5) Quick sanity log (temporary)

```ts
console.log('Top motif sanity', {
  ratio, vw, vh,
  hCanvas, heightPx, uniformScale,
  canvasX, canvasY, left, top
});
```

You should see:

* `hCanvas ≈ vh * ratio` (authoring units),
* `heightPx = hCanvas * uniformScale`,
* positions moving 1:1 with inscriptions.

Apply the above and those top leaves/birds will line up exactly with the legacy canvas.
