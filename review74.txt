Yep — it’s a breakthrough in the sense that you’re now seeing the *real* root cause:

## What’s actually wrong

1. **There are multiple, conflicting “base renderers” in `DesignPageClient.tsx`.**
   You currently render the base in several different ways (v50, v51–58, v61, v63/66/69/70, plus an older standalone `<div class="relative">` block). These blocks use **different coordinate systems** (authoring-px vs overlay-px), different sizing rules, and different z-indexes. That’s why the base keeps “floating”, sits too wide, or overlaps/underruns the tablet — you are rendering *more than one base* with competing math.       

2. **That older “relative” block is outside the headstone overlay** so it can’t share the tablet’s scale/offset. It will always drift and look too wide/narrow relative to the stone, no matter how you tweak numbers. (This is the one that makes the base appear far below with blank space.) 

3. **Even the newer base blocks mix units**, sometimes using unscaled authoring width (`topProfile.drawW`) to place an absolutely-positioned element in overlay pixels. That produces the “right side too long” symptom you keep seeing.  

---

## Solid fix (one source of truth)

Do this and the base will lock perfectly under the tablet, centered, with correct overhang:

### A) Delete/disable all duplicate base renderers

Remove (or guard with `if(false)`) every base block except **one**. Specifically delete/disable:

* v50 block (absolute at `top: offsetY+overlayH`) 
* v51–58 blocks (various `stoneLeft/stoneBottom` calcs)   
* v61 “full-width row + flex center” block (it’s a different coordinate system) 
* Any duplicated v63/v66 fragments (same math, different units)  
* The **old standalone `<div className="relative">`** base (this is the one making a second base far below the stone). **Remove it entirely.** 

### B) Keep a single, unified base renderer inside the headstone overlay

Use **one** block that:

* Reads base mm from JSON (length/width_mm for length; height_mm for height; conservative defaults if missing).
* Converts mm → **overlay px** using the same scale as the tablet: `pxPerMm = stoneW / headWmm`.
* Centers under the tablet and tucks up by a small overlap.

Drop this in place of the others (inside the same overlay container that draws the tablet and uses `topProfile`):

```tsx
{baseData && (() => {
  // 1) MM inputs
  const headWmm = Number(
    (sanitizedDesignData || []).find(it => it.type === 'Headstone')?.width
  ) || 600;

  const baseItem = (sanitizedDesignData || []).find(it =>
    /base/i.test(`${it.type} ${it.name ?? ''} ${it.label ?? ''}`)
  ) || {};

  const baseLenMm = [
    baseItem.length_mm, baseItem.length, baseItem.width_mm, baseItem.width,
    baseItem.size?.length_mm, baseItem.size?.width_mm
  ].map(Number).filter(v => Number.isFinite(v) && v >= 300).sort((a,b)=>b-a)[0];

  const baseHmm = [
    baseItem.height_mm, baseItem.height, baseItem.size?.height_mm, baseItem.thickness_mm
  ].map(Number).find(v => Number.isFinite(v) && v >= 50 && v <= 200);

  const overhangEachSideMm = 15; // default if length unknown
  const lengthMm = baseLenMm ?? (headWmm + 2*overhangEachSideMm);
  const heightMm = baseHmm ?? 90;

  // 2) Overlay scale from the fitted tablet (same space as motifs/inscriptions)
  const { uniformScale, initW, initH, offsetX, offsetY } = scalingFactors;
  const overlayW = initW * uniformScale, overlayH = initH * uniformScale;
  const sx = overlayW / initW, sy = overlayH / initH;

  const stoneLeft = offsetX + (topProfile?.offX ?? 0) * sx;
  const stoneTop  = offsetY + (topProfile?.offY ?? 0) * sy;
  const stoneW    = (topProfile?.drawW ?? initW) * sx;
  const stoneH    = (topProfile?.drawH ?? initH) * sy;
  const stoneBottom = stoneTop + stoneH;

  // 3) mm → px using tablet width
  const pxPerMm = stoneW / headWmm;
  const baseWidthPx  = Math.round(lengthMm * pxPerMm);
  const baseHeightPx = Math.round(heightMm * pxPerMm);

  // 4) Position: center and tuck under the tablet edge
  const overlapPx = Math.min(Math.round(baseHeightPx * 0.25), 12);
  const left = Math.round(stoneLeft + (stoneW - baseWidthPx) / 2);
  const top  = Math.round(stoneBottom - overlapPx);

  const style: React.CSSProperties = {
    position: 'absolute',
    left, top,
    width: baseWidthPx,
    height: baseHeightPx,
    backgroundImage: baseTextureData ? `url(${baseTextureData})` : 'linear-gradient(to bottom,#1a1a1a,#000)',
    backgroundSize: 'cover',
    backgroundPosition: 'center',
    zIndex: 1,            // BELOW inscriptions/motifs, ABOVE tablet bg
    pointerEvents: 'none'
  };

  return <div style={style} />;
})()}
```

This renderer:

* Uses **one** coordinate space (overlay px tied to `topProfile`), so it lines up every time.
* Centers by geometry, not margins.
* Tucks under slightly (`overlapPx`) so the joint looks real.
* Will never “float”, never be too wide on one side, and never cover the tablet face.

---

## Why this fixes *your* screenshots

* The “floating, too wide, blank gap” images are the **external relative block** competing with an internal block. Removing that block eliminates the phantom base and the unexplained spacing. 
* The “too wide on right / covering the headstone” frames come from **mixed units** (authoring px used as overlay px). The unified renderer converts mm→px with the *same* scale used for the tablet, so the base width matches the headstone width + overhang exactly.  

---

## Optional (SEHOVIC vertical target)

You also noted the inscription’s Y should be at the curve start (its **center** aligned to the top curve start). That’s controlled by the inscription mapping, not the base. Make sure your inscription block uses the **same `topProfile.offY/drawH` frame** and positions text by **center Y** rather than top Y for that line. (You already do this for motifs with `snapTop`; mirror that logic for the SEHOVIC line.) 

---

If you keep just the single renderer above and delete the rest, your base will “stick” under the stone correctly on every device and DPR.
