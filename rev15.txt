This fix adjusts the Child Wrapper Position to align with the SVG Document Origin (0,0) rather than the Geometry Bounding Box Origin.

By shifting the Child Wrapper by the exact same amount we shifted the Geometry (-Center, -Top), we ensure that if a Motif is defined at x=500, y=500 in the SVG file, it aligns perfectly with the Stone Geometry that was also at x=500, y=500, regardless of where the Stone was centered on the canvas.

code
Tsx
download
content_copy
expand_less
// components/SvgHeadstone.tsx
'use client';

import * as React from 'react';
import { useMemo, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';
import * as THREE from 'three';
import { useLoader } from '@react-three/fiber';
import type { ThreeElements } from '@react-three/fiber';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { Edges, useTexture } from '@react-three/drei';
import { Line } from '#/lib/headstone-store';

export type HeadstoneAPI = {
  group: React.RefObject<THREE.Group>;
  mesh: React.RefObject<THREE.Mesh>;
  frontZ: number;
  unitsPerMeter: number;
  version: number;
  worldWidth: number;
  worldHeight: number;
};

const EPS = 1e-9;

type Props = {
  url: string;
  depth: number;
  scale?: number;
  faceTexture: string;
  sideTexture?: string;
  autoRepeat?: boolean;
  tileSize?: number;
  sideTileSize?: number;
  topTileSize?: number;
  faceRepeatX?: number;
  faceRepeatY?: number;
  sideRepeatX?: number;
  sideRepeatY?: number;
  targetHeight?: number;
  targetWidth?: number;
  preserveTop?: boolean;
  bevel?: boolean;
  doubleSided?: boolean;
  showEdges?: boolean;
  meshProps?: ThreeElements['mesh'];
  children?: (api: HeadstoneAPI, selectedAdditions: string[]) => React.ReactNode;
  inscriptions: Line[];
  selectedAdditions?: string[];
};

/* ---------------- helpers ---------------- */

function shapeBounds(shape: THREE.Shape) {
  const pts = shape.getPoints(256);
  let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
  for (const p of pts) {
    if (p.x < minX) minX = p.x;
    if (p.x > maxX) maxX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  return {
    minX, maxX, minY, maxY,
    dx: Math.max(EPS, maxX - minX),
    dy: Math.max(EPS, maxY - minY),
  };
}

function spacedOutline(shape: THREE.Shape, segments = 1024) {
  const pts = shape.getSpacedPoints(segments).map((p) => new THREE.Vector2(p.x, p.y));
  const cum = new Array<number>(pts.length).fill(0);
  let L = 0;
  for (let i = 1; i < pts.length; i++) {
    L += pts[i].distanceTo(pts[i - 1]);
    cum[i] = L;
  }
  L += pts[0].distanceTo(pts[pts.length - 1]);
  return { pts, cum, total: L };
}

function nearestS(x: number, y: number, pts: THREE.Vector2[], cum: number[], total: number) {
  let bi = 0, bd2 = Infinity;
  for (let i = 0; i < pts.length; i++) {
    const dx = x - pts[i].x, dy = y - pts[i].y;
    const d2 = dx * dx + dy * dy;
    if (d2 < bd2) { bd2 = d2; bi = i; }
  }
  return total > 0 ? cum[bi] / total : 0;
}

const SvgHeadstone = React.forwardRef<THREE.Group, Props>(({
  url,
  depth,
  scale = 0.01,
  faceTexture,
  sideTexture,
  autoRepeat = false,
  tileSize = 0.1,
  sideTileSize,
  faceRepeatX = 6,
  faceRepeatY = 6,
  sideRepeatX = 8,
  sideRepeatY = 1,
  targetHeight,
  targetWidth,
  preserveTop = true,
  bevel = false,
  doubleSided = false,
  showEdges = false,
  meshProps,
  children,
  selectedAdditions = [],
  inscriptions = [],
}, ref) => {
  
  // 1. Load SVG and Textures
  const svgData = useLoader(SVGLoader, url);
  const textures = useTexture({
    face: faceTexture,
    side: sideTexture ?? faceTexture
  });

  // 2. Clone Textures
  const [clonedFaceMap, clonedSideMap] = useMemo(() => {
    const f = textures.face.clone();
    const s = textures.side.clone();
    
    [f, s].forEach(t => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.minFilter = THREE.LinearMipmapLinearFilter;
      t.magFilter = THREE.LinearFilter;
      (t as any).anisotropy = 8;
      t.generateMipmaps = true;
      t.needsUpdate = true;
    });
    
    return [f, s];
  }, [textures.face, textures.side]);

  // 3. Generate Geometry
  const { geometries, dims, meshScale, apiData, childWrapperPos } = useMemo(() => {
    const shapes: THREE.Shape[] = [];
    svgData.paths.forEach((p: any) => shapes.push(...SVGLoader.createShapes(p)));
    
    if (!shapes.length) {
      return { 
        geometries: [], 
        dims: null, 
        meshScale: [1, 1, 1] as [number, number, number],
        apiData: { frontZ: 0, unitsPerMeter: 1, version: 0, worldWidth: 1, worldHeight: 1 },
        childWrapperPos: [0, 0, 0] as [number, number, number]
      };
    }

    const base = shapes[0];
    const outline = spacedOutline(base, 1024);
    
    // Bounds and world size
    const { minX, maxX, minY, maxY, dx, dy } = shapeBounds(base);
    const widthW = dx * Math.abs(scale);
    const heightW = dy * Math.abs(scale);

    // Targets
    const wantW = targetWidth ?? widthW;
    const wantH = targetHeight ?? heightW;

    // Uniform scale (width)
    const sCore = wantW / Math.max(EPS, widthW);
    const coreH_world = heightW * sCore;

    // Bottom target (top fixed) in SVG space
    const toSV = (w: number) => w / Math.max(EPS, Math.abs(scale) * sCore);
    const targetH_SV = preserveTop ? toSV(wantH) : dy * sCore;
    const bottomTarget_SV = minY + targetH_SV;

    // Build extrudes
    const extrudeSettings = {
      depth,
      steps: 1,
      bevelEnabled: bevel,
      bevelSegments: bevel ? 2 : 0,
      bevelSize: bevel ? 0.8 : 0,
      bevelThickness: bevel ? 0.8 : 0,
    };

    let coreGeom = new THREE.ExtrudeGeometry(base, extrudeSettings);
    const geoms: THREE.BufferGeometry[] = [coreGeom];

    if (preserveTop && wantH > coreH_world + 1e-9) {
      const s = new THREE.Shape();
      s.moveTo(minX, maxY);
      s.lineTo(maxX, maxY);
      s.lineTo(maxX, bottomTarget_SV);
      s.lineTo(minX, bottomTarget_SV);
      s.closePath();
      geoms.push(new THREE.ExtrudeGeometry(s, extrudeSettings));
    } else if (preserveTop && wantH < coreH_world - 1e-9) {
      const pos = coreGeom.getAttribute('position') as THREE.BufferAttribute;
      const P = pos.array as Float32Array;
      for (let i = 0; i < P.length; i += 3)
        if (P[i + 1] > bottomTarget_SV) P[i + 1] = bottomTarget_SV;
      pos.needsUpdate = true;
    }

    // Merge
    let merged: THREE.BufferGeometry = geoms.length > 1 
      ? BufferGeometryUtils.mergeGeometries(geoms) 
      : geoms[0];

    if (merged.index) merged = merged.toNonIndexed();

    // --- TRANSFORM GEOMETRY ---
    // 1. Center X. 2. Align Top to Y=0. 3. Center Z.
    // This makes the mesh's (0,0,0) point correspond to (CenterX, MinY, CenterZ) of the SVG.
    merged.translate(-(minX + maxX) / 2, -minY, -depth / 2);

    // --- WINDING ORDER FIX ---
    // Since we will scale Y by -1 in the Group, we must invert winding now 
    // to ensure faces point outwards after the flip.
    const posAttr = merged.getAttribute('position');
    for (let i = 0; i < posAttr.count; i += 3) {
       const x1 = posAttr.getX(i + 1), y1 = posAttr.getY(i + 1), z1 = posAttr.getZ(i + 1);
       const x2 = posAttr.getX(i + 2), y2 = posAttr.getY(i + 2), z2 = posAttr.getZ(i + 2);
       posAttr.setXYZ(i + 1, x2, y2, z2);
       posAttr.setXYZ(i + 2, x1, y1, z1);
    }
    merged.computeVertexNormals();

    // Material Groups
    const zFront = -depth / 2;
    const zBack = depth / 2;
    const zTol = Math.max(0.25, Math.abs(depth) * 0.01);
    
    merged.clearGroups();
    const pos = merged.getAttribute('position') as THREE.BufferAttribute;
    const triCount = Math.floor(pos.count / 3);
    let currentMat = -1, start = 0, count = 0;
    const flush = () => { if (count > 0) { merged.addGroup(start, count, currentMat); start += count; count = 0; } };

    for (let t = 0; t < triCount; t++) {
      const i0 = t * 3, i1 = i0 + 1, i2 = i0 + 2;
      const z0 = pos.getZ(i0), z1 = pos.getZ(i1), z2 = pos.getZ(i2);
      const cap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol && Math.abs(z2 - zFront) <= zTol) ||
                  (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol && Math.abs(z2 - zBack) <= zTol);
      const matIndex = cap ? 0 : 1;
      if (currentMat === -1) currentMat = matIndex;
      if (matIndex !== currentMat) { flush(); currentMat = matIndex; }
      count += 3;
    }
    flush();

    // UV Mapping
    merged.computeBoundingBox();
    const x0 = merged.boundingBox!.min.x; 
    const dxU = merged.boundingBox!.max.x - merged.boundingBox!.min.x;
    
    // Y-Range is 0 to Height.
    const y0 = merged.boundingBox!.min.y;
    const dyU = merged.boundingBox!.max.y - merged.boundingBox!.min.y;
    
    const uvArr = new Float32Array(pos.count * 2);
    const centerX = (minX + maxX) / 2;
    
    for (let i = 0; i < pos.count; i += 3) {
      const z0 = pos.getZ(i), z1 = pos.getZ(i+1);
      const isCap = (Math.abs(z0 - zFront) <= zTol && Math.abs(z1 - zFront) <= zTol) ||
                    (Math.abs(z0 - zBack) <= zTol && Math.abs(z1 - zBack) <= zTol);
      
      if (isCap) {
        for (let j = 0; j < 3; j++) {
          const u = (pos.getX(i+j) - x0) / dxU;
          // Invert V: Visual Top (Y=0) -> Texture Top (V=1).
          const v = 1 - (pos.getY(i+j) - y0) / dyU; 
          uvArr[2 * (i+j)] = u;
          uvArr[2 * (i+j)+1] = v;
        }
      } else {
        for (let j = 0; j < 3; j++) {
          const px = pos.getX(i+j);
          const py = pos.getY(i+j);
          const pz = pos.getZ(i+j);
          // Restore original absolute SVG Y for correct outline perimeter mapping
          const originalSvgY = py + minY;
          const s = nearestS(px + centerX, originalSvgY, outline.pts, outline.cum, outline.total);
          const t = (pz - zFront) / (zBack - zFront);
          uvArr[2 * (i+j)] = s;
          uvArr[2 * (i+j)+1] = t;
        }
      }
    }
    merged.setAttribute('uv', new THREE.BufferAttribute(uvArr, 2));

    // Stats
    const worldW = (maxX - minX) * Math.abs(scale) * sCore;
    const worldH = (bottomTarget_SV - minY) * Math.abs(scale) * sCore;
    const worldPerim = outline.total * Math.abs(scale) * sCore;
    const worldDepth = Math.abs(depth * scale);

    // Group Scale: [S, -S, S] to align with SVG Coordinate System (Y-Down)
    const finalScale: [number, number, number] = [scale * sCore, -scale * sCore, scale];

    // --- CHILD WRAPPER POSITION ---
    // We offset the wrapper by the exact inverse of the Geometry Translation.
    // This sets the Wrapper's Origin (0,0) to coincide with the SVG Document Origin (0,0).
    const wrapperX = -(minX + maxX) / 2;
    const wrapperY = -minY; 
    const wrapperZ = depth / 2 + 0.05;

    return {
      geometries: [merged],
      dims: { worldW, worldH, worldPerim, worldDepth },
      meshScale: finalScale,
      apiData: {
        frontZ: depth / 2,
        unitsPerMeter: 1 / Math.max(EPS, scale * sCore),
        version: Math.random(),
        worldWidth: worldW,
        worldHeight: worldH
      },
      childWrapperPos: [wrapperX, wrapperY, wrapperZ] as [number, number, number]
    };
  }, [svgData, depth, bevel, scale, targetWidth, targetHeight, preserveTop]);

  // 4. Update Texture Repeats
  useLayoutEffect(() => {
    if (!dims) return;
    const usePhysical = autoRepeat || tileSize != null || sideTileSize != null;
    const faceTile = tileSize ?? 0.1;
    const sideTile = sideTileSize ?? faceTile;
    const repFaceX = usePhysical ? Math.max(1, dims.worldW / faceTile) : (faceRepeatX ?? 6);
    const repFaceY = usePhysical ? Math.max(1, dims.worldH / faceTile) : (faceRepeatY ?? 6);
    const repSideX = usePhysical ? Math.max(1, dims.worldPerim / sideTile) : (sideRepeatX ?? 8);
    const repSideY = usePhysical ? Math.max(1, dims.worldDepth / sideTile) : (sideRepeatY ?? 1);

    clonedFaceMap.repeat.set(repFaceX, repFaceY);
    clonedSideMap.repeat.set(repSideX, repSideY);
    clonedFaceMap.needsUpdate = true;
    clonedSideMap.needsUpdate = true;
  }, [dims, autoRepeat, tileSize, sideTileSize, faceRepeatX, faceRepeatY, sideRepeatX, sideRepeatY, clonedFaceMap, clonedSideMap]);

  // 5. Materials
  const materials = useMemo(() => {
    const common = {
      roughness: 0.15,
      metalness: 0.1,
      color: new THREE.Color(0xffffff),
      side: doubleSided ? THREE.DoubleSide : THREE.FrontSide,
      envMapIntensity: 1.5,
    };
    return [
      new THREE.MeshStandardMaterial({ ...common, map: clonedFaceMap }),
      new THREE.MeshStandardMaterial({ ...common, map: clonedSideMap })
    ];
  }, [clonedFaceMap, clonedSideMap, doubleSided]);

  const meshRef = useRef<THREE.Mesh>(null!);
  const groupRef = useRef<THREE.Group>(null!);
  
  const [isReady, setIsReady] = useState(false);
  useLayoutEffect(() => { setIsReady(true); }, []);

  useImperativeHandle(ref, () => groupRef.current);

  const childApi = useMemo(() => ({
    group: groupRef,
    mesh: meshRef,
    frontZ: apiData?.frontZ ?? 0,
    unitsPerMeter: apiData?.unitsPerMeter ?? 100,
    version: apiData?.version ?? 0,
    worldWidth: apiData?.worldWidth ?? 1,
    worldHeight: apiData?.worldHeight ?? 1
  }), [apiData, isReady]);

  if (!geometries.length || !dims) return null;

  return (
    <group ref={groupRef} scale={meshScale}>
      {geometries.map((geom, i) => (
        <mesh
          key={`hs-${i}`}
          ref={i === 0 ? meshRef : undefined}
          geometry={geom}
          material={materials}
          castShadow
          receiveShadow
          {...meshProps}
        >
          {showEdges && <Edges scale={1.002} threshold={15} color="white" />}
        </mesh>
      ))}

      {/* Children Wrapper aligned to Absolute SVG Coordinates */}
      <group position={childWrapperPos}>
         {typeof children === 'function' && children(childApi, selectedAdditions)}
      </group>
    </group>
  );
});

SvgHeadstone.displayName = 'SvgHeadstone';

export default SvgHeadstone;