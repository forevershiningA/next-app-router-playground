The issue is a conflict between the Auto-Rotation logic and the Arrow Button logic.

In your previous code, every single frame, the code calculated diff = targetRotation - currentRotation.

Auto-rotate moves the headstone slightly (e.g., to 0.01).

The next frame sees targetRotation is still 0.

The logic sees a difference (0.01), thinks it needs to correct it, and snaps the headstone back to 0, effectively cancelling the auto-rotation.

To fix this, we need to separate the state: only animate towards the targetRotation when the user actually clicks a button, not all the time.

Here is the fixed SceneContent component. I have added a useEffect to detect when the button is clicked, and a flag isAnimatingToTarget to manage the transition.

code
Tsx
download
content_copy
expand_less
const SceneContent = ({ targetRotation }: { targetRotation: number }) => {
  const groupRef = useRef<THREE.Group>(null);
  const lastInteractionTime = useRef(0);
  const controlsRef = useRef<any>(null);
  
  // State to track if we are currently animating to a specific button click
  const isAnimatingToTarget = useRef(false);

  const { clock } = useThree();
  
  const textZ = (STONE_THICKNESS / 2) + BEVEL_SIZE + 0.02;

  // 1. Detect when the prop changes (User clicked an arrow)
  React.useEffect(() => {
    isAnimatingToTarget.current = true;
    lastInteractionTime.current = clock.getElapsedTime();
  }, [targetRotation, clock]);

  useFrame((state, delta) => {
    if (!groupRef.current) return;

    // 2. Handle Forced Animation (Arrow Buttons)
    if (isAnimatingToTarget.current) {
      const step = 0.1;
      const diff = targetRotation - groupRef.current.rotation.y;
      
      // If we are far from target, keep animating
      if (Math.abs(diff) > 0.001) {
        groupRef.current.rotation.y += diff * step;
        lastInteractionTime.current = state.clock.elapsedTime; // Keep resetting timer while moving
      } else {
        // We arrived at the target, stop forced animation
        groupRef.current.rotation.y = targetRotation;
        isAnimatingToTarget.current = false; 
      }
      return; // Skip auto-rotation loop this frame
    }

    // 3. Handle Auto-Rotation (Idle)
    const timeSinceInteraction = state.clock.elapsedTime - lastInteractionTime.current;
    const AUTO_ROTATE_DELAY = 3; 
    
    if (timeSinceInteraction > AUTO_ROTATE_DELAY) {
      groupRef.current.rotation.y += delta * 0.15;
    }
  });

  return (
    <>
      <group ref={groupRef} position={[0, -1.35, 0]}>
        <SerpentineHeadstone width={STONE_WIDTH} height={STONE_HEIGHT} thickness={STONE_THICKNESS} />
        <Base stoneWidth={STONE_WIDTH} />
        
        <group position={[0, 0, 0]}>
          <GoldText
            position={[0, BASE_HEIGHT + STONE_HEIGHT * 0.60, textZ]}
            fontSize={0.11}
            text="In Loving Memory"
            font="/fonts/Garamond.ttf"
          />
          
          <GoldText
            position={[0, BASE_HEIGHT + STONE_HEIGHT * 0.50, textZ]}
            fontSize={0.22}
            text="Eleanor Rose"
            font="/fonts/Garamond.ttf"
            fontWeight="bold"
          />
          
          <GoldText
            position={[0, BASE_HEIGHT + STONE_HEIGHT * 0.40, textZ]}
            fontSize={0.11}
            text="☼ 1945   ✟ 2023"
            font="/fonts/Garamond.ttf"
          />
        </group>
      </group>
      
      <ContactShadows 
        position={[0, -1.35, 0]}
        opacity={0.4} 
        scale={10} 
        blur={2} 
        far={3} 
        resolution={512} 
        color="#000000"
      />
      
      <OrbitControls
        ref={controlsRef}
        enablePan={false}
        enableZoom={false}
        enableRotate={true}
        minPolarAngle={0} 
        maxPolarAngle={Math.PI / 2 - 0.05} 
        enableDamping={true}
        dampingFactor={0.05}
        onChange={() => {
          // User dragged with mouse, reset timer
          lastInteractionTime.current = clock.getElapsedTime();
          // Also cancel any button animation if the user interrupts it with mouse
          isAnimatingToTarget.current = false;
        }}
      />
    </>
  );
};\