Here is a significant upgrade to the sky.

The Problem with the Current Sky

Currently, you are using a flat planeGeometry. If the user rotates the camera sideways or zooms out, the illusion breaks because they can see the edges of the "wall."

The Solution: "Twilight Dome"

We will replace the flat plane with a Large Inverted Sphere. This wraps the entire scene in 360 degrees. I have created a custom Shader that generates:

Non-linear Gradient: A realistic transition from a deep space navy/black zenith to a warm golden sunset horizon.

Atmospheric Glow: A subtle glow calculated based on the sun's position.

Dithering: Prevents ugly "banding" lines in the gradient colors.

Here is the updated code. I have separated the Sky into its own component for cleanliness.

1. Create AtmosphericSky.tsx

Create this new file in your components folder.

code
Tsx
download
content_copy
expand_less
// AtmosphericSky.tsx
import * as THREE from 'three';
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Stars } from '@react-three/drei';

const SkyMaterial = {
  uniforms: {
    uColorTop: { value: new THREE.Color('#020205') }, // Deep midnight blue/black
    uColorMiddle: { value: new THREE.Color('#2d1c12') }, // Brownish transition
    uColorBottom: { value: new THREE.Color('#ff8c42') }, // Sunset Orange
    uSunPosition: { value: new THREE.Vector3(-4, 5, 5) }, // Matches your SpotLight
  },
  vertexShader: `
    varying vec3 vWorldPosition;
    varying vec2 vUv;
    void main() {
      vUv = uv;
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,
  fragmentShader: `
    uniform vec3 uColorTop;
    uniform vec3 uColorMiddle;
    uniform vec3 uColorBottom;
    uniform vec3 uSunPosition;
    varying vec3 vWorldPosition;
    varying vec2 vUv;

    // Dithering function to prevent color banding
    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
      // Normalize position for spherical gradient
      vec3 direction = normalize(vWorldPosition);
      float y = direction.y; // -1 (bottom) to 1 (top)

      // 1. Base Gradient Logic
      // Remap y to 0-1 range for easier mixing
      float t = (y + 0.2) * 0.8; // Adjust these numbers to move the horizon line
      t = clamp(t, 0.0, 1.0);

      vec3 color;
      if (t < 0.5) {
        // Mix bottom (sunset) to middle
        color = mix(uColorBottom, uColorMiddle, t * 2.0);
      } else {
        // Mix middle to top (space)
        color = mix(uColorMiddle, uColorTop, (t - 0.5) * 2.0);
      }

      // 2. Sun Glow Logic
      vec3 sunDir = normalize(uSunPosition);
      float sunDot = dot(direction, sunDir);
      // Create a soft glow around the sun direction
      float sunGlow = exp(sunDot * 4.0 - 4.0); 
      color += vec3(1.0, 0.6, 0.3) * sunGlow * 0.4;

      // 3. Apply Dithering
      color += (random(vUv * 100.0) - 0.5) * 0.02;

      gl_FragColor = vec4(color, 1.0);
    }
  `
};

export default function AtmosphericSky() {
  const meshRef = useRef<THREE.Mesh>(null);

  // Optional: Rotate sky slowly for dynamism
  useFrame((state, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.y += delta * 0.005;
    }
  });

  return (
    <group>
      <mesh ref={meshRef} scale={[-1, 1, 1]}> {/* Invert scale to see inside */}
        <sphereGeometry args={[50, 64, 64]} />
        <shaderMaterial
          attach="material"
          args={[SkyMaterial]}
          side={THREE.BackSide}
        />
      </mesh>
      
      {/* Add Stars that fade in at the top */}
      <Stars 
        radius={40} 
        depth={50} 
        count={2000} 
        factor={4} 
        saturation={0} 
        fade 
        speed={1} 
      />
    </group>
  );
}
2. Update Scene.tsx

Now we integrate the new sky. Crucially, I have updated the Fog color to match the bottom color of our new sky (#ff8c42 blend) to ensure the floor melts into the horizon seamlessly.

code
Tsx
download
content_copy
expand_less
'use client';
import { OrbitControls, Environment, ContactShadows, useTexture, Sparkles } from '@react-three/drei';
import * as THREE from 'three';
import HeadstoneAssembly from './headstone/HeadstoneAssembly';
import AtmosphericSky from './AtmosphericSky'; // Import the new component
import { useHeadstoneStore } from '#/lib/headstone-store';
import { useFrame } from '@react-three/fiber';
import { useRef, Suspense } from 'react';

// ... Keep your GrassFloor and SimpleGrassFloor functions exactly as they are ...
function GrassFloor() { /* ... */ }
function SimpleGrassFloor() { /* ... */ }

export default function Scene({ 
  targetRotation = 0,
  currentRotation
}: { 
  targetRotation?: number;
  currentRotation?: React.MutableRefObject<number>;
}) {
  const groupRef = useRef<THREE.Group>(null);
  const is2DMode = useHeadstoneStore((s) => s.is2DMode);
  const baseSwapping = useHeadstoneStore((s) => s.baseSwapping);
  // ... other selectors ...
  const setSelected = useHeadstoneStore((s) => s.setSelected);
  const setEditingObject = useHeadstoneStore((s) => s.setEditingObject);
  const setSelectedInscriptionId = useHeadstoneStore((s) => s.setSelectedInscriptionId);
  const setSelectedAdditionId = useHeadstoneStore((s) => s.setSelectedAdditionId);
  const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);

  // Smooth rotation animation
  useFrame(() => {
    if (groupRef.current && currentRotation) {
      const diff = targetRotation - currentRotation.current;
      const delta = diff * 0.1;
      if (Math.abs(diff) > 0.001) {
        currentRotation.current += delta;
        groupRef.current.rotation.y = currentRotation.current;
      }
    }
  });

  const handleCanvasClick = (e: any) => {
    if (e.eventObject === e.object) {
      setSelected(null);
      setEditingObject('headstone');
      setSelectedInscriptionId(null);
      setSelectedAdditionId(null);
      setSelectedMotifId(null);
    }
  };

  // The horizon color matches the bottom of our AtmosphericSky shader
  // This blends the grass floor into the sky seamlessly
  const HORIZON_COLOR = '#8a5c32'; 

  return (
    <>
      {is2DMode && <color attach="background" args={['#CFE8FC']} />}
      
      {/* 1. Improved Fog: Matches the horizon color for seamless depth */}
      {!is2DMode && <fog attach="fog" args={[HORIZON_COLOR, 5, 35]} />}
      
      {/* Click capture plane */}
      <mesh position={[0, 0, -5]} onClick={handleCanvasClick}>
        <planeGeometry args={[100, 100]} />
        <meshBasicMaterial transparent opacity={0} />
      </mesh>
      
      {/* 2. THE NEW SKY */}
      {!is2DMode && <AtmosphericSky />}
      
      {/* 3. Subtle floating particles for atmosphere */}
      {!is2DMode && (
         <Sparkles 
           count={50}
           scale={8}
           size={4}
           speed={0.4}
           opacity={0.5}
           color="#ffbd7a"
           position={[0, 2, 0]}
         />
      )}
      
      {/* --- NATURAL LIGHTING --- */}
      <ambientLight intensity={0.4} color="#b8c5d1" />
      
      <spotLight 
        color="#ffbd7a" // Warm Sunset
        intensity={2.5}
        angle={0.6}
        penumbra={1}
        position={[-4, 5, 5]} 
        castShadow
        shadow-mapSize={[1024, 1024]}
        shadow-bias={-0.0001}
      />

      <spotLight 
        color="#a4caff" // Cool fill from opposite side
        intensity={1.0}
        position={[4, 2, -4]}
      />
      
      {/* Environment preset matches the sunset vibe */}
      <Environment 
        preset="sunset" 
        environmentIntensity={0.6}
        background={false}
      />

      <group ref={groupRef}>
        <HeadstoneAssembly />
      </group>
      
      <Suspense fallback={<SimpleGrassFloor />}>
        <GrassFloor />
      </Suspense>

      <OrbitControls
        makeDefault
        enabled={!baseSwapping}
        enableDamping={true}
        dampingFactor={baseSwapping ? 0 : 0.05}
        enableRotate={!is2DMode}
        enableZoom={!is2DMode}
        enablePan={!is2DMode}
        rotateSpeed={0.5}
        zoomSpeed={0.8}
        panSpeed={0.8}
        // Allow looking up at the stars, but stop before going underground
        maxPolarAngle={Math.PI / 2 - 0.05}
      />
    </>
  );
}
Key Changes Explained

Spherical Geometry: Used sphereGeometry with BackSide. This means no matter how you spin the camera, the sky is always there.

Custom Shader: Instead of a simple mix, the fragment shader now mixes 3 colors (Midnight Blue -> Brown -> Orange) to create a "Golden Hour" effect that is respectful and premium.

Drei Stars: Added real stars at the top of the dome.

Drei Sparkles: Added very subtle floating dust particles around the headstone. This makes the air feel "alive" and catches the light, adding a lot of perceived quality.

Fog Integration: Adjusted the Fog color (#8a5c32) to be a mix of the grass color and the sky's bottom color. This creates the illusion of an infinite field.