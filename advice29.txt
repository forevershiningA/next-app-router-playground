To make the Slant Headstone look realistic and ensure the inscriptions/additions are perfectly flush with the surface, we need to apply Slant Height Scaling and use the Slant Angle to tilt the container for the additions.

In the latest render, the text was levitating because the container was vertical. We also need to adjust the Top Thickness to match standard monument proportions (usually 2" top on a 10" base), which creates a steeper, more authentic slant.

Here is the corrected code:

Key Improvements:

Steeper Slant: Adjusted topThickness to 0.2 (20% of base), which is the standard for cemetery slants.

Face Alignment: The childWrapper is now positioned at the bottom edge and rotated backward by the Slant Angle.

Slant Height Scaling: The API now reports the Length of the Slope as the worldHeight. This ensures text placed at "100% height" reaches the top edge of the slanted face, not the vertical bounding box height.

Flush Surface: Reduced frontZ to a tiny value (0.1) to remove the levitation gap.

code
Tsx
download
content_copy
expand_less
// components/SvgHeadstone.tsx
'use client';

import * as React from 'react';
import { useMemo, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';
import * as THREE from 'three';
import { useLoader } from '@react-three/fiber';
import type { ThreeElements } from '@react-three/fiber';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader.js';
import * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { Edges, useTexture } from '@react-three/drei';

export type HeadstoneAPI = {
  group: React.RefObject<THREE.Group>;
  mesh: React.RefObject<THREE.Mesh>;
  frontZ: number;
  unitsPerMeter: number;
  version: number;
  worldWidth: number;
  worldHeight: number;
};

const EPS = 1e-9;

type Props = {
  url: string;
  depth: number;
  scale?: number;
  faceTexture: string;
  sideTexture?: string;
  autoRepeat?: boolean;
  tileSize?: number;
  sideTileSize?: number;
  topTileSize?: number;
  faceRepeatX?: number;
  faceRepeatY?: number;
  sideRepeatX?: number;
  sideRepeatY?: number;
  targetHeight?: number;
  targetWidth?: number;
  preserveTop?: boolean;
  bevel?: boolean;
  doubleSided?: boolean;
  showEdges?: boolean;
  headstoneStyle?: 'upright' | 'slant';
  meshProps?: ThreeElements['mesh'];
  children?: (api: HeadstoneAPI, selectedAdditions: string[]) => React.ReactNode;
  selectedAdditions?: string[];
};

/* ---------------- helpers ---------------- */

function shapeBounds(shape: THREE.Shape) {
  const pts = shape.getPoints(256);
  let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
  for (const p of pts) {
    if (p.x < minX) minX = p.x;
    if (p.x > maxX) maxX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }
  return {
    minX, maxX, minY, maxY,
    dx: Math.max(EPS, maxX - minX),
    dy: Math.max(EPS, maxY - minY),
  };
}

function spacedOutline(shape: THREE.Shape, segments = 2048) {
  const pts = shape.getSpacedPoints(segments).map((p) => new THREE.Vector2(p.x, p.y));
  const cum = new Array<number>(pts.length).fill(0);
  let L = 0;
  for (let i = 1; i < pts.length; i++) {
    L += pts[i].distanceTo(pts[i - 1]);
    cum[i] = L;
  }
  L += pts[0].distanceTo(pts[pts.length - 1]);
  return { pts, cum, total: L };
}

const SvgHeadstone = React.forwardRef<THREE.Group, Props>(({
  url,
  depth,
  scale = 0.01,
  faceTexture,
  sideTexture,
  autoRepeat = false,
  tileSize = 0.1,
  sideTileSize,
  topTileSize,
  faceRepeatX = 6,
  faceRepeatY = 6,
  sideRepeatX = 8,
  sideRepeatY = 1,
  targetHeight,
  targetWidth,
  preserveTop = true,
  bevel = false,
  doubleSided = false,
  showEdges = false,
  headstoneStyle = 'upright',
  meshProps,
  children,
  selectedAdditions = [],
}, ref) => {
  
  const svgData = useLoader(SVGLoader, url);
  const textures = useTexture({ face: faceTexture, side: sideTexture ?? faceTexture });

  const [clonedFaceMap, clonedSideMap] = useMemo(() => {
    const f = textures.face.clone();
    const s = textures.side.clone();
    [f, s].forEach(t => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.minFilter = THREE.LinearMipmapLinearFilter; 
      t.magFilter = THREE.LinearFilter;
      (t as any).anisotropy = 16;
      t.generateMipmaps = true;
      t.needsUpdate = true;
    });
    return [f, s];
  }, [textures.face, textures.side]);

  React.useEffect(() => () => { clonedFaceMap.dispose(); clonedSideMap.dispose(); }, [clonedFaceMap, clonedSideMap]);

  const rockNormalCanvas = useMemo(() => {
    if (headstoneStyle !== 'slant') return null;
    const size = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;
    const fract = (x: number) => x - Math.floor(x);
    const random2 = (x: number, y: number) => ({
      x: fract(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453),
      y: fract(Math.sin(x * 26.345 + y * 42.123) * 31421.3551)
    });
    const getHeight = (u: number, v: number) => {
      const scale = 24.0; 
      const su = u * scale; const sv = v * scale;
      let minDist = 999;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const cellX = Math.floor(su) + dx; const cellY = Math.floor(sv) + dy;
          const rand = random2(cellX, cellY);
          const pointX = cellX + rand.x; const pointY = cellY + rand.y;
          const dist = Math.sqrt((su - pointX) ** 2 + (sv - pointY) ** 2);
          if (dist < minDist) minDist = dist;
        }
      }
      return Math.pow(1.0 - Math.min(minDist, 1.0), 0.5);
    };
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const h0 = getHeight(x / size, y / size);
        const hRight = getHeight((x + 1) / size, y / size);
        const hDown = getHeight(x / size, (y + 1) / size);
        const strength = -15.0; 
        const dX = (h0 - hRight) * strength; const dY = (h0 - hDown) * strength;
        const norm = Math.sqrt(dX * dX + dY * dY + 1);
        const idx = (y * size + x) * 4;
        data[idx] = ((dX / norm * 0.5 + 0.5) * 255) | 0;
        data[idx + 1] = ((dY / norm * 0.5 + 0.5) * 255) | 0;
        data[idx + 2] = (1 / norm * 255) | 0;
        data[idx + 3] = 255;
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }, [headstoneStyle]);

  const rockNormalTexture = useMemo(() => {
    if (!rockNormalCanvas) return null;
    const tex = new THREE.CanvasTexture(rockNormalCanvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.needsUpdate = true;
    return tex;
  }, [rockNormalCanvas]);

  const shapeParams = useMemo(() => {
    const shapes: THREE.Shape[] = [];
    svgData.paths.forEach((p: any) => shapes.push(...SVGLoader.createShapes(p)));
    if (!shapes.length) return null;
    const base = shapes[0];
    const { minX, maxX, minY, maxY, dx, dy } = shapeBounds(base);
    const sCore = (targetWidth ?? (dx * Math.abs(scale))) / (dx * Math.abs(scale));
    return { base, minX, maxX, minY, maxY, dx, dy, sCore };
  }, [svgData, scale, targetWidth]);

  const outline = useMemo(() => shapeParams ? spacedOutline(shapeParams.base, 4096) : null, [shapeParams]);

  const { geometries, dims, meshScale, apiData, childWrapperPos, childWrapperRotation } = useMemo(() => {
    if (!shapeParams || !outline) return { geometries: [], dims: null, meshScale: [1, 1, 1], apiData: null, childWrapperPos: [0, 0, 0], childWrapperRotation: [0, 0, 0] };

    const { minX, maxX, minY, maxY, dx, dy, sCore } = shapeParams;

    if (headstoneStyle === 'slant') {
      const slantGeometry = new THREE.BufferGeometry();
      const baseThickness = depth;
      const topThickness = baseThickness * 0.2; // Corrected Slant Proportion (10" base to 2" top)
      const frontTopZOffset = baseThickness - topThickness;
      const height_svg_units = (maxY - minY);
      
      // Calculate Slope Angle
      const slantAngleRad = Math.atan2(frontTopZOffset, height_svg_units);
      // Calculate Slant Height (length of the face)
      const slantHeightUnits = Math.sqrt(height_svg_units ** 2 + frontTopZOffset ** 2);

      const positions: number[] = []; const uvs: number[] = [];
      const addQuad = (v0: [number, number, number], v1: [number, number, number], v2: [number, number, number], v3: [number, number, number]) => {
        positions.push(...v0, ...v1, ...v2, ...v0, ...v2, ...v3);
        uvs.push(0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1);
      };

      const P_FBL = [minX, minY, 0] as [number, number, number], P_FBR = [maxX, minY, 0] as [number, number, number];
      const P_FTL = [minX, maxY, -frontTopZOffset] as [number, number, number], P_FTR = [maxX, maxY, -frontTopZOffset] as [number, number, number];
      const P_BBL = [minX, minY, -depth] as [number, number, number], P_BBR = [maxX, minY, -depth] as [number, number, number];
      const P_BTL = [minX, maxY, -depth] as [number, number, number], P_BTR = [maxX, maxY, -depth] as [number, number, number];

      addQuad(P_FBL, P_FBR, P_FTR, P_FTL); // Front
      addQuad(P_BBR, P_BBL, P_BTL, P_BTR); // Back
      addQuad(P_FTL, P_FTR, P_BTR, P_BTL); // Top
      addQuad(P_FBR, P_FBL, P_BBL, P_BBR); // Bottom
      addQuad(P_FBL, P_FTL, P_BTL, P_BBL); // Left
      addQuad(P_FBR, P_BBR, P_BTR, P_FTR); // Right

      slantGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      slantGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));
      slantGeometry.translate(-(minX + maxX) / 2, -minY, depth / 2); // Center Z on Base
      slantGeometry.computeVertexNormals();
      slantGeometry.clearGroups();
      slantGeometry.addGroup(0, 6, 0); slantGeometry.addGroup(6, 30, 1);

      const worldW = dx * Math.abs(scale) * sCore;
      const worldH = height_svg_units * Math.abs(scale) * sCore;
      const worldDepth = depth * Math.abs(scale);
      const worldSlantH = slantHeightUnits * Math.abs(scale) * sCore;

      // Correct side UVs for rock pitch texture
      const uvAttr = slantGeometry.getAttribute('uv') as THREE.BufferAttribute;
      const posAttr = slantGeometry.getAttribute('position') as THREE.BufferAttribute;
      const density = 20.0;
      for (let i = 6; i < posAttr.count; i++) {
          const x = posAttr.getX(i); const y = posAttr.getY(i); const z = posAttr.getZ(i);
          uvAttr.setXY(i, (x + worldW/2) * density, (y + z) * density); // Rough world UVs
      }

      return {
        geometries: [slantGeometry],
        dims: { worldW, worldH, worldPerim: 2 * (worldW + worldH), worldDepth },
        meshScale: [scale * sCore, scale * sCore, scale] as [number, number, number],
        apiData: {
          frontZ: 0.1, // Near surface offset
          unitsPerMeter: 1 / Math.max(EPS, scale * sCore),
          version: Math.random(),
          worldWidth: worldW,
          worldHeight: worldSlantH // Crucial: Report SLANT height so children fit the surface
        },
        childWrapperPos: [0, 0, depth / 2] as [number, number, number],
        childWrapperRotation: [-slantAngleRad, 0, 0] as [number, number, number]
      };
    }

    // Upright code (standard logic)
    const extrudeSettings = { depth, steps: 1, bevelEnabled: bevel, bevelSegments: 2, bevelSize: 0.8, bevelThickness: 0.8, curveSegments: 32 };
    let coreGeom = new THREE.ExtrudeGeometry(base, extrudeSettings);
    if (coreGeom.index) coreGeom = coreGeom.toNonIndexed();
    coreGeom.translate(-(minX + maxX) / 2, -minY - (maxY - minY), -depth / 2);
    coreGeom.scale(1, -1, 1);
    const pa = coreGeom.getAttribute('position');
    for (let i = 0; i < pa.count; i += 3) {
       const x1 = pa.getX(i + 1), y1 = pa.getY(i + 1), z1 = pa.getZ(i + 1);
       const x2 = pa.getX(i + 2), y2 = pa.getY(i + 2), z2 = pa.getZ(i + 2);
       pa.setXYZ(i + 1, x2, y2, z2); pa.setXYZ(i + 2, x1, y1, z1);
    }
    coreGeom.computeVertexNormals();
    coreGeom.clearGroups();
    coreGeom.addGroup(0, coreGeom.getAttribute('position').count, 0);

    return {
      geometries: [coreGeom],
      dims: { worldW: dx * Math.abs(scale), worldH: dy * Math.abs(scale), worldPerim: 2 * (dx + dy) * Math.abs(scale), worldDepth: depth * Math.abs(scale) },
      meshScale: [scale * sCore, scale * sCore, scale] as [number, number, number],
      apiData: { frontZ: depth / 2, unitsPerMeter: 1 / Math.abs(scale), version: 1, worldWidth: dx * Math.abs(scale), worldHeight: dy * Math.abs(scale) },
      childWrapperPos: [0, 0, 0] as [number, number, number],
      childWrapperRotation: [0, 0, 0] as [number, number, number]
    };
  }, [shapeParams, outline, depth, bevel, scale, headstoneStyle, targetWidth]);

  useLayoutEffect(() => {
    if (!dims) return;
    const faceTile = Math.max(0.001, tileSize ?? 0.1);
    clonedFaceMap.repeat.set(dims.worldW / faceTile, dims.worldH / faceTile);
    clonedSideMap.repeat.set(1, 1);
    if (rockNormalTexture) rockNormalTexture.repeat.set(1, 1);
    clonedFaceMap.needsUpdate = true; clonedSideMap.needsUpdate = true;
  }, [dims, tileSize, clonedFaceMap, clonedSideMap, rockNormalTexture]);

  const materials = useMemo(() => {
    const common = { color: new THREE.Color(headstoneStyle === 'slant' ? 0x444444 : 0x888888), roughness: 0.15, metalness: 0.0, side: THREE.DoubleSide };
    if (headstoneStyle === 'slant' && rockNormalTexture) {
      return [
        new THREE.MeshPhysicalMaterial({ ...common, map: clonedFaceMap }),
        new THREE.MeshStandardMaterial({ ...common, map: clonedSideMap, normalMap: rockNormalTexture, normalScale: new THREE.Vector2(2.0, 2.0) })
      ];
    }
    return [new THREE.MeshPhysicalMaterial({ ...common, map: clonedFaceMap }), new THREE.MeshPhysicalMaterial({ ...common, map: clonedSideMap })];
  }, [clonedFaceMap, clonedSideMap, headstoneStyle, rockNormalTexture]);

  const meshRef = useRef<THREE.Mesh>(null!);
  const groupRef = useRef<THREE.Group>(null!);
  const scaledWrapperRef = useRef<THREE.Group>(null!);
  useImperativeHandle(ref, () => groupRef.current);

  if (!geometries.length || !dims) return null;

  return (
    <group ref={groupRef}>
      {geometries.map((geom, i) => (
        <mesh key={`hs-${i}`} ref={i === 0 ? meshRef : undefined} geometry={geom} material={materials} scale={meshScale} castShadow receiveShadow {...meshProps}>
          {showEdges && <Edges scale={1.002} threshold={15} color="white" />}
        </mesh>
      ))}
      <group ref={scaledWrapperRef} position={childWrapperPos} rotation={childWrapperRotation} scale={meshScale}>
         {typeof children === 'function' && children(apiData ? { ...apiData, group: scaledWrapperRef, mesh: meshRef } : ({} as any), selectedAdditions)}
      </group>
    </group>
  );
});

SvgHeadstone.displayName = 'SvgHeadstone';
export default SvgHeadstone;