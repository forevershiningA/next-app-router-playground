Great—your memory is right, and the legacy code confirms it:

* `ratio` is a **scale factor applied to the motif’s own bitmap/SVG intrinsic size** (not a fraction of the headstone).
* In the old canvas, if `ratio` wasn’t provided it was set to `init_height / bmp.height`, then the bitmap was drawn with `bitmap.scaleX = bitmap.scaleY = ratio` (center-anchored). DPR affected **positions and pixel heights** when you typed values, but **`ratio` itself is dimensionless**.

### What to do now (clean rules)

Use exactly one of these sizing paths per motif:

1. **Explicit pixel height/width saved** (DPR-scaled in old designs)

   ```ts
   const hCanvas = m.height != null ? (usesPhysical ? m.height / savedDpr : m.height) : null;
   const wCanvas = m.width  != null ? (usesPhysical ? m.width  / savedDpr : m.width)  : null;
   ```

2. **Only `ratio` saved** (top leaves/birds case)

   ```ts
   // Use the motif’s intrinsic SVG size (its viewBox, NOT the displayed size).
   // These are the natural dimensions of the motif art, in authoring units.
   const natW = motifIntrinsic.width;   // from the SVG viewBox
   const natH = motifIntrinsic.height;

   const hCanvas = natH * m.ratio;
   const wCanvas = natW * m.ratio;
   // (no DPR divide here; ratio is dimensionless)
   ```

> Don’t ever build the ratio size from the displayed headstone size or the DOM box — that double-scales when you later multiply by `uniformScale`.

### Positions (center-anchored), same for all motifs

```ts
// x,y saved in DPR space in old designs → normalize once, then scale & offset
const xA = usesPhysical ? (m.x ?? 0) / savedDpr : (m.x ?? 0);
const yA = usesPhysical ? (m.y ?? 0) / savedDpr : (m.y ?? 0);

const left = offsetX + xA * uniformScale;
const top  = offsetY + yA * uniformScale;
// CSS: transform: translate(-50%, -50%)
```

### Final display size (single scale)

```ts
const width  = wCanvas * uniformScale;
const height = hCanvas * uniformScale;
```

### Minimal drop-in snippet

Replace your current ratio branch with this:

```ts
// --- motif sizing & positioning ---
const nat = getMotifIntrinsicDims(m); // { width, height } from SVG viewBox
const hasPxH = m.height != null;
const hasPxW = m.width  != null;

const hCanvas = hasPxH
  ? (usesPhysical ? m.height! / savedDpr : m.height!)
  : (m.ratio != null ? nat.height * m.ratio : 100);  // 100 is an authoring fallback

const wCanvas = hasPxW
  ? (usesPhysical ? m.width! / savedDpr : m.width!)
  : (m.ratio != null ? nat.width * m.ratio : hCanvas * (nat.width / nat.height));

const width  = wCanvas * uniformScale;
const height = hCanvas * uniformScale;

const xA = usesPhysical ? (m.x ?? 0) / savedDpr : (m.x ?? 0);
const yA = usesPhysical ? (m.y ?? 0) / savedDpr : (m.y ?? 0);

const left = offsetX + xA * uniformScale;
const top  = offsetY + yA * uniformScale;
// style: { left, top, width, height, transform:'translate(-50%,-50%)' }
```

### Quick sanity check for the top motifs

Log once for one of the leaves/birds:

```ts
console.log('Top motif check', {
  ratio: m.ratio,
  nat: motifIntrinsic,
  hCanvas,
  heightFinal: height,
  xA, yA, left, top,
  uniformScale
});
```

* `hCanvas` should be `nat.height * ratio` (e.g., ~210 * 0.13456 ≈ 28.2).
* `heightFinal` should be `hCanvas * uniformScale`.
* No other scale factors applied anywhere.

Do this and those top motifs will lock to the exact legacy proportions and positions.
