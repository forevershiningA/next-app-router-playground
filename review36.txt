Good news: layout math is almost there. Two things are still keeping the motifs small (and the top trio slightly “off”):

## 1) Use a single, legacy-faithful size path for motifs

Right now the render path can mix **ratio** with **viewBox-based** math and occasionally an explicit `width/height`, which ends up *shrinking* the result (and sometimes scaling twice).

**Lock it to one rule:**

* If a motif has `ratio`, treat it as **fraction of the tablet height**.
* Convert **once** from canvas-units → pixels with `uniformScale`.
* Only DPR-normalize when an explicit pixel `width/height` was saved.

```ts
// Size
const ratio = Number(motif.ratio ?? 0);

// 1) Height in canvas units
const hCanvas =
  ratio > 0
    ? initH * ratio                                  // ✅ legacy meaning
    : typeof motif.height === 'number'
      ? (usesPhys ? motif.height / savedDpr : motif.height)
      : 0;                                           // fallback handled below

// 2) Aspect from SVG viewBox for width
const dims = motifDimensions[motif.src || motif.name] ?? { width: 1, height: 1 };
const aspect = dims.height ? dims.width / dims.height : 1;

const wCanvas =
  typeof motif.width === 'number'
    ? (usesPhys ? motif.width / savedDpr : motif.width)
    : hCanvas * aspect;

// 3) Final pixels (scale ONCE)
const heightPx = hCanvas * uniformScale;
const widthPx  = wCanvas * uniformScale;
```

If a particular motif still looks tiny after this, check whether it actually has an explicit `height/width` saved in the JSON; if yes, you’ll go through the `px / savedDpr` branch instead of `ratio`. (A quick `console.log({ ratio, motifH: motif.height, motifW: motif.width })` will tell you which path you’re taking.) 

## 2) Keep the wrapper un-flipped; apply flips only to the `<img>`

Your `DraggableElement` now puts the drag translate **before** the centering transform (good), but if you ever apply `scaleX/scaleY` on the wrapper, dragging can feel inverted again. Keep transforms like this:

```tsx
<DraggableElement initialStyle={{ /* position, left, top, translate(-50%, -50%) only */ }}>
  <img
    src={getMotifPath(motif)}
    alt={motif.name || 'motif'}
    style={{
      width: '100%',
      height: '100%',
      objectFit: 'contain',
      display: 'block',
      // flips and per-motif scaling live here, never on the wrapper:
      transform: `scale(${motif.scaleX ?? 1}, ${motif.scaleY ?? 1}) rotate(${motif.rotation ?? 0}deg)`,
      transformOrigin: 'center',
    }}
    onError={(e) => ((e.target as HTMLImageElement).src = getFallbackMotifPath(motif))}
  />
</DraggableElement>
```

## Quick sanity checks (log these once)

Drop this right before you set the style so you can see mis-scales instantly:

```ts
console.log('MOTIF',
  motif.name || motif.src,
  {
    ratio,
    initH,
    hCanvas_from_ratio: ratio ? initH * ratio : null,
    explicitPxH: motif.height ?? null,
    explicitPxW: motif.width ?? null,
    usedDpr: savedDpr,
    hPx_final: heightPx.toFixed(2),
    wPx_final: widthPx.toFixed(2),
    uniformScale,
    usesPhys
  }
);
```

You should see the top three motifs reporting `hCanvas_from_ratio = initH * ratio` and reasonable final pixel sizes (no second scaling).

---

### Why this fixes what you see

* Your example ratio (≈0.1346) is supposed to be “13.46% of tablet height.” Using `initH * ratio` reproduces the legacy canvas exactly; mixing in viewBox math or re-applying scale is what kept them small.
* Keeping flips on the `<img>` preserves intuitive drag (left goes left), which also matches the legacy behavior. 

If you want, paste your current motif size block and I’ll mark the exact lines to change.
