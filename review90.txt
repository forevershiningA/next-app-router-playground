Thanks for the screenshot—that tells us exactly what’s wrong:

1. **The stone is being fitted correctly** (square shape contained in a landscape canvas),
2. **but inscriptions/motifs are being scaled a second time**, and
3. **the granite image/fill isn’t inside the same transform as the stone path**, so it “sticks out” to the left.

Here’s the precise fix so the SVG matches the original screenshot layout.

---

## 1) One frame, one scale

Treat the **authoring canvas** as the only coordinate system for everything:

```ts
const CANVAS_W = init_width;   // e.g. 1126
const CANVAS_H = init_height;  // e.g. 561

// fit the *square* stone viewBox (vbW x vbH) into the authoring canvas:
const stoneScale = Math.min(CANVAS_W / vbW, CANVAS_H / vbH);
const stoneOffX  = (CANVAS_W - vbW * stoneScale) / 2;
const stoneOffY  = (CANVAS_H - vbH * stoneScale) / 2;
```

Render the whole scene in **one** `<svg>` whose `viewBox` is the **authoring canvas**:

```tsx
<div
  className="absolute"
  style={{
    left: offsetX,
    top:  offsetY,
    width:  CANVAS_W * uniformScale,
    height: CANVAS_H * uniformScale,
  }}
>
  <svg viewBox={`0 0 ${CANVAS_W} ${CANVAS_H}`} width="100%" height="100%">
    {/* 2) Place the STONE (shape + texture) in a group that receives the same contain-fit */}
    <g transform={`translate(${stoneOffX},${stoneOffY}) scale(${stoneScale})`}>
      {/* put BOTH the texture image (or pattern rect) AND the stone path(s) here */}
      {/* ... stone <image> / <rect fill="url(#granite)"> ... */}
      {/* ... stone outline path(s) ... */}
      {/* If you use a clipPath, apply it inside this group */}
    </g>

    {/* 3) All inscriptions/motifs go in authoring coordinates (no extra scaling) */}
    {/* Example text anchored by center: */}
    <text x={CANVAS_W/2 + rawX} y={CANVAS_H/2 + rawY}
          textAnchor="middle" dominantBaseline="middle"
          fontSize={fontPx /* authoring px, NOT multiplied by uniformScale */}
    >
      {label}
    </text>

    {/* Motif: give it width/height in authoring px; position by its center if you prefer */}
    <image
      href={motifSrc}
      x={cx - motifW/2}
      y={cy - motifH/2}
      width={motifW} height={motifH}
      preserveAspectRatio="xMidYMid meet"
    />
  </svg>
</div>
```

**Key rule:** *Do not multiply per-element sizes or positions by `uniformScale`.*
That outer DIV already scales the entire SVG 1:1 to screen. Multiplying again is what produced the giant, drifting text you see now. Remove any code that does `fontSize * uniformScale`, `motifW * uniformScale`, or `x/y * uniformScale` for SVG children. (Keep `uniformScale` only on the outer container.) 

---

## 2) Stop the granite “bar” on the left

That bar appears because the **texture `<image>`/pattern rect is not inside the same transform** as the stone outline. Move the texture element **inside** the same `<g transform="translate(...) scale(...)">` as the path (or clip it with the path in that group). Then the bitmap and the outline receive identical `translate+scale`, so no bleed.

If you use a pattern:

```xml
<defs>
  <pattern id="granite" patternUnits="userSpaceOnUse" width="{vbW}" height="{vbH}">
    <image href="/textures/..." x="0" y="0" width="{vbW}" height="{vbH}"/>
  </pattern>
</defs>
<g transform="translate(stoneOffX,stoneOffY) scale(stoneScale)">
  <path d="..." fill="url(#granite)"/>
</g>
```

*(Putting the `<path>` inside the transformed group is enough; you don’t need to scale the image separately if the pattern uses `userSpaceOnUse` sized to `vbW×vbH`.)*

---

## 3) Anchor text/motifs by center (to match authored data)

Your saved coordinates are center-relative. Use:

* `textAnchor="middle"` + `dominantBaseline="middle"` for text, and
* for motifs, set `x = cx - w/2`, `y = cy - h/2` (or wrap in a `<g transform="translate(cx,cy)">` and draw centered).

That removes all `translate(-50%,-50%)` CSS hacks and keeps transforms inside the SVG, so drag math stays honest. If you keep your `DraggableElement`, ensure it **doesn’t** add a second scale on top of the SVG—only a pure translate is OK. 

---

### Why this fixes your screenshot

* **Same frame for everyone:** stone, text, motifs all live in `0..CANVAS_W × 0..CANVAS_H`.
* **No double-scaling:** per-element sizes aren’t multiplied by `uniformScale`; the outer box handles screen scaling.
* **Texture locked to outline:** the bitmap sits in the same translated/scaled group, so no left bleed.

Apply those three changes and your render will match the original landscape screenshot exactly.
