Got it — two things are happening:

1. the base width is being allowed to exceed the tablet by too much,
2. it’s being positioned *at* the tablet’s bottom rather than *under* it, so it overlaps.

Below is a drop-in patch you can apply in **DesignPageClient.tsx** where you size/position the base. It:

* derives a single px/mm from the tablet **width** (isotropic),
* reads base length/height from the saved design when present, with safe fallbacks,
* caps base width to **+2%** over tablet (so it can’t be “too wide”),
* tucks the base **under** the tablet by a small overlap (8 px) and auto-grows the overlay height so the base never covers the headstone.

> This fixes both “too wide” and “covering headstone” in your current preview. 

---

### Patch

```ts
// === 1) Isotropic px/mm from tablet WIDTH
const pxPerMm = stoneW / tabletWidthMm; // use width only

// === 2) Pull base dims from JSON with safe fallbacks
const baseItem =
  (designData || []).find(
    (it: any) => /base/i.test(`${it.type} ${it.name ?? ''} ${it.label ?? ''}`)
  ) ?? {};

const lenCandidates = [
  Number(baseItem.length_mm),
  Number(baseItem.length),
  Number(baseItem.width_mm),
  Number(baseItem.width),
  Number(baseItem.size?.length_mm),
  Number(baseItem.size?.width_mm),
];
// avoid thickness fields (e.g., 60–120 mm); pick largest plausible length
const baseLenMm = lenCandidates
  .filter(v => Number.isFinite(v) && v >= 300)
  .sort((a,b) => b - a)[0];

const htCandidates = [
  Number(baseItem.height_mm),
  Number(baseItem.height),
  Number(baseItem.size?.height_mm),
  Number(baseItem.thickness_mm),
];
const baseHtMm = htCandidates
  .filter(v => Number.isFinite(v) && v >= 50 && v <= 200)[0];

// gentle default if JSON missing
const defaultOverhangEachSideMm = 15; // small overhang per side
const lengthMm = Number.isFinite(baseLenMm)
  ? baseLenMm
  : (tabletWidthMm + 2 * defaultOverhangEachSideMm);

const heightMm = Number.isFinite(baseHtMm) ? baseHtMm : 90;

// convert to px
let baseWpx = Math.round(lengthMm * pxPerMm);
const baseHpx = Math.round(heightMm * pxPerMm);

// === 3) Clamp width so it can’t look “too wide”
const maxW = Math.round(stoneW * 1.02); // +2% cap
baseWpx = Math.min(baseWpx, maxW);

// === 4) Place base UNDER the tablet and expand canvas if needed
// from buildTopProfile we have offY/drawH -> tablet bounding box
const stoneBottomPx = Math.round((topProfile?.offY ?? 0) + (topProfile?.drawH ?? stoneH));
const overlapPx = 8; // small tuck under the tablet face
const baseTopPx = stoneBottomPx - overlapPx;

// ensure the preview container is tall enough
const requiredH = baseTopPx + baseHpx + 12; // 12px breathing room
if (overlayH < requiredH) {
  overlayRef.current!.style.height = `${requiredH}px`;
}

// row that holds the base (full-width, centered)
const baseRowStyle: React.CSSProperties = {
  position: 'absolute',
  left: 0,
  top: baseTopPx,
  width: overlayW,
  height: baseHpx,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'flex-start',
  pointerEvents: 'none',
  zIndex: 25,
};

// actual base “slab”
const baseStyle: React.CSSProperties = {
  width: baseWpx,
  height: baseHpx,
  backgroundImage: `url(${baseTextureUrl})`,
  backgroundSize: 'cover',
  backgroundPosition: 'center',
};
```

And in the JSX, keep the base stacked **after** the tablet so it renders below:

```tsx
{/* Tablet / inscriptions / motifs ... */}

{/* Base row */}
<div style={baseRowStyle}>
  <div style={baseStyle} />
</div>
```

#### Why this works

* Using **width-based** px/mm prevents aspect drift that was making the base too wide.
* The **+2% cap** guarantees visual parity with the original screenshot.
* Positioning from `stoneBottomPx` and adding **required height** to the overlay keeps the base under the tablet—never covering it.

If you want a touch more overhang like the reference photo, bump `maxW` to `stoneW * 1.04` and/or `defaultOverhangEachSideMm` to 20.
