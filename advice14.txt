This is a comprehensive and well-structured SvgHeadstone component for Three.js, addressing several advanced concerns like proper UV mapping, material groups, and even a custom normal map for a "rock pitch" effect.

The most significant change to make your headstone look like a slant headstone has already been implemented: the headstoneStyle === 'slant' block. However, the current implementation of the slant headstone is a very simple rectangular prism with a slanted top face.

To achieve the look of the reference image, which shows a typical slant headstone (where the front face is angled), we need to modify the geometry generation for the 'slant' style.

Here's my advice, focusing on making the "slant" style truly a slant headstone as seen in your reference:

Key Advice for Slant Headstone Geometry (The Main Change)

The current "slant" geometry generation is creating a simple box where only the top face is slanted. A real slant headstone (like your reference image) has a front face that slants backward from base to top, and the back face is typically vertical, or also slightly slanted.

To achieve this, the core geometry construction needs to change for headstoneStyle === 'slant':

Front Face Slant: The key characteristic of a slant headstone is that its front surface is not vertical but angles backward. This means the top edge of the front face is set further back (negative Z) than its bottom edge.

Back Face: The back face is usually vertical or has a slight inward slant, often with a "rock pitch" finish.

Overall Shape: The resulting shape is a trapezoidal prism (looking from the side).

Here's a detailed breakdown of how to modify the slant geometry block:

code
TypeScript
download
content_copy
expand_less
// FOR SLANT: Create trapezoidal prism geometry
    if (headstoneStyle === 'slant') {
      const slantGeometry = new THREE.BufferGeometry();
      
      // Define the slant angle for the front face (e.g., 60-75 degrees from horizontal, or 15-30 degrees from vertical)
      const frontSlantAngleRad = 15 * Math.PI / 180; // Angle from the vertical plane, 0 means vertical, positive means slanting back
      
      // Calculate the back-offset for the top edge of the front face
      const frontSlantOffsetZ = (maxY - minY) * Math.tan(frontSlantAngleRad);

      // Define vertices (NON-INDEXED for proper UV mapping)
      const positions: number[] = [];
      const uvs: number[] = [];
      const normals: number[] = []; // We will compute this later
      
      // Helper to add a quad (2 triangles)
      const addQuad = (
        v0: [number, number, number], v1: [number, number, number],
        v2: [number, number, number], v3: [number, number, number],
        uv0: [number, number], uv1: [number, number],
        uv2: [number, number], uv3: [number, number]
      ) => {
        positions.push(...v0, ...v1, ...v2); // Triangle 1: v0, v1, v2
        uvs.push(...uv0, ...uv1, ...uv2);
        positions.push(...v0, ...v2, ...v3); // Triangle 2: v0, v2, v3
        uvs.push(...uv0, ...uv2, ...uv3);
      };

      // Define the key points for the shape
      // Front bottom edge
      const p_fb_L = new THREE.Vector3(minX, minY, 0); // Front Bottom Left
      const p_fb_R = new THREE.Vector3(maxX, minY, 0); // Front Bottom Right
      
      // Front top edge (slanted back)
      const p_ft_L = new THREE.Vector3(minX, maxY, -frontSlantOffsetZ); // Front Top Left
      const p_ft_R = new THREE.Vector3(maxX, maxY, -frontSlantOffsetZ); // Front Top Right

      // Back bottom edge (aligned with front bottom)
      const p_bb_L = new THREE.Vector3(minX, minY, -depth); // Back Bottom Left
      const p_bb_R = new THREE.Vector3(maxX, minY, -depth); // Back Bottom Right
      
      // Back top edge (vertical back, so same Z as back bottom)
      // If you want the back face to also slant, adjust this Z coordinate
      const p_bt_L = new THREE.Vector3(minX, maxY, -depth); // Back Top Left
      const p_bt_R = new THREE.Vector3(maxX, maxY, -depth); // Back Top Right


      // FRONT FACE (polished) - Uses texture group 0
      // Vertices are p_fb_L, p_fb_R, p_ft_R, p_ft_L
      addQuad(
        p_fb_L.toArray(), p_fb_R.toArray(),
        p_ft_R.toArray(), p_ft_L.toArray(),
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs for texture
      );
      
      // BACK FACE (rock pitch) - Uses texture group 1
      // Vertices are p_bb_R, p_bb_L, p_bt_L, p_bt_R
      addQuad(
        p_bb_R.toArray(), p_bb_L.toArray(),
        p_bt_L.toArray(), p_bt_R.toArray(),
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs for texture
      );
      
      // BOTTOM FACE (rock pitch) - Uses texture group 1
      // Vertices are p_fb_L, p_bb_L, p_bb_R, p_fb_R
      addQuad(
        p_fb_L.toArray(), p_bb_L.toArray(),
        p_bb_R.toArray(), p_fb_R.toArray(),
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs for texture
      );
      
      // TOP FACE (rock pitch, horizontal, connecting front top to back top) - Uses texture group 1
      // Vertices are p_ft_L, p_bt_L, p_bt_R, p_ft_R
      addQuad(
        p_ft_L.toArray(), p_bt_L.toArray(),
        p_bt_R.toArray(), p_ft_R.toArray(),
        [0, 0], [1, 0], [1, 1], [1, 0] // UVs for texture
      );
      
      // LEFT SIDE (rock pitch) - Uses texture group 1
      // Vertices are p_fb_L, p_ft_L, p_bt_L, p_bb_L
      addQuad(
        p_fb_L.toArray(), p_ft_L.toArray(),
        p_bt_L.toArray(), p_bb_L.toArray(),
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs for texture (adjust as needed for side textures)
      );
      
      // RIGHT SIDE (rock pitch) - Uses texture group 1
      // Vertices are p_fb_R, p_bb_R, p_bt_R, p_ft_R
      addQuad(
        p_fb_R.toArray(), p_bb_R.toArray(),
        p_bt_R.toArray(), p_ft_R.toArray(),
        [0, 0], [1, 0], [1, 1], [0, 1] // UVs for texture (adjust as needed for side textures)
      );
      
      slantGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      slantGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));
      slantGeometry.computeVertexNormals();
      
      // Material groups: 0 = front (first 6 vertices), 1 = everything else
      slantGeometry.clearGroups();
      slantGeometry.addGroup(0, 6, 0);  // Front face
      slantGeometry.addGroup(6, positions.length - 6, 1); // All other faces
      
      // ... rest of the slant block (worldW, worldH, etc.) remains largely the same
      // Ensure frontZ is correctly set for child positioning
      const worldW = dx * Math.abs(scale) * sCore;
      const worldH = (maxY - minY) * Math.abs(scale) * sCore; // Use SVG height
      const worldDepth = depth * Math.abs(scale);
      const perim = 2 * (worldW + worldH); // Simplified perimeter, might need refinement
      
      const finalScale: [number, number, number] = [scale * sCore, scale * sCore, scale];
      
      return {
        geometries: [slantGeometry],
        dims: { worldW, worldH, worldPerim: perim, worldDepth },
        meshScale: finalScale,
        apiData: {
          frontZ: 0, // The front face's base is at Z=0
          unitsPerMeter: 1 / Math.max(EPS, scale * sCore),
          version: Math.random(),
          worldWidth: worldW,
          worldHeight: worldH
        },
        childWrapperPos: [0, 0, 0] as [number, number, number]
      };
    }

Explanation of Changes:

frontSlantAngleRad and frontSlantOffsetZ: These calculate how much the top of the front face should be pushed back to create the slant.

Vertex Definitions (p_fb_L, p_ft_L, etc.):

The Z coordinate of the front top vertices (p_ft_L, p_ft_R) is now -frontSlantOffsetZ, making them recede.

The Z coordinate of the back top vertices (p_bt_L, p_bt_R) is -depth (if you want a vertical back) or can be further adjusted if the back also slants.

The Z coordinate of all bottom vertices (p_fb_L, p_fb_R, p_bb_L, p_bb_R) is 0 for the front bottom and -depth for the back bottom.

addQuad calls: These are updated to use the new vertex positions to construct all six faces of the trapezoidal prism.

frontZ in apiData: It remains 0 because the front bottom edge of the slant headstone is considered 0 in local Z space for child positioning.

Other Minor Recommendations

Slant Angle for Rock Pitch Normal Map:
In your rockNormalCanvas useMemo, you generate a normal map for the "rock pitch." When applying this to the side material of the slant headstone, you might want to consider the actual slant of the faces. The normalScale is already (3.0, 3.0), which is good for intensity. The direction of the normal map might benefit from being aligned to the slanted surface normals. However, for a rough "rock pitch" look, a general normal map often works well enough without complex transformations.

UV Mapping for Slant Sides:
The current UV mapping for the slant sides (addQuad calls) is [0,0], [1,0], [1,1], [0,1]. This is a basic normalized UV. For more advanced textures that might need to wrap correctly around the slanted sides, you might need to calculate UVs based on the perimeter distance and the height along that specific slanted side, similar to how you do for the upright headstone's perimeter. However, for a rock pitch texture that's meant to be irregular, this basic UV often suffices with RepeatWrapping.

Headstone Base:
Your reference image also clearly shows the headstone sitting on a separate base. Currently, your component only generates the headstone itself. To fully match the reference, you'd need to add a separate BoxGeometry (or a similar SvgHeadstone instance if you have a base SVG) for the base and position it correctly below the slant headstone. This would likely be another component rendered alongside SvgHeadstone.

Material Colors for Slant:
You currently set color: new THREE.Color(headstoneStyle === 'slant' ? 0x444444 : 0x888888). The 0x444444 (dark gray) for the slant is appropriate for a rough, unpolished finish often seen on the back and sides. The 0x888888 (lighter gray) for the upright could represent polished granite. This is a good distinction. Ensure your faceTexture and sideTexture are visually distinct enough to convey this difference as well.

By implementing the geometry changes for the slant style as detailed above, your Three.js headstone component will much more accurately represent a real-world slant headstone like the one in your reference image.