Here is the updated Scene.tsx.

To make the grass look realistic without using heavy post-processing or millions of geometry blades, the biggest fix is the Texture Scale.

In your previous code, repeat.set(6, 6) on a size 150 plane meant a single blade of grass was effectively 2 meters wide. By increasing the repeat to 32 and using MirroredRepeatWrapping (to hide grid lines), the grass will look like actual ground cover rather than a stretched carpet.

I also adjusted the material properties (roughness, normal scale) to make it feel more organic and "lush".

code
Tsx
download
content_copy
expand_less
--- START OF FILE Scene.tsx ---

'use client';
import { OrbitControls, Environment, ContactShadows, useTexture, Sparkles } from '@react-three/drei';
import * as THREE from 'three';
import HeadstoneAssembly from './headstone/HeadstoneAssembly';
import AtmosphericSky from './AtmosphericSky';
import { useHeadstoneStore } from '#/lib/headstone-store';

import { useFrame } from '@react-three/fiber';
import { useRef, Suspense } from 'react';

// --- CONFIGURATION ---
// A deeper, more organic green to blend with the texture
const GRASS_COLOR = '#113311';

function GrassFloor() {
  // Load grass textures from local public folder
  const props = useTexture({
    map: '/textures/grass_color.jpg',
    normalMap: '/textures/grass_normal.jpg',
    roughnessMap: '/textures/grass_roughness.jpg',
    aoMap: '/textures/grass_ao.jpg',
  });

  // --- TEXTURE FIXES ---
  // 1. Scale: On a 150x150 plane, a repeat of 32 gives ~4.5m per tile. 
  //    This makes individual grass blades look realistically small.
  const REPEAT_SCALE = 32; 

  props.map.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
  props.normalMap.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
  props.roughnessMap.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
  props.aoMap.repeat.set(REPEAT_SCALE, REPEAT_SCALE);

  // 2. Mirrored Wrapping: This flips every other tile, destroying the obvious "grid" pattern
  [props.map, props.normalMap, props.roughnessMap, props.aoMap].forEach((tex) => {
    tex.wrapS = tex.wrapT = THREE.MirroredRepeatWrapping;
  });

  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        {/* Increased segments (64,64) improves lighting accuracy across the large floor */}
        <planeGeometry args={[150, 150, 64, 64]} />
        <meshStandardMaterial 
          {...props}
          color={GRASS_COLOR}
          // Blend the texture color 50/50 with our deep green to unify the look
          color-lerp={0.5} 
          
          // Grass isn't perfectly matte (1.0). It has a waxy coating.
          roughness={0.8}
          
          // Crank up the normal scale to make the grass blades catch light and look 3D
          normalScale={new THREE.Vector2(2, 2)}
          
          metalness={0}
          envMapIntensity={0.1} // Very slight reflection of the sky
        />
      </mesh>
      
      {/* Contact Shadow: Anchors the headstone so it doesn't look like it's floating */}
      <ContactShadows
        position={[0, 0.01, 0]}
        scale={20}
        blur={2}
        opacity={0.7}
        far={10}
        color="#000000"
      />
    </group>
  );
}

// Fallback if internet is slow/textures fail
function SimpleGrassFloor() {
  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        <meshStandardMaterial color={GRASS_COLOR} roughness={0.9} />
      </mesh>
      <ContactShadows position={[0, 0.01, 0]} scale={20} blur={2.5} opacity={0.6} color="#000000" />
    </group>
  );
}

export default function Scene({ 
  targetRotation = 0,
  currentRotation
}: { 
  targetRotation?: number;
  currentRotation?: React.MutableRefObject<number>;
}) {
  const groupRef = useRef<THREE.Group>(null);
  const is2DMode = useHeadstoneStore((s) => s.is2DMode);
  const baseSwapping = useHeadstoneStore((s) => s.baseSwapping);
  const setSelected = useHeadstoneStore((s) => s.setSelected);
  const setEditingObject = useHeadstoneStore((s) => s.setEditingObject);
  const setSelectedInscriptionId = useHeadstoneStore((s) => s.setSelectedInscriptionId);
  const setSelectedAdditionId = useHeadstoneStore((s) => s.setSelectedAdditionId);
  const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);

  // Smooth rotation animation
  useFrame(() => {
    if (groupRef.current && currentRotation) {
      const diff = targetRotation - currentRotation.current;
      const delta = diff * 0.1;
      
      if (Math.abs(diff) > 0.001) {
        currentRotation.current += delta;
        groupRef.current.rotation.y = currentRotation.current;
      }
    }
  });

  const handleCanvasClick = (e: any) => {
    if (e.eventObject === e.object) {
      setSelected(null);
      setEditingObject('headstone');
      setSelectedInscriptionId(null);
      setSelectedAdditionId(null);
      setSelectedMotifId(null);
    }
  };

  return (
    <>
      {is2DMode && <color attach="background" args={['#CFE8FC']} />}
      
      {/* Fog: Matches the sky bottom to blend the horizon line seamlessly */}
      {!is2DMode && <fog attach="fog" args={['#e0f2fe', 20, 60]} />}
      
      {/* Invisible background plane to capture clicks */}
      <mesh
        position={[0, 0, -5]}
        onClick={handleCanvasClick}
      >
        <planeGeometry args={[100, 100]} />
        <meshBasicMaterial transparent opacity={0} />
      </mesh>
      
      {!is2DMode && <AtmosphericSky />}
      
      {/* Dust particles */}
      {!is2DMode && (
         <Sparkles 
           count={40}
           scale={10}
           size={2}
           speed={0.4}
           opacity={0.3}
           color="#fff"
           position={[0, 2, 0]}
         />
      )}
      
      {/* --- LIGHTING --- */}
      <ambientLight intensity={0.4} color="#cce0ff" />
      
      <spotLight 
        color="#fff5e6"
        intensity={2.5}
        angle={0.6}
        penumbra={0.5}
        position={[-5, 8, 8]}
        castShadow
        shadow-bias={-0.0001}
      />

      <pointLight position={[5, 2, 5]} intensity={0.5} color="#b8c5d1" />
      <spotLight color="#bfdbfe" intensity={1.5} position={[-5, 4, -5]} />

      <Environment
        preset="city"
        environmentIntensity={0.8}
        background={false}
        environmentRotation={[0, Math.PI / 2, 0]} 
      />

      <group ref={groupRef}>
        <HeadstoneAssembly />
      </group>
      
      <Suspense fallback={<SimpleGrassFloor />}>
        <GrassFloor />
      </Suspense>

      <OrbitControls
        makeDefault
        enabled={!baseSwapping}
        enableDamping={true}
        dampingFactor={baseSwapping ? 0 : 0.05}
        enableRotate={!is2DMode}
        enableZoom={!is2DMode}
        enablePan={!is2DMode}
        rotateSpeed={0.5}
        zoomSpeed={0.8}
        panSpeed={0.8}
        minPolarAngle={Math.PI / 3.5}
        maxPolarAngle={Math.PI / 2 - 0.05}
      />
    </>
  );
}