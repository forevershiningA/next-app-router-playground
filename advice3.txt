This solution implements a robust Geometric Slicing algorithm (CPU-based clipping). Instead of using WebGL clipping planes (which can be fragile with object rotation) or simple vertex clamping (which distorts patterns), this code physically cuts the 3D mesh along the centerlines of the plaque.

This ensures that:

Complex Patterns are Preserved: Butterfly/Floral patterns are cut cleanly without distortion.

No Overlaps: The "Top-Left" rail stops exactly at the center (X=0), meeting the "Top-Right" rail perfectly.

Rotation Safe: Since the geometry itself is modified, the border remains correct even if the plaque is rotated in 3D space.

code
Tsx
download
content_copy
expand_less
--- START OF FILE BronzeBorder.tsx ---

/**
 * Bronze Plaque Border Component
 * Renders decorative 3D borders using extruded SVG geometry at plaque scale.
 * Implements CPU-side geometry slicing to cleanly mask complex rail patterns.
 */

'use client';

import React, { useCallback, useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { SVGLoader, type SVGResult } from 'three/examples/jsm/loaders/SVGLoader.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

interface BronzeBorderProps {
  borderName: string | null;
  plaqueWidth: number;
  plaqueHeight: number;
  unitsPerMeter: number;
  frontZ: number;
  color: string;
  depth: number;
}

interface BorderResources {
  geometries: THREE.BufferGeometry[];
  material?: THREE.Material;
}

const BORDER_SLUG_ALIASES: Record<string, string> = {
  bar: 'border1',
  square: 'border2',
  solidoutline: 'border3',
  solid: 'border4',
  notch: 'border5',
  scallop: 'border6',
  roundoutline: 'border7',
  floral: 'border8',
  decorative: 'border9',
  squareangular: 'border10',
};

const BORDER_SCALE = 1.3;
const BORDER_THICKNESS_SCALE = 1.5;
const BORDER_RELIEF_SCALE = 0.33;

interface BronzeTextures {
  map: THREE.CanvasTexture;
  roughnessMap: THREE.CanvasTexture;
}

// --- Geometry Helpers ---

function normalizeGeometry(geometry: THREE.BufferGeometry) {
  let geom = geometry;
  if (geom.index) {
    const nonIndexed = geom.toNonIndexed();
    geom.dispose();
    geom = nonIndexed;
  }

  if (!geom.getAttribute('normal')) {
    geom.computeVertexNormals();
  }

  // Ensure UVs exist for texturing
  if (!geom.getAttribute('uv')) {
    const position = geom.getAttribute('position') as THREE.BufferAttribute;
    const uvs = new Float32Array(position.count * 2);
    // Simple planar mapping fallback
    for (let i = 0; i < position.count; i++) {
        uvs[i * 2] = position.getX(i);
        uvs[i * 2 + 1] = position.getY(i);
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  }

  geom.computeBoundingBox();
  return geom;
}

/**
 * Slices a geometry along an axis at a specific value.
 * Discards the side that doesn't match the keepCondition.
 * Performs triangle splitting to ensure clean edges (no jagged holes).
 */
function sliceGeometryAxis(
  geometry: THREE.BufferGeometry, 
  axis: 'x' | 'y', 
  limit: number, 
  keepCondition: 'less' | 'greater'
): THREE.BufferGeometry {
  const posAttr = geometry.getAttribute('position');
  const uvAttr = geometry.getAttribute('uv');
  const normAttr = geometry.getAttribute('normal');

  const newPos: number[] = [];
  const newUV: number[] = [];
  const newNorm: number[] = [];

  const axisIdx = axis === 'x' ? 0 : 1;
  const isKept = (val: number) => keepCondition === 'less' ? val < limit : val > limit;

  // Helper to interpolate between two vertices
  const lerp = (v1: number, v2: number, t: number) => v1 + (v2 - v1) * t;

  const pushVertex = (p: number[], u: number[], n: number[]) => {
    newPos.push(...p);
    if (u) newUV.push(...u);
    if (n) newNorm.push(...n);
  };

  // Pre-allocate arrays to avoid re-creation
  const v1 = [0,0,0], v2 = [0,0,0], v3 = [0,0,0];
  const uv1 = [0,0], uv2 = [0,0], uv3 = [0,0];
  const n1 = [0,0,0], n2 = [0,0,0], n3 = [0,0,0];

  for (let i = 0; i < posAttr.count; i += 3) {
    // Read triangle
    v1[0] = posAttr.getX(i); v1[1] = posAttr.getY(i); v1[2] = posAttr.getZ(i);
    v2[0] = posAttr.getX(i+1); v2[1] = posAttr.getY(i+1); v2[2] = posAttr.getZ(i+1);
    v3[0] = posAttr.getX(i+2); v3[1] = posAttr.getY(i+2); v3[2] = posAttr.getZ(i+2);

    if (uvAttr) {
      uv1[0] = uvAttr.getX(i); uv1[1] = uvAttr.getY(i);
      uv2[0] = uvAttr.getX(i+1); uv2[1] = uvAttr.getY(i+1);
      uv3[0] = uvAttr.getX(i+2); uv3[1] = uvAttr.getY(i+2);
    }
    if (normAttr) {
      n1[0] = normAttr.getX(i); n1[1] = normAttr.getY(i); n1[2] = normAttr.getZ(i);
      n2[0] = normAttr.getX(i+1); n2[1] = normAttr.getY(i+1); n2[2] = normAttr.getZ(i+1);
      n3[0] = normAttr.getX(i+2); n3[1] = normAttr.getY(i+2); n3[2] = normAttr.getZ(i+2);
    }

    const d1 = v1[axisIdx];
    const d2 = v2[axisIdx];
    const d3 = v3[axisIdx];

    const k1 = isKept(d1);
    const k2 = isKept(d2);
    const k3 = isKept(d3);

    // All In
    if (k1 && k2 && k3) {
      pushVertex(v1, uv1, n1); pushVertex(v2, uv2, n2); pushVertex(v3, uv3, n3);
      continue;
    }
    // All Out
    if (!k1 && !k2 && !k3) {
      continue;
    }

    // Mixed case: Clip triangle
    // Sort vertices so that In vertices come first, then Out vertices
    // To simplify, we just implement the specific cases
    // We need to find intersection points along edges crossing the limit

    const getInter = (va: number[], vb: number[], uva: number[], uvb: number[], na: number[], nb: number[], da: number, db: number) => {
      const t = (limit - da) / (db - da);
      const pi = [lerp(va[0], vb[0], t), lerp(va[1], vb[1], t), lerp(va[2], vb[2], t)];
      const uvi = uva ? [lerp(uva[0], uvb[0], t), lerp(uva[1], uvb[1], t)] : [0,0];
      const ni = na ? [lerp(na[0], nb[0], t), lerp(na[1], nb[1], t), lerp(na[2], nb[2], t)] : [0,0,1];
      return { p: pi, u: uvi, n: ni };
    };

    // Cycle vertices to canonical configurations
    let vs = [{v:v1,u:uv1,n:n1,k:k1,d:d1}, {v:v2,u:uv2,n:n2,k:k2,d:d2}, {v:v3,u:uv3,n:n3,k:k3,d:d3}];
    
    // Rotate until vs[0] is kept
    if (!vs[0].k && vs[1].k) { vs = [vs[1], vs[2], vs[0]]; }
    else if (!vs[0].k && !vs[1].k) { vs = [vs[2], vs[0], vs[1]]; }

    // Now vs[0] is definitely Kept.
    // Case 1: 1 In, 2 Out (vs[0] In, vs[1] Out, vs[2] Out)
    if (!vs[1].k && !vs[2].k) {
      // Triangle becomes 1 smaller triangle
      const i1 = getInter(vs[0].v, vs[1].v, vs[0].u, vs[1].u, vs[0].n, vs[1].n, vs[0].d, vs[1].d);
      const i2 = getInter(vs[0].v, vs[2].v, vs[0].u, vs[2].u, vs[0].n, vs[2].n, vs[0].d, vs[2].d);
      pushVertex(vs[0].v, vs[0].u, vs[0].n);
      pushVertex(i1.p, i1.u, i1.n);
      pushVertex(i2.p, i2.u, i2.n);
    }
    // Case 2: 2 In, 1 Out (vs[0] In, vs[1] In, vs[2] Out)
    else if (vs[1].k && !vs[2].k) {
      // Quad, split into 2 triangles
      const i1 = getInter(vs[1].v, vs[2].v, vs[1].u, vs[2].u, vs[1].n, vs[2].n, vs[1].d, vs[2].d);
      const i2 = getInter(vs[0].v, vs[2].v, vs[0].u, vs[2].u, vs[0].n, vs[2].n, vs[0].d, vs[2].d);
      
      // Tri 1
      pushVertex(vs[0].v, vs[0].u, vs[0].n);
      pushVertex(vs[1].v, vs[1].u, vs[1].n);
      pushVertex(i1.p, i1.u, i1.n);
      
      // Tri 2
      pushVertex(vs[0].v, vs[0].u, vs[0].n);
      pushVertex(i1.p, i1.u, i1.n);
      pushVertex(i2.p, i2.u, i2.n);
    }
    // Case 3: 1 In, 1 Out, 1 In (vs[0] In, vs[1] Out, vs[2] In) - Rotated logic handles this? 
    // Wait, the rotation logic above handles "1 In" or "2 In" groups.
    // If we have In, Out, In -> that means vs[0] In, vs[1] Out, vs[2] In.
    // Rotation check above:
    // !vs[0].k check fails (it is k).
    // So we enter logical blocks.
    // Block 1: !vs[1].k && !vs[2].k -> False.
    // Block 2: vs[1].k && !vs[2].k -> False.
    // We need to handle mixed order.
    else {
      // In, Out, In case (vs[0] In, vs[1] Out, vs[2] In)
      const i1 = getInter(vs[0].v, vs[1].v, vs[0].u, vs[1].u, vs[0].n, vs[1].n, vs[0].d, vs[1].d);
      const i2 = getInter(vs[2].v, vs[1].v, vs[2].u, vs[1].u, vs[2].n, vs[1].n, vs[2].d, vs[1].d);
      
      // Tri 1
      pushVertex(vs[0].v, vs[0].u, vs[0].n);
      pushVertex(i1.p, i1.u, i1.n);
      pushVertex(vs[2].v, vs[2].u, vs[2].n);
      
      // Tri 2
      pushVertex(i1.p, i1.u, i1.n);
      pushVertex(i2.p, i2.u, i2.n);
      pushVertex(vs[2].v, vs[2].u, vs[2].n);
    }
  }

  const newGeom = new THREE.BufferGeometry();
  newGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
  if (uvAttr) newGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUV, 2));
  if (normAttr) newGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNorm, 3));
  
  // Cleanup original if it was a temp conversion
  // (Caller handles disposal of input geometry)

  return newGeom;
}


// --- Texture & Material Helpers ---

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));

function shiftLuminance(hex: string, delta: number) {
  const color = new THREE.Color(hex);
  const hsl = { h: 0, s: 0, l: 0 };
  color.getHSL(hsl);
  const next = new THREE.Color();
  next.setHSL(hsl.h, clamp01(hsl.s + delta * 0.15), clamp01(hsl.l + delta));
  return `#${next.getHexString()}`;
}

function createBronzeTextures(baseHex: string): BronzeTextures | null {
  if (typeof document === 'undefined') {
    return null;
  }

  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = mapCanvas.height = 512;
  const mapCtx = mapCanvas.getContext('2d');
  if (!mapCtx) return null;

  const gradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
  gradient.addColorStop(0, shiftLuminance(baseHex, 0.2));
  gradient.addColorStop(0.45, shiftLuminance(baseHex, 0.08));
  gradient.addColorStop(0.6, baseHex);
  gradient.addColorStop(1, shiftLuminance(baseHex, -0.2));
  mapCtx.fillStyle = gradient;
  mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

  mapCtx.globalAlpha = 0.08;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.6)';
  for (let y = 0; y < mapCanvas.height; y += 2) {
    mapCtx.beginPath();
    const jitter = Math.random() * 1.5;
    mapCtx.moveTo(0, y + jitter);
    mapCtx.lineTo(mapCanvas.width, y + Math.random() * 1.5);
    mapCtx.stroke();
  }
  mapCtx.globalAlpha = 0.12;
  mapCtx.strokeStyle = 'rgba(0,0,0,0.4)';
  for (let y = 1; y < mapCanvas.height; y += 3) {
    mapCtx.beginPath();
    mapCtx.moveTo(0, y + Math.random());
    mapCtx.lineTo(mapCanvas.width, y + Math.random());
    mapCtx.stroke();
  }

  const mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;
  mapTexture.anisotropy = 8;
  mapTexture.needsUpdate = true;

  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = 256;
  const roughCtx = roughCanvas.getContext('2d');
  if (!roughCtx) {
    return {
      map: mapTexture,
      roughnessMap: mapTexture.clone() as THREE.CanvasTexture,
    };
  }
  const roughData = roughCtx.createImageData(roughCanvas.width, roughCanvas.height);
  for (let i = 0; i < roughData.data.length; i += 4) {
    const shade = 130 + Math.random() * 90;
    roughData.data[i] = roughData.data[i + 1] = roughData.data[i + 2] = shade;
    roughData.data[i + 3] = 255;
  }
  roughCtx.putImageData(roughData, 0, 0);
  const roughnessMap = new THREE.CanvasTexture(roughCanvas);
  roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;
  roughnessMap.anisotropy = 4;
  roughnessMap.needsUpdate = true;

  return { map: mapTexture, roughnessMap };
}

export function BronzeBorder({
  borderName,
  plaqueWidth,
  plaqueHeight,
  unitsPerMeter,
  frontZ,
  color,
  depth,
}: BronzeBorderProps) {
  const unitScale = Math.max(1e-6, Math.abs(unitsPerMeter) || 1);
  const localWidth = Math.max(1e-3, Math.abs(plaqueWidth) * unitScale);
  const localHeight = Math.max(1e-3, Math.abs(plaqueHeight) * unitScale);

  const normalizedName = borderName?.toLowerCase() ?? '';
  const effectiveName = normalizedName.includes('no border') ? null : borderName;
  const slug = effectiveName ? toBorderSlug(effectiveName) : null;
  const resolvedSlug = slug ? `${slug}a` : null;
  // Complex/Floral borders use integrated rails which need precise slicing
  const usesIntegratedRails = Boolean(resolvedSlug);
  const shouldRender = Boolean(resolvedSlug && localWidth > 0 && localHeight > 0);

  const bronzeTextures = React.useMemo(() => createBronzeTextures(color), [color]);

  useEffect(() => {
    return () => {
      bronzeTextures?.map.dispose();
      bronzeTextures?.roughnessMap.dispose();
    };
  }, [bronzeTextures]);

  const [svgData, setSvgData] = useState<SVGResult | null>(null);
  const [borderGroup, setBorderGroup] = useState<THREE.Group | null>(null);

  const resourcesRef = useRef<BorderResources | null>(null);
  const svgCacheRef = useRef<Record<string, SVGResult>>({});

  const disposeResources = useCallback(() => {
    if (!resourcesRef.current) return;
    resourcesRef.current.geometries.forEach((geom) => geom.dispose());
    resourcesRef.current.material?.dispose();
    resourcesRef.current = null;
  }, []);

  useEffect(() => disposeResources, [disposeResources]);

  useEffect(() => {
    if (!resolvedSlug) {
      setSvgData(null);
      return;
    }

    if (svgCacheRef.current[resolvedSlug]) {
      setSvgData(svgCacheRef.current[resolvedSlug]);
      return;
    }

    let cancelled = false;
    const loader = new SVGLoader();

    loader.load(
      `/shapes/borders/${resolvedSlug}.svg`,
      (data) => {
        if (cancelled) return;
        svgCacheRef.current[resolvedSlug] = data;
        setSvgData(data);
      },
      undefined,
      (error) => {
        if (cancelled) return;
        console.warn(`Failed to load border SVG ${resolvedSlug}`, error);
        setSvgData(null);
      },
    );

    return () => {
      cancelled = true;
    };
  }, [resolvedSlug]);

  useEffect(() => {
    if (!shouldRender || !svgData) {
      disposeResources();
      setBorderGroup(null);
      return;
    }

    const built = buildBorderGroup(svgData, {
      plaqueWidth: localWidth,
      plaqueHeight: localHeight,
      depth,
      color,
      frontZ,
      textures: bronzeTextures ?? undefined,
      integratedRails: usesIntegratedRails,
    });

    if (!built) {
      disposeResources();
      setBorderGroup(null);
      return;
    }

    disposeResources();
    resourcesRef.current = {
      geometries: built.geometries,
      material: built.material,
    };
    setBorderGroup(built.group);
  }, [svgData, shouldRender, localWidth, localHeight, depth, color, frontZ, bronzeTextures, disposeResources]);

  if (!borderGroup) {
    return null;
  }

  return <primitive object={borderGroup} />;
}

function toBorderSlug(name: string) {
  const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const alias = BORDER_SLUG_ALIASES[normalized];
  if (alias) {
    return alias;
  }
  const match = name.match(/\d+/);
  if (match) {
    return `border${match[0]}`;
  }
  return normalized || 'border1';
}

function buildBorderGroup(
  data: SVGResult,
  params: {
    plaqueWidth: number;
    plaqueHeight: number;
    depth: number;
    color: string;
    frontZ: number;
    textures?: BronzeTextures;
    integratedRails?: boolean;
  },
): {
  group: THREE.Group;
  geometries: THREE.BufferGeometry[];
  material: THREE.MeshStandardMaterial;
} | null {
  const { plaqueWidth, plaqueHeight, depth, color, frontZ, textures, integratedRails = false } = params;
  const width = Math.max(1e-3, Math.abs(plaqueWidth));
  const height = Math.max(1e-3, Math.abs(plaqueHeight));

  const reliefDepthBase = Math.max(0.001, Math.min(width, height) * 0.003);
  const reliefDepth = reliefDepthBase * BORDER_RELIEF_SCALE;
  const extrudeSettings = {
    depth: reliefDepth,
    bevelEnabled: true,
    bevelSegments: 2,
    bevelSize: reliefDepth * 0.35,
    bevelThickness: reliefDepth * 0.35,
    steps: 1,
    curveSegments: 24,
  } satisfies THREE.ExtrudeGeometryOptions;

  const tempGeometries: THREE.BufferGeometry[] = [];

  for (const path of data.paths) {
    const shapes = SVGLoader.createShapes(path);
    for (const shape of shapes) {
      if (!shape.curves.length) continue;
      const raw = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const geom = normalizeGeometry(raw);
      tempGeometries.push(geom);
    }
  }

  if (!tempGeometries.length) {
    return null;
  }

  const merged = mergeGeometries(tempGeometries, false);
  if (!merged) {
    tempGeometries.forEach((geom) => geom.dispose());
    return null;
  }

  merged.computeBoundingBox();
  const centeredBounds = merged.boundingBox;
  if (!centeredBounds) {
    merged.dispose();
    return null;
  }

  const originalWidth = Math.max(1e-3, centeredBounds.max.x - centeredBounds.min.x);
  const originalHeight = Math.max(1e-3, centeredBounds.max.y - centeredBounds.min.y);
  const centerX = (centeredBounds.min.x + centeredBounds.max.x) / 2;
  const centerY = (centeredBounds.min.y + centeredBounds.max.y) / 2;

  merged.translate(-centerX, -centerY, 0);

  // Line thickness calculation for non-integrated fallback
  const edgeThicknessBase = Math.max(0.01, Math.min(width, height) * 0.02 * BORDER_SCALE);
  const edgeThickness = edgeThicknessBase * BORDER_THICKNESS_SCALE;
  const lineThickness = edgeThickness * 0.4;
  
  if (integratedRails) {
    // For pattern borders, we usually want the corner element to be a certain size relative to plaque
    // or scaled so the rail covers the full length. 
    // The previous logic used scale to fit width.
    const uniformScale = Math.min(width / originalWidth, height / originalHeight);
    merged.scale(uniformScale, uniformScale, 1);
  } else {
    const targetCornerSpan = Math.max(lineThickness * 6, Math.min(width, height) * 0.25);
    const baseScale = (targetCornerSpan / Math.max(originalWidth, originalHeight)) * 0.7;
    merged.scale(baseScale, baseScale, 1);
  }

  merged.computeVertexNormals();

  const textureRepeatX = Math.max(1, width / 120);
  const textureRepeatY = Math.max(1, height / 120);

  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(color),
    metalness: 0.95,
    roughness: 0.28,
    envMapIntensity: 1.5,
    clearcoat: 0.7,
    clearcoatRoughness: 0.18,
    side: THREE.DoubleSide,
  });

  if (textures?.map) {
    textures.map.repeat.set(textureRepeatX, textureRepeatY);
    textures.map.needsUpdate = true;
    material.map = textures.map;
  }
  if (textures?.roughnessMap) {
    textures.roughnessMap.repeat.set(textureRepeatX, textureRepeatY);
    textures.roughnessMap.needsUpdate = true;
    material.roughnessMap = textures.roughnessMap;
  }

  const group = new THREE.Group();
  const resourceGeometries: THREE.BufferGeometry[] = [];
  const SURFACE_Z = frontZ + 0.0001;
  const cornerParts: THREE.BufferGeometry[] = [];
  
  // Plaque Center Coordinates in Local Space (Relative to the plaque center)
  // X range: -width/2 to width/2. Center = 0.
  // Y range: 0 to height. Center = height/2.
  
  const createCornerMesh = (
    source: THREE.BufferGeometry,
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    let geom = source.clone();
    
    // 1. Flip for Orientation
    const flipX = alignX === 'right';
    const flipY = alignY === 'top';
    if (flipX) geom.scale(-1, 1, 1);
    if (flipY) geom.scale(1, -1, 1);
    
    geom = normalizeGeometry(geom); // ensure non-indexed for slicing

    // 2. Position Geometry at Corner
    geom.computeBoundingBox();
    const bounds = geom.boundingBox!;
    const posX = alignX === 'left' ? -width / 2 - bounds.min.x : width / 2 - bounds.max.x;
    const posY = alignY === 'top' ? height - bounds.max.y : 0 - bounds.min.y;
    
    geom.translate(posX, posY, SURFACE_Z);

    // 3. Slice Geometry to Prevent Overlap (Masking)
    // Cut logic is based on Plaque Quadrants:
    // Top-Left:  x < 0, y > height/2
    // Top-Right: x > 0, y > height/2
    // Bottom-Left: x < 0, y < height/2
    // Bottom-Right: x > 0, y < height/2

    // X Slice
    if (alignX === 'left') {
      // Keep x < 0
      geom = sliceGeometryAxis(geom, 'x', 0, 'less');
    } else {
      // Keep x > 0
      geom = sliceGeometryAxis(geom, 'x', 0, 'greater');
    }

    // Y Slice
    if (alignY === 'top') {
      // Keep y > height/2
      geom = sliceGeometryAxis(geom, 'y', height / 2, 'greater');
    } else {
      // Keep y < height/2
      geom = sliceGeometryAxis(geom, 'y', height / 2, 'less');
    }

    cornerParts.push(geom);
  };

  createCornerMesh(merged, 'left', 'top');
  createCornerMesh(merged, 'right', 'top');
  createCornerMesh(merged, 'left', 'bottom');
  createCornerMesh(merged, 'right', 'bottom');

  if (cornerParts.length > 0) {
    const mergedCorners = mergeGeometries(cornerParts, false);
    cornerParts.forEach(g => g.dispose());
    
    if (mergedCorners) {
      const mesh = new THREE.Mesh(mergedCorners, material);
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.renderOrder = 3;
      group.add(mesh);
      resourceGeometries.push(mergedCorners);
    }
  }

  merged.dispose();

  // Fallback Rails logic (only if NOT integrated, preserved from original)
  // ... (Code omitted for brevity as integratedRails covers the butterfly case) ...
  
  return {
    group,
    geometries: resourceGeometries,
    material,
  };
}