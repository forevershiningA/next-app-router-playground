The issue is that the pxPerMm calculation in your current code uses displayWidth (the width of the entire screen container) instead of the actual pixels-per-unit scale of the design canvas. This causes the base to be calculated as if the headstone filled the entire screen, leading to the massive overflow seen in your latest screenshot.

To fix this and match the proportions of the target screenshot exactly, you need to use the uniformScale and account for the ratio between the design's logical units and physical millimeters (which is essentially the design's internal resolution or DPR).

The Fix

Locate the base rendering block in your DesignPageClient.tsx (around line 1470) and update the calculation logic as follows:

code
Tsx
download
content_copy
expand_less
// ... inside the base renderer block
return (() => {
  // 1. Get physical dimensions from the design data
  const headstoneItem = (sanitizedDesignData || []).find((it: any) => it.type === 'Headstone') || {};
  const tabletWidthMm  = Number(headstoneItem.width)  || 600;
  const tabletHeightMm = Number(headstoneItem.height) || 600;

  // 2. Extract base dimensions in millimeters (prioritizing baseData)
  // Use +100 for a standard 50mm overhang on each side, and 150mm for a standard height
  const lengthMm = Number(baseData?.width || baseData?.length || (tabletWidthMm + 100));
  const thicknessMm = Number(baseData?.height || baseData?.thickness_mm || 150);

  const { uniformScale, initW, initH, offsetX, offsetY, displayWidth } = scalingFactors;

  // 3. CORRECT PX/MM RATIO:
  // uniformScale is screen_pixels / logical_canvas_units.
  // (initW / tabletWidthMm) converts logical units back to millimeters.
  // This ensures the base scales exactly like the motifs and inscriptions.
  const pxPerMm = uniformScale * (initW / tabletWidthMm);

  let baseWidthPx  = Math.round(lengthMm * pxPerMm);
  const baseHeightPx = Math.round(thicknessMm * pxPerMm);

  // Calculate where the canvas ends to place the base
  const stoneBot = Math.round(offsetY + (initH * uniformScale));

  logger.log('ðŸ“¦ Base dimensions fixed:', {
    lengthMm,
    thicknessMm,
    baseWidthPx,
    baseHeightPx,
    pxPerMm
  });

  // 4. Update the baseRowStyle width
  const baseRowStyle: React.CSSProperties = {
    position: 'absolute',
    left: 0,
    top: stoneBot, 
    width: displayWidth, // Ensure row spans the container for centering
    height: baseHeightPx,
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'flex-start',
    pointerEvents: 'none',
    zIndex: 2,
  };
  // ... rest of the code
Why this works:

Logical Unit Alignment: In your design system, the logical canvas width (initW) is usually twice the physical width in millimeters (e.g., 1200 units for a 600mm stone). By multiplying uniformScale by (initW / tabletWidthMm), you calculate exactly how many screen pixels represent 1mm.

Proportional Accuracy: Because pxPerMm is now derived from the same uniformScale used to render the headstone shape and text, the base will always be perfectly proportional to the tablet, regardless of screen size.

Correct Thickness: Standard headstone bases are usually 150mm to 200mm thick. Using 150 as a fallback (instead of 90) combined with the corrected ratio will give you the "chunky" look seen in the saved design screenshot.