To fix the pixelated grass, we need to increase the "tiling" (Repeat Scale). Currently, it's stretching the image too much. We will increase the repeat to 50 (making the texture much smaller and sharper) and enable Anisotropy (which keeps textures sharp when viewed from an angle).

To fix the distracting reflections, we will max out the blur on the Environment so it looks like soft light rather than specific trees.

Here is the updated Scene.tsx.

Key Changes:

Grass REPEAT_SCALE changed to 50: This shrinks the texture significantly so it looks high-res and crisp, not pixelated.

Added anisotropy: This forces the graphics card to render the floor sharply even when looking at it from the side.

Environment blur={1}: This blurs the forest completely, so the headstone just reflects "light and dark" instead of "branches and leaves."

Grass Color: Changed to #ffffff (White). Since your texture is high quality and has its own color, we shouldn't tint it. We let the natural texture color show through.

code
Tsx
download
content_copy
expand_less
// --- START OF FILE Scene.tsx ---

'use client';
import { OrbitControls, Environment, ContactShadows, useTexture, Sparkles } from '@react-three/drei';
import * as THREE from 'three';
import HeadstoneAssembly from './headstone/HeadstoneAssembly';
import AtmosphericSky from './AtmosphericSky';
import { useHeadstoneStore } from '#/lib/headstone-store';
import { useFrame, useThree } from '@react-three/fiber';
import { useRef, Suspense, useEffect } from 'react';

// --- CONFIGURATION ---
// UPDATED: Set to White so we see the REAL texture color, not a tinted version
const GRASS_COLOR = '#ffffff'; 
const FOG_COLOR = '#e8e8e8';

function GrassFloor() {
  const gl = useThree((state) => state.gl);
  
  const props = useTexture({
    map: '/textures/grass_color.jpg',
    normalMap: '/textures/grass_normal.jpg',
    aoMap: '/textures/grass_ao.jpg',
  });

  // --- TEXTURE FIXES ---
  // UPDATED: Increased to 50. 
  // This shrinks the texture tiles, making them look sharp instead of pixelated.
  const REPEAT_SCALE = 50;

  useEffect(() => {
    [props.map, props.normalMap, props.aoMap].forEach((tex) => {
      if (tex) {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping; // Changed from Mirrored to Standard Repeat for organic textures
        tex.repeat.set(REPEAT_SCALE, REPEAT_SCALE);
        tex.colorSpace = THREE.SRGBColorSpace;
        
        // CRITICAL: Anisotropy fixes the "blur" when looking at the ground from an angle
        tex.anisotropy = gl.capabilities.getMaxAnisotropy();
        tex.needsUpdate = true;
      }
    });
  }, [props, gl]);

  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        <meshStandardMaterial 
          map={props.map}
          normalMap={props.normalMap}
          aoMap={props.aoMap}
          
          color={GRASS_COLOR}
          
          roughness={1}          // Matte (no shine)
          metalness={0}          
          envMapIntensity={0}    // No sky reflection on grass
          
          // Reduced normal scale slightly so the bumpiness isn't too noisy at high repeat
          normalScale={new THREE.Vector2(0.5, 0.5)} 
        />
      </mesh>
      
      {/* Contact Shadow */}
      <ContactShadows
        position={[0, 0.02, 0]}
        scale={15}
        blur={2.5}
        opacity={0.6}
        far={1.5}
        color="#001100"
        resolution={512}
      />
    </group>
  );
}

// Fallback
function SimpleGrassFloor() {
  return (
    <group position={[0, -0.01, 0]}>
      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
        <planeGeometry args={[150, 150]} />
        <meshStandardMaterial 
          color="#355c18" // Fallback color
          roughness={1}
          metalness={0}
          envMapIntensity={0}
        />
      </mesh>
      <ContactShadows position={[0, 0.02, 0]} scale={15} blur={2.5} opacity={0.6} far={1.5} color="#001100" />
    </group>
  );
}

export default function Scene({ 
  targetRotation = 0,
  currentRotation
}: { 
  targetRotation?: number;
  currentRotation?: React.MutableRefObject<number>;
}) {
  const groupRef = useRef<THREE.Group>(null);
  const is2DMode = useHeadstoneStore((s) => s.is2DMode);
  const baseSwapping = useHeadstoneStore((s) => s.baseSwapping);
  const setSelected = useHeadstoneStore((s) => s.setSelected);
  const setEditingObject = useHeadstoneStore((s) => s.setEditingObject);
  const setSelectedInscriptionId = useHeadstoneStore((s) => s.setSelectedInscriptionId);
  const setSelectedAdditionId = useHeadstoneStore((s) => s.setSelectedAdditionId);
  const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);

  useFrame(() => {
    if (groupRef.current && currentRotation) {
      const diff = targetRotation - currentRotation.current;
      const delta = diff * 0.1;
      if (Math.abs(diff) > 0.001) {
        currentRotation.current += delta;
        groupRef.current.rotation.y = currentRotation.current;
      }
    }
  });

  const handleCanvasClick = (e: any) => {
    if (e.eventObject === e.object) {
      setSelected(null);
      setEditingObject('headstone');
      setSelectedInscriptionId(null);
      setSelectedAdditionId(null);
      setSelectedMotifId(null);
    }
  };

  return (
    <>
      {is2DMode && <color attach="background" args={['#CFE8FC']} />}
      
      {!is2DMode && <fog attach="fog" args={[FOG_COLOR, 50, 150]} />}
      
      <mesh
        position={[0, 0, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
        onClick={handleCanvasClick}
      >
        <planeGeometry args={[200, 200]} />
        <meshBasicMaterial transparent opacity={0} side={THREE.DoubleSide} />
      </mesh>
      
      {!is2DMode && (
         <Sparkles 
           count={50}
           scale={12}
           size={3}
           speed={0.3}
           opacity={0.4}
           color="#fffee0"
           position={[0, 2, 0]}
         />
      )}
      
      {/* --- LIGHTING --- */}
      <ambientLight intensity={0.6} color="#ffffff" />
      
      <hemisphereLight
        args={['#fff8e7', '#444444']} // Darker ground color in light prevents wash-out
        intensity={0.5}
      />
      
      <spotLight 
        color="#fffce6"
        intensity={2.0}
        angle={0.8}
        penumbra={0.5}
        position={[-10, 15, 10]}
        castShadow
        shadow-bias={-0.0001}
        shadow-mapSize={[2048, 2048]}
      />

      <pointLight position={[-5, 2, 5]} intensity={0.5} color="#ffffff" />
      <spotLight color="#ffffff" intensity={2} position={[5, 5, -5]} distance={30} />

      {/* 
        ENVIRONMENT UPDATES:
        1. blur={1}: Max blur. Turns the forest into abstract light/dark patches.
        2. environmentIntensity={0.5}: Lowers the brightness of reflections globally.
      */}
      <Environment
        preset="forest"
        background={false}
        blur={1.0} 
        environmentIntensity={0.5} 
      />

      <group ref={groupRef}>
        <HeadstoneAssembly />
        <Suspense fallback={<SimpleGrassFloor />}>
          <GrassFloor />
        </Suspense>
      </group>
      
      {!is2DMode && <AtmosphericSky />}

      <OrbitControls
        makeDefault
        enabled={!baseSwapping}
        enableDamping={true}
        dampingFactor={baseSwapping ? 0 : 0.05}
        enableRotate={!is2DMode}
        enableZoom={!is2DMode}
        enablePan={!is2DMode}
        rotateSpeed={0.5}
        zoomSpeed={0.8}
        panSpeed={0.8}
        minPolarAngle={Math.PI / 3.5}
        maxPolarAngle={Math.PI / 2 - 0.05}
      />
    </>
  );
}
Important: How to tune the Granite Reflection

Because the user's HeadstoneAssembly.tsx is separate, if the reflection is still too strong after these changes, you must go into your Headstone material (in HeadstoneAssembly.tsx) and lower the envMapIntensity.

Example:

code
Tsx
download
content_copy
expand_less
// inside HeadstoneAssembly.tsx
<meshPhysicalMaterial 
   ...
   envMapIntensity={0.3} // <--- Lower this number to make reflections darker
   roughness={0.3}       // <--- Increase this to make reflections fuzzier
/>