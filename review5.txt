This is the "home stretch" fix.

To solve the "Denim/Sandpaper" look and get the "Great" result (heavy, chiseled rock), we need to make three specific changes:

Change the Noise Algorithm: We need "Cellular-ish" shapes, not sine waves. I have replaced the math with a "Crater/Chip" algorithm that creates jagged distinct areas.

Drastically Reduce Repeat: "Denim" happens when you tile a texture 20 times. We will tile it 2 times. We want the chips to be the size of a fist, not a grain of sand.

Manual Normal Calculation: Instead of treating the noise as a height map and guessing, we will calculate the slopes manually to create "hard edges" (the chisel marks).

Here is the updated file.

code
Tsx
download
content_copy
expand_less
'use client';
import * as THREE from 'three';
import React, {
  useRef,
  forwardRef,
  useImperativeHandle,
  useEffect,
  useLayoutEffect,
  useMemo,
  Suspense,
} from 'react';
import { useFrame } from '@react-three/fiber';
import { useTexture } from '@react-three/drei';
import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';
import { useHeadstoneStore, Line } from '#/lib/headstone-store';
import HeadstoneInscription from '../../HeadstoneInscription';
import MotifModel from '../MotifModel';
import type { HeadstoneAPI } from '../../SvgHeadstone';
import {
  TEX_BASE,
  DEFAULT_TEX,
  BASE_WIDTH_MULTIPLIER,
  BASE_DEPTH_MULTIPLIER,
  BASE_MIN_DEPTH,
  LERP_FACTOR,
  EPSILON,
} from '#/lib/headstone-constants';

type HeadstoneBaseAutoProps = {
  headstoneObject: React.RefObject<THREE.Object3D>;
  wrapper: React.RefObject<THREE.Object3D>;
  onClick?: (e: any) => void;
  height?: number;
  name?: string;
};

function PreloadTexture({
  url,
  onReady,
}: {
  url: string;
  onReady?: () => void;
}) {
  useTexture(url);
  React.useEffect(() => {
    const id = requestAnimationFrame(() => onReady?.());
    return () => cancelAnimationFrame(id);
  }, [onReady]);
  return null;
}

/**
 * Helper to fix Multi-Material support on RoundedBoxGeometry
 */
function fixRoundedBoxUVs(geometry: THREE.BufferGeometry) {
  if (!geometry.attributes.position || !geometry.index) return;
  geometry.clearGroups();
  const normal = geometry.attributes.normal;
  const index = geometry.index;

  // 0: Right (+x), 1: Left (-x), 2: Top (+y), 3: Bottom (-y), 4: Front (+z), 5: Back (-z)
  for (let i = 0; i < index.count; i += 3) {
    const a = index.getX(i);
    const nx = normal.getX(a);
    const ny = normal.getY(a);
    const nz = normal.getZ(a);
    let matIdx = 0;
    if (Math.abs(nx) > Math.abs(ny) && Math.abs(nx) > Math.abs(nz)) {
      matIdx = nx > 0 ? 0 : 1; // Right : Left
    } else if (Math.abs(ny) > Math.abs(nx) && Math.abs(ny) > Math.abs(nz)) {
      matIdx = ny > 0 ? 2 : 3; // Top : Bottom
    } else {
      matIdx = nz > 0 ? 4 : 5; // Front : Back
    }
    geometry.addGroup(i, 3, matIdx);
  }
}

function BaseMesh({
  baseRef,
  baseTexture,
  onClick,
  name,
  dimensions,
  finish,
}: {
  baseRef: React.RefObject<THREE.Mesh | null>;
  baseTexture: THREE.Texture;
  onClick?: (e: any) => void;
  name?: string;
  dimensions: { width: number; height: number; depth: number };
  finish: 'default' | 'rock-pitch';
}) {
  // 1. Generate the Source Canvas (The "Great" Texture)
  const rockNormalCanvas = useMemo(() => {
    if (finish !== 'rock-pitch') return null;

    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    if (!ctx) return null;

    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    // "Chiseled Rock" Noise Generator
    // This creates large, angular slopes instead of small sine waves
    const chipNoise = (x: number, y: number) => {
      // 1. Base Layer: Large low-frequency shapes (The big chips)
      const nx = x * 0.015;
      const ny = y * 0.015;
      
      // 'Billowy' noise creates crater-like edges
      let h = Math.abs(Math.sin(nx * 4.0 + ny) + Math.cos(ny * 3.0 - nx));
      
      // 2. Secondary Layer: Angular cuts
      h += Math.abs(Math.sin(nx * 8.0) * Math.cos(ny * 8.0)) * 0.5;
      
      // 3. Detail Layer: Grit (High frequency)
      h += (Math.random() - 0.5) * 0.1;
      
      return h;
    };

    // Sobel Filter loop to generate sharp normals
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const idx = (y * size + x) * 4;
        
        // Sample height at center and neighbors
        const h0 = chipNoise(x, y);
        const hRight = chipNoise(x + 1, y);
        const hDown = chipNoise(x, y + 1);
        
        // Calculate slope (The "Chisel" sharpness)
        // Higher scale = sharper/deeper cracks
        const scale = 15.0; 
        const dX = (h0 - hRight) * scale;
        const dY = (h0 - hDown) * scale;
        const dZ = 1.0; // The surface normal

        // Normalize vector to get RGB values
        const len = Math.sqrt(dX * dX + dY * dY + dZ * dZ);
        
        // Pack into 0-255 range
        // Standard Normal Map: R=X, G=Y, B=Z
        data[idx] = ((dX / len) * 0.5 + 0.5) * 255;     // R
        data[idx + 1] = ((dY / len) * 0.5 + 0.5) * 255; // G
        data[idx + 2] = ((dZ / len) * 0.5 + 0.5) * 255; // B (Blue)
        data[idx + 3] = 255;                            // Alpha
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }, [finish]);

  // 2. Manage Base Texture Settings
  useLayoutEffect(() => {
    if (baseTexture) {
      baseTexture.wrapS = THREE.RepeatWrapping;
      baseTexture.wrapT = THREE.RepeatWrapping;
      const textureScale = 0.15;
      baseTexture.repeat.set(
        dimensions.width / textureScale,
        dimensions.height / textureScale
      );
      baseTexture.anisotropy = 16;
      baseTexture.needsUpdate = true;
    }
  }, [baseTexture, dimensions.width, dimensions.height]);

  // 3. Create Materials
  const materials = useMemo(() => {
    const polishedMaterial = new THREE.MeshPhysicalMaterial({
      map: baseTexture,
      color: 0x888888,
      metalness: 0.0,
      roughness: 0.15,
      envMapIntensity: 1.5,
      clearcoat: 1.0,
      clearcoatRoughness: 0.1,
    });

    if (finish === 'rock-pitch' && rockNormalCanvas) {
      const texShort = new THREE.CanvasTexture(rockNormalCanvas);
      const texLong = new THREE.CanvasTexture(rockNormalCanvas);

      [texShort, texLong].forEach((tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.colorSpace = THREE.NoColorSpace; 
        tex.needsUpdate = true;
      });

      // Darker grey to create contrast with the polished top
      const rockColor = 0x444444; 

      const matShort = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texShort,
        // Aggressive Normal Scale for deep lighting effects
        normalScale: new THREE.Vector2(3.0, 3.0),
        color: rockColor,
        metalness: 0.0,
        // Granite sparkles: Lower roughness means more specular highlights
        // 0.6 is rough stone, 0.9 is matte dust.
        roughness: 0.65, 
        envMapIntensity: 1.0,
      });

      const matLong = new THREE.MeshStandardMaterial({
        map: baseTexture,
        normalMap: texLong,
        normalScale: new THREE.Vector2(3.0, 3.0),
        color: rockColor,
        metalness: 0.0,
        roughness: 0.65,
        envMapIntensity: 1.0,
      });

      return [
        matShort,
        matShort,
        polishedMaterial,
        polishedMaterial,
        matLong,
        matLong,
      ];
    }

    return polishedMaterial;
  }, [baseTexture, finish, rockNormalCanvas]);

  // 4. Update Material Repeats (The Scale Fix)
  useLayoutEffect(() => {
    if (Array.isArray(materials) && finish === 'rock-pitch') {
      // DENSITY: 
      // 1.5 = Large "Fist Sized" Chips (Realism)
      // 10.0 = "Denim" (Too small)
      const density = 2.0; 
      
      const matRight = materials[0] as THREE.MeshStandardMaterial;
      const matFront = materials[4] as THREE.MeshStandardMaterial;

      if (matRight.normalMap) {
        matRight.normalMap.repeat.set(
          Math.max(1, dimensions.depth * density),
          Math.max(1, dimensions.height * 3) // Vertical repeat
        );
      }

      if (matFront.normalMap) {
        matFront.normalMap.repeat.set(
          Math.max(1, dimensions.width * density),
          Math.max(1, dimensions.height * 3)
        );
      }
    }
  }, [materials, dimensions, finish]);

  // Cleanup
  useEffect(() => {
    return () => {
      if (Array.isArray(materials)) {
        materials.forEach((m) => {
          if (m instanceof THREE.MeshStandardMaterial && m.normalMap) {
            m.normalMap.dispose();
          }
        });
      }
    };
  }, [materials]);

  // 5. Geometry Logic
  const geometry = useMemo(() => {
    if (finish === 'rock-pitch') {
      // Small 3% bevel for realistic stone edge
      const geo = new RoundedBoxGeometry(1, 1, 1, 8, 0.03);
      fixRoundedBoxUVs(geo);
      return geo;
    }
    return new THREE.BoxGeometry(1, 1, 1);
  }, [finish]);

  return (
    <mesh
      ref={baseRef}
      name={name}
      onClick={onClick}
      castShadow
      receiveShadow
      geometry={geometry}
      onUpdate={(self) => {
        if (self.geometry) self.geometry.computeBoundingBox();
      }}
    >
      {Array.isArray(materials) ? (
        materials.map((mat, i) => (
          <primitive key={i} object={mat} attach={`material-${i}`} />
        ))
      ) : (
        <primitive object={materials} attach="material" />
      )}
    </mesh>
  );
}

const HeadstoneBaseAuto = forwardRef<THREE.Mesh, HeadstoneBaseAutoProps>(
  ({ headstoneObject, wrapper, onClick, height = 0.1, name }, ref) => {
    const baseRef = useRef<THREE.Mesh>(null);
    useImperativeHandle(ref, () => baseRef.current!);

    const dummyGroupRef = useRef<THREE.Group>(null);

    const baseMaterialUrl = useHeadstoneStore((s) => s.baseMaterialUrl);
    const setBaseSwapping = useHeadstoneStore((s) => s.setBaseSwapping);
    const hasStatue = useHeadstoneStore((s) => s.hasStatue);
    const widthMm = useHeadstoneStore((s) => s.widthMm);
    const heightMm = useHeadstoneStore((s) => s.heightMm);
    const baseWidthMm = useHeadstoneStore((s) => s.baseWidthMm);
    const baseHeightMm = useHeadstoneStore((s) => s.baseHeightMm);
    const baseFinish = useHeadstoneStore((s) => s.baseFinish);
    const inscriptions = useHeadstoneStore((s) => s.inscriptions);
    const selectedMotifs = useHeadstoneStore((s) => s.selectedMotifs);
    const motifOffsets = useHeadstoneStore((s) => s.motifOffsets);

    const baseHeightMeters = baseHeightMm / 1000;
    const selectedInscriptionId = useHeadstoneStore(
      (s) => s.selectedInscriptionId
    );
    const setSelectedInscriptionId = useHeadstoneStore(
      (s) => s.setSelectedInscriptionId
    );
    const setSelectedMotifId = useHeadstoneStore((s) => s.setSelectedMotifId);
    const setSelected = useHeadstoneStore((s) => s.setSelected);
    const setSelectedAdditionId = useHeadstoneStore(
      (s) => s.setSelectedAdditionId
    );
    const setActivePanel = useHeadstoneStore((s) => s.setActivePanel);

    const baseAPI: HeadstoneAPI = useMemo(() => {
      const baseDepth = 0.2 * BASE_DEPTH_MULTIPLIER;
      return {
        group: dummyGroupRef as React.RefObject<THREE.Group>,
        mesh: baseRef as React.RefObject<THREE.Mesh>,
        frontZ: baseDepth / 2,
        unitsPerMeter: 1000,
        version: 1,
        worldWidth: (widthMm / 1000) * BASE_WIDTH_MULTIPLIER,
        worldHeight: height,
      };
    }, [widthMm, height]);

    const requestedBaseTex = useMemo(() => {
      const file = baseMaterialUrl?.split('/').pop() ?? DEFAULT_TEX;
      const webp = file.replace(/\.jpg$/i, '.webp');
      return TEX_BASE + webp;
    }, [baseMaterialUrl]);

    const [visibleBaseTex, setVisibleBaseTex] = React.useState(requestedBaseTex);

    const baseSwapping = requestedBaseTex !== visibleBaseTex;

    useEffect(() => {
      setBaseSwapping(baseSwapping);
    }, [baseSwapping, setBaseSwapping]);

    const baseTexture = useTexture(visibleBaseTex);

    const hasTx = useRef(false);
    const targetPos = useRef(new THREE.Vector3());
    const targetScale = useRef(new THREE.Vector3(1, height, 1));
    const invMatrix = useRef(new THREE.Matrix4());
    const [baseDimensions, setBaseDimensions] = React.useState({
      width: 1,
      height: height,
      depth: 1,
    });

    useFrame(() => {
      const t = headstoneObject.current;
      const w = wrapper.current;
      const b = baseRef.current;
      if (!t || !w || !b) return;

      const baseW = baseWidthMm / 1000;
      const baseD = Math.max(0.2 * BASE_DEPTH_MULTIPLIER, BASE_MIN_DEPTH);
      const statueExtension = hasStatue() ? 0.2 : 0;
      const xOffset = statueExtension / 2;
      const headstoneDepth = 0.15;
      const baseZCenter = -(headstoneDepth / 2) + baseD / 2;

      const centerW = new THREE.Vector3(
        -xOffset,
        baseHeightMeters * 0.5 + EPSILON,
        baseZCenter
      );

      w.updateWorldMatrix(true, false);
      invMatrix.current.copy(w.matrixWorld).invert();
      const posLocal = centerW.applyMatrix4(invMatrix.current);

      targetPos.current.copy(posLocal);
      targetScale.current.set(baseW, baseHeightMeters, baseD);

      if (
        baseDimensions.width !== baseW ||
        baseDimensions.height !== baseHeightMeters ||
        baseDimensions.depth !== baseD
      ) {
        setBaseDimensions({
          width: baseW,
          height: baseHeightMeters,
          depth: baseD,
        });
      }

      if (!hasTx.current) {
        b.position.copy(targetPos.current);
        b.scale.copy(targetScale.current);
        hasTx.current = true;
      }

      b.visible = true;

      if (!hasTx.current) {
        return;
      }

      if (!baseSwapping) {
        b.position.lerp(targetPos.current, LERP_FACTOR);
        b.scale.lerp(targetScale.current, LERP_FACTOR);
      }

      b.visible = true;
    });

    return (
      <React.Fragment>
        <Suspense fallback={null}>
          <BaseMesh
            baseRef={baseRef}
            baseTexture={baseTexture}
            onClick={(e) => {
              e.stopPropagation();
              if (onClick && (!e.delta || e.delta < 2)) {
                onClick(e);
              }
            }}
            name={name}
            dimensions={baseDimensions}
            finish={baseFinish}
          />
        </Suspense>

        {inscriptions
          .filter((line: Line) => line.target === 'base')
          .map((line: Line, i: number) => {
            const zBump = (inscriptions.length - 1 - i) * 0.00005;
            return (
              <Suspense key={line.id} fallback={null}>
                <HeadstoneInscription
                  id={line.id}
                  headstone={baseAPI}
                  font={`/fonts/${line.font}.woff2`}
                  editable
                  selected={selectedInscriptionId === line.id}
                  onSelectInscription={() => {
                    setSelected('base');
                    setSelectedMotifId(null);
                    setSelectedAdditionId(null);
                    setSelectedInscriptionId(line.id);
                    setActivePanel('inscription');
                  }}
                  color={line.color}
                  lift={0.002}
                  xPos={line.xPos}
                  yPos={line.yPos}
                  rotationDeg={line.rotationDeg}
                  height={line.sizeMm}
                  text={line.text}
                  zBump={zBump}
                />
              </Suspense>
            );
          })}

        {selectedMotifs
          .filter((motif) => {
            const offset = motifOffsets[motif.id];
            return offset?.target === 'base';
          })
          .map((motif, i) => (
            <Suspense key={`${motif.id}-${i}`} fallback={null}>
              <MotifModel
                id={motif.id}
                svgPath={motif.svgPath}
                color={motif.color}
                headstone={baseAPI}
                index={i}
              />
            </Suspense>
          ))}

        {requestedBaseTex !== visibleBaseTex && (
          <Suspense fallback={null}>
            <PreloadTexture
              url={requestedBaseTex}
              onReady={() => {
                setVisibleBaseTex(requestedBaseTex);
              }}
            />
          </Suspense>
        )}
      </React.Fragment>
    );
  },
);

HeadstoneBaseAuto.displayName = 'HeadstoneBaseAuto';
export default HeadstoneBaseAuto;