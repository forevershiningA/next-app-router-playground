You’re sooo close. That screenshot shows the background (marble + curved mask) and the items are being drawn in **two different coordinate systems**:

* the background is drawn with one transform/offset,
* the inscriptions/motifs are drawn with a different offset (and probably a separate manual `x* s + offX`), so they no longer share the same origin.

Fix it by using **one transform for everything** and draw all elements in the same *authoring* space (414×660). No per-item offsets; no per-element special cases.

---

# One-Transform Pipeline (robust + simple)

```ts
// 0) canvas sharpness (optional, but recommended)
const DPR = window.devicePixelRatio || 1;
canvas.width  = dyo.w * DPR;
canvas.height = dyo.h * DPR;
ctx.setTransform(DPR, 0, 0, DPR, 0, 0);  // physical pixels -> CSS pixels

// 1) authoring & display frames
const initW = +design.init_width;   // 414
const initH = +design.init_height;  // 660
const dispW = dyo.w, dispH = dyo.h;

// uniform "contain" scale + offsets in CSS px
const s    = Math.min(dispW / initW, dispH / initH);
const offX = (dispW - initW * s) * 0.5;
const offY = (dispH - initH * s) * 0.5;

// 2) global world transform: everything now draws in authoring units
ctx.save();
ctx.transform(s, 0, 0, s, offX, offY);   // <- the only transform you need
// From here on, draw as if canvas were 414×660 with (0,0) in top-left
```

## Draw the headstone (background) in authoring space

```ts
// The path MUST be parameterised by initW/initH, starting at (0,0)
drawCurvedTopPath(ctx, initW, initH); // uses authoring coords only
ctx.save();
ctx.clip();

// draw marble to the full authoring frame (apply any crop here in authoring units)
ctx.drawImage(marbleImg, 0, 0, initW, initH);

ctx.restore();
```

## Draw each item in the *same* space

Undo legacy scaling once (if present), but **do not** add per-item offsets or multiply by `s` anymore—your context transform already handles it.

```ts
// Legacy undo (same scale for both axes if legacy)
const legacy = Math.max(items[0].x, items[0].y) > Math.max(initW, initH) * 1.15;
const legacyScale = legacy ? +(design.legacy_scale || 1) : 1;

for (const it of items) {
  const ax = legacy ? it.x / legacyScale : it.x; // authoring x
  const ay = legacy ? it.y / legacyScale : it.y; // authoring y

  if (it.type === 'Inscription') {
    const px = parseFloat(String(it.font).split('px')[0] ?? it.font_size);
    // IMPORTANT: because the world is scaled by s, use the *authoring* px directly
    ctx.save();
    ctx.font = `${px}px ${it.font_family}`;
    ctx.textAlign = 'center'; // or whatever you used at save time
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = it.color; // gold
    drawText(it, ax, ay);     // pass authoring coords
    ctx.restore();

  } else if (it.type === 'Motif') {
    const ar = it.svgAR ?? (it.width && it.height ? it.width/it.height : 1);
    const wA = it.width  ?? (it.height * ar);  // authoring size
    const hA = it.height ?? (it.width  / ar);
    drawMotif(it, ax, ay, wA, hA);             // authoring coords & size
  }
}
ctx.restore(); // end world transform
```

### Why this will fix your screenshot

* The marble semicircle currently sits left because it’s drawn with `(offX,offY,s)` but your items are additionally doing `x*s+offX` **or** using a different offset—so the two layers don’t align.
* With a **single context.transform**, every element (background + text + motifs) shares the exact same affine map. No double-scaling, no mismatched offsets.

---

## Two common “gotchas” to avoid (they cause exactly what you see)

1. **Double-scaling fonts or positions**
   If you keep the global `transform(s,0,0,s,offX,offY)` and also do `x* s + offX` (or `fontPx * s`), you’ll scale twice. Under the one-transform pipeline, draw using **authoring** `x,y` and **authoring** `fontPx`.

2. **Drawing the marble in display space**
   `ctx.drawImage(marble, 0,0, dispW, dispH)` inside a transformed world will push the bitmap left/top. Always use authoring: `drawImage(..., 0,0, initW, initH)` after you’ve applied the world transform.

---

### Quick checklist (log once)

* `initW, initH` = `414, 660`
* `s`, `offX`, `offY` are the **same** for the whole render
* Background, text, and motifs are all drawn **between** `ctx.save(); ctx.transform(...); ... ctx.restore();`
* Inside the transformed block, you **never** multiply positions or font sizes by `s`, nor add `offX/offY`

Switch to this single-transform approach and the marble mask will align perfectly with the inscriptions/motifs.
