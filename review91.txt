Got it. I inspected the uploaded `svg-generator.ts` and your screenshot. The issues in the PINTO render (top ribbon text left-shifted, small/offset motifs, inscription baselines drifting) all come from mixing coordinate bases and scaling twice (once via width/height and again via transforms/DPR heuristics).

Here’s a clean, stable fix that makes motifs and inscriptions land exactly where they were authored:

# What to change (single-space model)

1. **Use the authoring canvas as the only coordinate space**

* `viewBox = init_width x init_height`
* Remove all DPR logic and any “normalize” branches. Treat saved X/Y and font sizes as **authoring pixels**.

2. **Map from center-origin (how your editor saves) to SVG top-left**

* Most of your saved items are `{ x, y }` measured from canvas center.
* Convert once; never re-scale positions later.

3. **Scale sizes, not positions**

* Positions are only center→top-left + optional crop offsets.
* Font sizes and motif sizes scale by a single `uniformScale`.

4. **Never double-scale motifs**

* If you set `<image width/height>`, do **not** also apply a `transform: scale(...)`.
* Respect `ratio` from JSON: `finalMotifSize = originalSize * ratio * uniformScale`.

5. **Text anchoring & baseline**

* Use `text-anchor` from JSON (`start|middle|end`); default to `middle` for centered headings.
* Use `dominant-baseline="middle"` when Y is intended to be centerline; otherwise keep `alphabetic`.

---

## Drop-in helpers (replace/add)

```ts
// 1) One source of truth for scale
function computeUniformScale(initW: number, initH: number, targetW: number, targetH: number) {
  // "meet" behavior – keeps aspect and fits entirely
  return Math.min(targetW / initW, targetH / initH);
}

// 2) Center-origin → SVG top-left (optionally with crop offsets)
function centerToSvg(
  xFromCenter: number,
  yFromCenter: number,
  initW: number,
  initH: number,
  cropOffsetX = 0,
  cropOffsetY = 0
) {
  const cx = initW / 2;
  const cy = initH / 2;
  return {
    x: cx + xFromCenter - cropOffsetX,
    y: cy + yFromCenter - cropOffsetY,
  };
}
```

---

## In your generator (key lines to keep consistent)

```ts
// ViewBox = authoring canvas
const viewBoxWidth = initWidth;     // from JSON: init_width
const viewBoxHeight = initHeight;   // from JSON: init_height

// Target display size comes from your container (px). If unknown here, pass it in.
const uniformScale = computeUniformScale(initWidth, initHeight, targetW, targetH);

// ------------- SHAPE -------------
// Render the headstone path INTO the same viewBox. If you inline an external SVG,
// scale its internal path(s) to fill the authoring canvas ONCE, then stop.
const shape = /* generate or inline path(s) so that the stone sits exactly
                 where it did during authoring, in authoring pixels */;

// ------------- TEXT --------------
inscriptions.map(ins => {
  const { x, y } = centerToSvg(ins.x, ins.y, initWidth, initHeight, cropOffsetX, cropOffsetY);
  const fontSize = ins.fontSize * uniformScale;

  const anchor = ins.anchor || 'middle'; // 'start'|'middle'|'end'
  const baseline = ins.baseline || 'alphabetic'; // or 'middle' if your Y means centerline

  return `
    <text
      x="${x}"
      y="${y}"
      font-family="${ins.fontFamily}"
      font-size="${fontSize}"
      fill="${ins.color || '#000'}"
      text-anchor="${anchor}"
      dominant-baseline="${baseline}"
    >${escapeXML(ins.text)}</text>
  `;
}).join('\n');

// ------------- MOTIFS ------------
motifs.map(m => {
  const { x, y } = centerToSvg(m.x, m.y, initWidth, initHeight, cropOffsetX, cropOffsetY);

  // original motif native size (from your asset metadata or JSON)
  const baseW = m.originalWidth;
  const baseH = m.originalHeight;

  // JSON ratio defines authoring-time scale (you mentioned <ratio>…</ratio>)
  const ratio = m.ratio ?? 1;

  const w = baseW * ratio * uniformScale;
  const h = baseH * ratio * uniformScale;

  // Place by top-left. If your x,y refer to motif center (common), subtract half-size here:
  const anchorX = x - w / 2;
  const anchorY = y - h / 2;

  return `
    <image
      href="${m.src}"
      x="${anchorX}"
      y="${anchorY}"
      width="${w}"
      height="${h}"
      preserveAspectRatio="xMidYMid meet"
    />
  `;
}).join('\n');
```

---

## Why this fixes the PINTO screenshot

* The long ribbon text in your screenshot is left-shifted because earlier code mixed a center-based Y with a **left-anchored X** and then re-scaled positions again. The rules above anchor correctly (usually `text-anchor="middle"` for that line) and never re-scale positions.
* The top floral motif and icons are too small/offset because their `ratio` was applied *before* another transform scale (double scaling), or their X/Y were mirrored by a flipped transform space. Here we size once: `ratio * uniformScale`, and we map X/Y with a single `centerToSvg` pass.
* The “SEHOVIC” style centerline drift you’ve been seeing is a baseline issue; using `dominant-baseline="middle"` for center-Y text stops the creep across devices.