The issue in the previous iteration was that I attempted to separate the "Headstone Object" dimensions from the "Canvas" dimensions to handle edge cases, but for this specific data structure, the Headstone **width defined in the JSON (e.g., 600mm)** is a physical manufacturing dimension, while the **Canvas `init_width` (e.g., 800px)** is the visual rendering dimension.

By using the physical width (600) to size the HTML element, it shrunk the image relative to the canvas (800), causing the "tiny headstone" effect while the text (positioned on the 800px canvas grid) appeared floating or cut off.

**The Fix:**
1.  **Revert to Canvas-Based Sizing:** We treat `init_width` and `init_height` as the absolute source of truth for the visual aspect ratio.
2.  **Force Full-Bleed:** The headstone image/SVG is forced to fill 100% of this calculated container, ignoring the physical manufacturing dimensions for *rendering* purposes.
3.  **Alignment Fix:** Added logic to handle text alignment (`center`, `left`, `right`) to ensure inscriptions anchor correctly relative to their X coordinate.

Here is the corrected code:

```tsx
'use client';

import { useEffect, useState, Suspense, useRef, useMemo, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useSavedDesign, convertSavedDesignToDYO } from '#/components/SavedDesignLoader';
import { loadSavedDesignIntoEditor } from '#/lib/saved-design-loader-utils';
import { useHeadstoneStore } from '#/lib/headstone-store';
import { calculateMotifPrice } from '#/lib/motif-pricing';
import { data } from '#/app/_internal/_data';
import { ChevronRightIcon, ArrowPathIcon } from '@heroicons/react/24/outline';
import { getProductFromId } from '#/lib/product-utils';
import type { SavedDesignMetadata, DesignCategory } from '#/lib/saved-designs-data';
import React from 'react';
import { MotifsData } from '#/motifs_data';
import DesignSidebar from '#/components/DesignSidebar';
import DesignContentBlock from '#/components/DesignContentBlock';
import { analyzeImageForCrop, type CropBounds } from '#/lib/screenshot-crop';
import { getMotifCategoryName } from '#/lib/motif-translations';
import MobileNavToggle from '#/components/MobileNavToggle';
import DesignsTreeNav from '#/components/DesignsTreeNav';

// Type for layout items (inscriptions and motifs)
type LayoutItem = {
  x?: number;
  y?: number;
  cx?: number;
  cy?: number;
};

// Helper function to detect if design uses physical coordinates
function designUsesPhysicalCoords(
  items: LayoutItem[],
  initW: number,
  initH: number
): boolean {
  if (!initW || !initH) return false;

  const maxCanvasX = initW / 2 + 10; // small margin
  const maxCanvasY = initH / 2 + 10;

  return items.some((item) => {
    const rawX = (item.x ?? item.cx ?? 0) as number;
    const rawY = (item.y ?? item.cy ?? 0) as number;

    return Math.abs(rawX) > maxCanvasX || Math.abs(rawY) > maxCanvasY;
  });
}

// Helper function to detect motif category from motif src
function detectMotifCategory(motifSrc: string): string | null {
  for (const category of MotifsData) {
    const files = category.files.split(',');
    if (files.includes(motifSrc)) {
      return category.name.toLowerCase().replace(/\s+/g, '-').replace(/'/g, '');
    }
  }
  return null;
}

// Helper function to get motif path with fallback for spaces
function getMotifPath(motif: any): string {
  const baseSrc = motif.src || motif.name || motif.label || 'motif';
  // If the src contains spaces, remove them (proactive fix for file naming inconsistencies)
  const cleanSrc = baseSrc.replace(/\s+/g, '');
  return `/shapes/motifs/${cleanSrc}.svg`;
}

// Helper function to get fallback motif path (original with spaces - kept for backwards compatibility)
function getFallbackMotifPath(motif: any): string {
  const baseSrc = motif.src || motif.name || motif.label || 'motif';
  return `/shapes/motifs/${baseSrc}.svg`;
}

// Helper function to get predominant motif category from design
function getPredominantMotifCategory(designData: any[]): string | null {
  if (!designData) return null;
  
  const motifs = designData.filter((item: any) => item.type === 'Motif');
  if (motifs.length === 0) return null;
  
  // Count motifs by category
  const categoryCounts: Record<string, number> = {};
  
  for (const motif of motifs) {
    const src = motif.src;
    if (src) {
      const category = detectMotifCategory(src);
      if (category) {
        categoryCounts[category] = (categoryCounts[category] || 0) + 1;
      }
    }
  }
  
  // Find the category with most motifs
  let maxCount = 0;
  let predominantCategory: string | null = null;
  
  for (const [category, count] of Object.entries(categoryCounts)) {
    if (count > maxCount) {
      maxCount = count;
      predominantCategory = category;
    }
  }
  
  return predominantCategory;
}

interface DesignPageClientProps {
  productSlug: string;  // e.g., 'bronze-plaque'
  category: string;     // e.g., 'memorial', 'in-loving-memory'
  slug: string;         // e.g., '1724060510093_memorial-with-motifs'
  designId: string;
  design: SavedDesignMetadata;
}

// Component for design-specific content (SEO & programmatic content)
function DesignSpecificContent({ 
  shapeName, 
  productSlug, 
  categoryTitle,
  designTitle 
}: { 
  shapeName: string; 
  productSlug: string; 
  categoryTitle: string;
  designTitle: string;
}) {
  const [content, setContent] = useState({
    intro: '',
    layoutGuidance: '',
    sizes: '',
    approval: '',
    timeline: ''
  });

  useEffect(() => {
    // Generate shape-specific content
    const shapeGuidance: Record<string, { chars: string; lines: string; motifTip: string }> = {
      'Curved Gable': {
        chars: '30â€“40 characters per line',
        lines: '3â€“6 lines total',
        motifTip: 'crosses, doves, or floral sprays fit well in the lower arc'
      },
      'Curved Top': {
        chars: '35â€“45 characters per line',
        lines: '4â€“8 lines',
        motifTip: 'larger verses suit the extended curved area'
      },
      'Serpentine': {
        chars: '30â€“40 characters per line',
        lines: '3â€“6 lines',
        motifTip: 'softer shoulders perfect for side motif pairing'
      },
      'Ogee': {
        chars: '25â€“35 characters per line',
        lines: '3â€“5 lines',
        motifTip: 'elegant curves frame centered motifs beautifully'
      }
    };

    const guidance = shapeGuidance[shapeName] || {
      chars: '30â€“40 characters per line',
      lines: '3â€“6 lines',
      motifTip: 'motifs can be positioned throughout the design'
    };

    const productType = productSlug.includes('laser') ? 'laser-etched' : 
                       productSlug.includes('bronze') ? 'bronze' : 'traditional engraved';

    setContent({
      intro: `This ${shapeName} design is a classic ${productType} headstone that suits ${categoryTitle.toLowerCase()} inscriptions. The ${shapeName.toLowerCase()} shape frames a central family name beautifully, with space for meaningful text and decorative motifs. Most families choose Black Granite with a serif family name and a clean, highly legible verse font.`,
      layoutGuidance: `Top line (family name): up to 12 words; best at 2â€“3 words|Body lines: ${guidance.chars}, ${guidance.lines}|Motifs: ${guidance.motifTip}|Tip: keep the longest line in the center for visual balance`,
      sizes: 'Standard tablet sizes: 600Ã—600, 700Ã—500, 800Ã—600 mm|Finishes: Traditional Engraved, Laser Etched (photo-realistic), or Sandblasted|Granite: Black, Blue Pearl, Imperial Red, and 27 more options',
      approval: 'We prepare proofs for your cemetery and can help with permits. Installation is available through our certified installer network.',
      timeline: 'Lead time typically 2â€“3 weeks after proof approval (express available)'
    });
  }, [shapeName, productSlug, categoryTitle]);

  return (
    <div className="bg-white rounded-none md:rounded-lg border-0 md:border border-slate-200 shadow-none md:shadow-sm mb-4 md:mb-6">
      <div className="px-4 md:px-6 py-4 md:py-6">
        <h2 className="font-serif text-2xl text-slate-900 mb-4">About This Design</h2>
        
        {/* Introduction */}
        <p className="text-slate-700 mb-6" style={{ fontSize: '15px', lineHeight: '1.6' }}>
          {content.intro}
        </p>

        {/* Layout Guidance */}
        <div className="mb-6">
          <h3 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
            Layout Guidance for {shapeName}
          </h3>
          <ul className="space-y-2">
            {content.layoutGuidance.split('|').map((item, index) => (
              <li key={index} className="flex items-start gap-2 text-slate-700" style={{ fontSize: '15px' }}>
                <span className="text-amber-600 mt-1">â€¢</span>
                <span>{item}</span>
              </li>
            ))}
          </ul>
        </div>

        {/* Sizes & Options */}
        <div className="mb-6">
          <h3 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
            Sizes & Options
          </h3>
          <ul className="space-y-2">
            {content.sizes.split('|').map((item, index) => (
              <li key={index} className="flex items-start gap-2 text-slate-700" style={{ fontSize: '15px' }}>
                <span className="text-amber-600 mt-1">â€¢</span>
                <span>{item}</span>
              </li>
            ))}
          </ul>
        </div>

        {/* Cemetery Approval & Installation */}
        <div className="mb-6">
          <h3 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
            Cemetery Approval & Installation
          </h3>
          <p className="text-slate-700 mb-2" style={{ fontSize: '15px', lineHeight: '1.6' }}>
            {content.approval}
          </p>
          <p className="text-slate-700" style={{ fontSize: '15px', lineHeight: '1.6' }}>
            <strong>Timeline:</strong> {content.timeline}
          </p>
        </div>

        {/* CTAs */}
        <div className="flex flex-col sm:flex-row gap-3 pt-4 border-t border-slate-200">
          <button
            onClick={() => {
              // Scroll to the "Use Template" button or trigger edit
              const editButton = document.querySelector('a[href*="#edit"]');
              if (editButton instanceof HTMLAnchorElement) {
                editButton.click();
              }
            }}
            className="flex-1 inline-flex items-center justify-center gap-2 px-6 py-3 bg-slate-900 text-white rounded-lg hover:bg-slate-800 transition-all font-medium cursor-pointer"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
            </svg>
            Design This Memorial (Live Preview)
          </button>
          <a
            href="/contact"
            className="flex-1 inline-flex items-center justify-center gap-2 px-6 py-3 bg-white text-slate-900 border-2 border-slate-900 rounded-lg hover:bg-slate-50 transition-all font-medium"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
            </svg>
            Get Help From a Designer
          </a>
        </div>
      </div>
    </div>
  );
}

// Component to load and display product description from XML
function ProductDescription({ productSlug, productId }: { productSlug: string; productId: string }) {
  const [description, setDescription] = useState<string>('');
  const [sizes, setSizes] = useState<string>('');
  const [productName, setProductName] = useState<string>('');
  const [isExpanded, setIsExpanded] = useState(false);

  useEffect(() => {
    async function loadProductDescription() {
      try {
        // Map product slugs to XML tags
        const productMap: Record<string, { nameTag: string; descTag: string; sizeTag: string; xmlPath: string }> = {
          'traditional-headstone': {
            nameTag: 'traditional_engraved_headstone',
            descTag: 'traditional_engraved_headstone_description',
            sizeTag: 'headstone_sizes_traditional',
            xmlPath: '/xml/us_EN/languages24.xml'
          },
          'bronze-plaque': {
            nameTag: 'bronze_plaque',
            descTag: 'bronze_plaque_description',
            sizeTag: 'bronze_plaque_sizes',
            xmlPath: '/xml/us_EN/languages24.xml'
          },
          'laser-etched-headstone': {
            nameTag: 'laser_etched_black_granite_headstone',
            descTag: 'laser_etched_black_granite_headstone_description',
            sizeTag: 'headstone_sizes',
            xmlPath: '/xml/us_EN/languages24.xml'
          },
          'laser-etched-plaque': {
            nameTag: 'laser_etched_black_granite_plaque',
            descTag: 'laser_etched_black_granite_plaque_description',
            sizeTag: 'plaques_sizes',
            xmlPath: '/xml/us_EN/languages24.xml'
          },
          'traditional-plaque': {
            nameTag: 'traditional_engraved_plaque',
            descTag: 'traditional_engraved_plaque_description',
            sizeTag: 'traditional_plaques_sizes',
            xmlPath: '/xml/us_EN/languages24.xml'
          }
        };

        const productInfo = productMap[productSlug];
        if (!productInfo) return;

        const response = await fetch(productInfo.xmlPath);
        if (response.ok) {
          const xmlText = await response.text();
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

          // Extract product name
          const nameElement = xmlDoc.querySelector(productInfo.nameTag);
          if (nameElement) {
            setProductName(nameElement.textContent || '');
          }

          // Extract description
          const descElement = xmlDoc.querySelector(productInfo.descTag);
          if (descElement) {
            let desc = descElement.textContent || '';
            // Remove <br/> and <br> tags from the description
            desc = desc.replace(/<br\s*\/?>/gi, '');
            setDescription(desc);
          }

          // Extract sizes
          const sizeElement = xmlDoc.querySelector(productInfo.sizeTag);
          if (sizeElement) {
            let sizeText = sizeElement.textContent || '';
            // Remove <br/> and <br> tags from sizes
            sizeText = sizeText.replace(/<br\s*\/?>/gi, '');
            setSizes(sizeText);
          }
        }
      } catch (error) {
        console.error('Failed to load product description:', error);
      }
    }
    loadProductDescription();
  }, [productSlug]);

  if (!description && !sizes) return null;

  return (
    <div className="bg-white rounded-none md:rounded-lg border-0 md:border border-slate-200 overflow-hidden mb-4 md:mb-6 shadow-none md:shadow-sm">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="w-full px-4 md:px-6 py-3 md:py-4 flex items-center justify-between hover:bg-slate-50 transition-colors"
      >
        <h3 className="font-serif font-light text-xl text-slate-900 flex items-center gap-3">
          <svg className="w-6 h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span>Product Information</span>
        </h3>
        <svg 
          className={`w-5 h-5 text-slate-500 transition-transform ${isExpanded ? 'rotate-180' : ''}`}
          fill="none" 
          stroke="currentColor" 
          viewBox="0 0 24 24"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      
      {isExpanded && (
        <div className="px-4 md:px-6 pb-4 md:pb-6 border-t border-slate-200">
          {/* Text Description */}
          <div className="ml-0 md:ml-9 mt-6 mb-6">
            <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
              {productName}
            </h4>
            {description && (
              <div 
                className="prose max-w-none text-slate-700 mb-3"
                style={{ fontSize: '15px', lineHeight: '1.6' }}
                dangerouslySetInnerHTML={{ __html: description }}
              />
            )}
            {sizes && (
              <div 
                className="prose max-w-none text-slate-700"
                style={{ fontSize: '15px', lineHeight: '1.6' }}
                dangerouslySetInnerHTML={{ __html: sizes }}
              />
            )}
          </div>

          {/* Alternative Products Carousel */}
          <div className="ml-0 md:ml-9">
            <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '15px' }}>
              Use This Design On:
            </h4>
            <div className="flex gap-4 overflow-x-auto pb-4">
              {/* Show related products, excluding the current product */}
              <RelatedProductCard productId="124" currentProductId={productId} />
              <RelatedProductCard productId="4" currentProductId={productId} />
              <RelatedProductCard productId="22" currentProductId={productId} />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Component to display related product card
function RelatedProductCard({ productId, currentProductId }: { productId: string; currentProductId?: string }) {
  const [productName, setProductName] = useState<string>('');
  const [description, setDescription] = useState<string>('');
  const [showModal, setShowModal] = useState(false);

  useEffect(() => {
    async function loadProductInfo() {
      try {
        const langResponse = await fetch('/xml/us_EN/languages24.xml');
        if (!langResponse.ok) return;

        const langXml = await langResponse.text();
        const parser = new DOMParser();
        const langDoc = parser.parseFromString(langXml, 'text/xml');

        // Map product IDs to XML tags
        const productMap: Record<string, { nameTag: string; descTag: string }> = {
          '124': {
            nameTag: 'traditional_engraved_headstone',
            descTag: 'traditional_engraved_headstone_description'
          },
          '4': {
            nameTag: 'laser_etched_black_granite_headstone',
            descTag: 'laser_etched_black_granite_headstone_description'
          },
          '22': {
            nameTag: 'laser_etched_black_granite_mini_headstone',
            descTag: 'laser_etched_black_granite_mini_headstone_description'
          }
        };

        const productInfo = productMap[productId];
        if (!productInfo) return;

        // Get product name
        const nameElement = langDoc.querySelector(productInfo.nameTag);
        if (nameElement) {
          setProductName(nameElement.textContent || '');
        }

        // Get description
        const descElement = langDoc.querySelector(productInfo.descTag);
        if (descElement) {
          let desc = descElement.textContent || '';
          desc = desc.replace(/<br\s*\/?>/gi, '');
          setDescription(desc);
        }
      } catch (error) {
        console.error('Failed to load related product info:', error);
      }
    }
    loadProductInfo();
  }, [productId]);

  // Don't render if this is the current product
  if (currentProductId && productId === currentProductId) return null;
  
  if (!productName) return null;

  const productImagePath = `/jpg/products/APP_ID_${productId}-medium.jpg`;

  return (
    <>
      <div 
        className="flex-shrink-0 w-64 bg-white rounded-lg border border-slate-300 overflow-hidden hover:shadow-lg transition-shadow cursor-pointer"
        onClick={() => setShowModal(true)}
      >
        <img 
          src={productImagePath}
          alt={productName}
          className="w-full h-48 object-cover"
          onError={(e) => {
            (e.target as HTMLImageElement).style.display = 'none';
          }}
        />
        <div className="p-4">
          <div className="font-medium text-slate-900 mb-2" style={{ fontSize: '15px' }}>
            {productName}
          </div>
          {description && (
            <div 
              className="prose max-w-none text-slate-700 text-sm line-clamp-3"
              style={{ fontSize: '14px', lineHeight: '1.5' }}
              dangerouslySetInnerHTML={{ __html: description }}
            />
          )}
        </div>
      </div>

      {/* Related Product Modal */}
      {showModal && (
        <div 
          className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4"
          onClick={() => setShowModal(false)}
        >
          <div 
            className="bg-white rounded-lg shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="sticky top-0 bg-white border-b border-slate-200 px-6 py-4 flex items-center justify-between z-10">
              <h3 className="font-serif text-2xl text-slate-900">{productName}</h3>
              <button
                onClick={() => setShowModal(false)}
                className="text-slate-400 hover:text-slate-600 transition-colors"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <div className="p-6">
              <div className="mb-6">
                <img 
                  src={productImagePath}
                  alt={productName}
                  className="w-full rounded-lg"
                  style={{ maxHeight: '40vh', objectFit: 'contain' }}
                />
              </div>
              {description && (
                <div 
                  className="prose max-w-none text-slate-700"
                  style={{ fontSize: '15px', lineHeight: '1.6' }}
                  dangerouslySetInnerHTML={{ __html: description }}
                />
              )}
            </div>
          </div>
        </div>
      )}
    </>
  );
}

// Component to load and display personalization options
function PersonalizationOptions({ productId, productSlug }: { productId: string; productSlug: string }) {
  const [options, setOptions] = useState<Array<{ name: string; description: string; image?: string }>>([]);
  const [photoInfo, setPhotoInfo] = useState<string>('');
  const [motifInfo, setMotifInfo] = useState<string>('');
  const [inscriptionInfo, setInscriptionInfo] = useState<string>('');
  const [selectedOption, setSelectedOption] = useState<{ name: string; description: string; image?: string } | null>(null);
  const [isExpanded, setIsExpanded] = useState(false);

  useEffect(() => {
    async function loadPersonalizationOptions() {
      try {
        // Load catalog XML
        const catalogResponse = await fetch(`/xml/catalog-id-${productId}.xml`);
        if (!catalogResponse.ok) return;

        const catalogXml = await catalogResponse.text();
        const catalogParser = new DOMParser();
        const catalogDoc = catalogParser.parseFromString(catalogXml, 'text/xml');

        // Get additions
        const additions = catalogDoc.querySelectorAll('additions > addition');
        if (additions.length === 0) return;

        // Load language XML for descriptions
        const langResponse = await fetch('/xml/us_EN/languages24.xml');
        if (!langResponse.ok) return;

        const langXml = await langResponse.text();
        const langParser = new DOMParser();
        const langDoc = langParser.parseFromString(langXml, 'text/xml');

        // Get photo info text
        const photoInfoElement = langDoc.querySelector('photo_info_traditional');
        if (photoInfoElement) {
          let photoInfoText = photoInfoElement.textContent || '';
          // Remove <br/> tags
          photoInfoText = photoInfoText.replace(/<br\s*\/?>/gi, ' ');
          setPhotoInfo(photoInfoText);
        }

        // Get inscription info text
        const inscriptionInfoElement = langDoc.querySelector('inscriptions_info_traditional');
        if (inscriptionInfoElement) {
          let inscriptionInfoText = inscriptionInfoElement.textContent || '';
          // Remove <br/> tags
          inscriptionInfoText = inscriptionInfoText.replace(/<br\s*\/?>/gi, ' ');
          setInscriptionInfo(inscriptionInfoText);
        }

        // Get motif info text based on product type
        let motifInfoTag = 'motifs_info_trad'; // default
        if (productSlug.includes('laser-etched')) {
          motifInfoTag = 'motifs_info_laser';
        } else if (productSlug.includes('bronze')) {
          motifInfoTag = 'motifs_info_bronze';
        }
        
        const motifInfoElement = langDoc.querySelector(motifInfoTag);
        if (motifInfoElement) {
          let motifInfoText = motifInfoElement.textContent || '';
          // Remove <br/> tags
          motifInfoText = motifInfoText.replace(/<br\s*\/?>/gi, ' ');
          setMotifInfo(motifInfoText);
        }

        const optionsList: Array<{ name: string; description: string; image?: string }> = [];

        additions.forEach((addition) => {
          const name = addition.getAttribute('name');
          if (!name) return;

          // Skip inscription and motif as they're basic
          if (name === 'Inscription' || name === 'Motif') return;

          // Skip flower pot, hole, and base additions
          if (name === 'Flower Pot Hole' || name === 'Flower Pot' || name === 'Coloured Granite Headstone Base') return;

          // Map addition names to XML tags and images
          const tagMap: Record<string, { descTag: string; image?: string }> = {
            'Ceramic Photo': {
              descTag: 'ceramic_photo_description',
              image: 'product-ceramic-image.jpg'
            },
            'Vitreous Enamel Image': {
              descTag: 'vitreous_enamel_description',
              image: 'product-vitreous-enamel-image.jpg'
            },
            'Premium Plana': {
              descTag: 'premium_plana_description',
              image: 'plana.jpg'
            },
            'Flower Pot Hole': {
              descTag: 'flower_pot_holes'
            },
            'Flower Pot': {
              descTag: 'flower_pot_holes'
            },
            'Coloured Granite Headstone Base': {
              descTag: 'headstone_base'
            },
          };

          const tagInfo = tagMap[name];
          if (tagInfo) {
            const descElement = langDoc.querySelector(tagInfo.descTag);
            if (descElement) {
              let desc = descElement.textContent || '';
              // Remove <br/> and <br> tags from the description
              desc = desc.replace(/<br\s*\/?>/gi, '');
              // Remove upload instructions
              desc = desc.replace(/<p>Click to upload.*?<\/p>/gi, '');
              desc = desc.replace(/<div class='instructions'>.*?<\/div>/gi, '');
              optionsList.push({
                name: name,
                description: desc,
                image: tagInfo.image
              });
            }
          } else {
            // Add name without description
            optionsList.push({
              name: name,
              description: '',
              image: undefined
            });
          }
        });

        setOptions(optionsList);
      } catch (error) {
        console.error('Failed to load personalization options:', error);
      }
    }
    loadPersonalizationOptions();
  }, [productId, productSlug]);

  if (options.length === 0 && !photoInfo && !motifInfo && !inscriptionInfo) return null;

  const fonts = data.fonts;

  return (
    <div className="bg-white rounded-none md:rounded-lg border-0 md:border border-slate-200 overflow-hidden mb-4 md:mb-6 shadow-none md:shadow-sm">
      <button
        onClick={() => setIsExpanded(!isExpanded)}
        className="w-full px-4 md:px-6 py-3 md:py-4 flex items-center justify-between hover:bg-slate-50 transition-colors"
      >
        <h3 className="font-serif font-light text-lg md:text-xl text-slate-900 flex items-center gap-3">
          <svg className="w-5 h-5 md:w-6 md:h-6 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M11 4a2 2 0 114 0v1a1 1 0 001 1h3a1 1 0 011 1v3a1 1 0 01-1 1h-1a2 2 0 100 4h1a1 1 0 011 1v3a1 1 0 01-1 1h-3a1 1 0 01-1-1v-1a2 2 0 10-4 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1v-3a1 1 0 00-1-1H4a2 2 0 110-4h1a1 1 0 001-1V7a1 1 0 011-1h3a1 1 0 001-1V4z" />
          </svg>
          <span>Personalization Options</span>
        </h3>
        <svg 
          className={`w-5 h-5 text-slate-500 transition-transform ${isExpanded ? 'rotate-180' : ''}`}
          fill="none" 
          stroke="currentColor" 
          viewBox="0 0 24 24"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>
      
      {isExpanded && (
        <div className="px-4 md:px-6 pb-4 md:pb-6 border-t border-slate-200">
          {/* Inscriptions Section */}
          {inscriptionInfo && (
            <div className="ml-0 md:ml-9 space-y-4 mb-6 mt-6">
          <div>
            <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
              Inscriptions
            </h4>
            <div 
              className="text-slate-700 mb-4"
              style={{ fontSize: '15px', lineHeight: '1.6' }}
              dangerouslySetInnerHTML={{ __html: inscriptionInfo }}
            />
            
            {/* Font List */}
            <div className="mt-4">
              <h5 className="font-medium text-slate-900 mb-3" style={{ fontSize: '15px' }}>
                Available Fonts
              </h5>
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                {fonts.map((font) => (
                  <div
                    key={font.id}
                    className="px-3 py-2 bg-white rounded border border-slate-300 text-sm text-slate-700 hover:border-slate-400 hover:shadow-sm transition-all"
                    style={{ 
                      fontFamily: font.name === 'Arial' ? 'Arial, sans-serif' :
                                  font.name === 'Garamond' ? 'Garamond, serif' :
                                  font.name === 'Franklin Gothic' ? 'Franklin Gothic Medium, sans-serif' :
                                  font.name === 'Lucida Calligraphy' ? 'Lucida Calligraphy, cursive' :
                                  font.name === 'Chopin Script' ? 'cursive' :
                                  font.name === 'French Script' ? 'cursive' :
                                  font.name === 'Great Vibes' ? 'cursive' :
                                  font.name === 'Adorable' ? 'cursive' :
                                  font.name === 'Dobkin' ? 'serif' :
                                  font.name === 'Xirwena' ? 'fantasy' :
                                  'inherit'
                    }}
                  >
                    {font.name}
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
        )}
        
        {/* Granites Section */}
        <div className="ml-0 md:ml-9 space-y-4 mb-6 mt-6">
          <div>
          <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
            Granites
          </h4>
          
          {/* Materials Grid */}
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3">
            {data.materials.map((material) => (
               <div
                key={material.id}
                className="bg-white rounded-lg border border-slate-300 overflow-hidden hover:shadow-md transition-all cursor-pointer"
              >
                <div className="aspect-square bg-slate-100 flex items-center justify-center">
                  <img 
                    src={`/textures/forever/l/${material.image}`}
                    alt={material.name}
                    className="w-full h-full object-cover"
                    loading="lazy"
                  />
                </div>
                <div className="p-2 text-center">
                  <div className="text-xs font-medium text-slate-900">
                    {material.name}
                  </div>
                </div>
              </div>
            ))}
            </div>
          </div>
        </div>
        
        {/* Photos Section */}
        <div className="ml-0 md:ml-9 space-y-4">
        {photoInfo && (
          <div>
            <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
              Photos
            </h4>
            <div 
              className="text-slate-700"
              style={{ fontSize: '15px', lineHeight: '1.6' }}
              dangerouslySetInnerHTML={{ __html: photoInfo }}
            />
            </div>
          )}
        </div>
        <div className="ml-0 md:ml-9 space-y-4 mt-4">
        {options.length > 0 && (
          <div className="relative">
            {/* Carousel for options with images */}
            {options.some(opt => opt.image) && (
              <div className="mb-6">
                <div className="flex gap-4 overflow-x-auto pb-4 snap-x snap-mandatory scrollbar-hide">
                  {options.filter(opt => opt.image).map((option, index) => (
                    <div 
                      key={index} 
                      className="flex-shrink-0 snap-start cursor-pointer"
                      onClick={() => setSelectedOption(option)}
                    >
                      <div className="w-64 bg-white rounded-lg border border-slate-300 overflow-hidden hover:shadow-lg transition-shadow">
                        <img 
                          src={`/jpg/photos/m/${option.image}`}
                          alt={option.name}
                          className="w-full h-48 object-cover"
                        />
                        <div className="p-4">
                          <div className="font-medium text-slate-900 mb-2" style={{ fontSize: '15px' }}>
                            {option.name}
                          </div>
                          {option.description && (
                            <div 
                              className="prose max-w-none text-slate-700 text-sm line-clamp-3"
                              style={{ fontSize: '14px', lineHeight: '1.5' }}
                              dangerouslySetInnerHTML={{ __html: option.description }}
                            />
                          )}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
                <style jsx>{`
                  .scrollbar-hide::-webkit-scrollbar {
                    display: none;
                  }
                  .scrollbar-hide {
                    -ms-overflow-style: none;
                    scrollbar-width: none;
                  }
                  .line-clamp-3 {
                    display: -webkit-box;
                    -webkit-line-clamp: 3;
                    -webkit-box-orient: vertical;
                    overflow: hidden;
                  }
                `}</style>
              </div>
            )}
            
            {/* Options without images */}
            {options.filter(opt => !opt.image).map((option, index) => (
              <div key={index} className="mb-4">
                <div className="font-medium text-slate-900 mb-1" style={{ fontSize: '15px' }}>
                  {option.name}
                </div>
                {option.description && (
                  <div 
                    className="prose max-w-none text-slate-700"
                    style={{ fontSize: '15px', lineHeight: '1.6' }}
                    dangerouslySetInnerHTML={{ __html: option.description }}
                  />
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Motif Info and Categories */}
      {motifInfo && (
        <div className="ml-0 md:ml-9 mt-6">
          <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '16px' }}>
            Motifs
          </h4>
          <div 
            className="text-slate-700 mb-4"
            style={{ fontSize: '15px', lineHeight: '1.6' }}
            dangerouslySetInnerHTML={{ __html: motifInfo }}
          />
            <MotifCategories />
          </div>
        )}
      </div>
      )}

      {/* Photo Option Modal */}
      {selectedOption && (
        <div 
          className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4"
          onClick={() => setSelectedOption(null)}
        >
          <div 
            className="bg-white rounded-lg shadow-2xl max-w-3xl w-full max-h-[90vh] overflow-y-auto"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="sticky top-0 bg-white border-b border-slate-200 px-6 py-4 flex items-center justify-between z-10">
              <h3 className="font-serif text-2xl text-slate-900">{selectedOption.name}</h3>
              <button
                onClick={() => setSelectedOption(null)}
                className="text-slate-400 hover:text-slate-600 transition-colors"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
            <div className="p-6">
              {selectedOption.image && (
                <div className="mb-6">
                  <img 
                    src={`/jpg/photos/m/${selectedOption.image}`}
                    alt={selectedOption.name}
                    className="w-full rounded-lg"
                    style={{ maxHeight: '40vh', objectFit: 'contain' }}
                  />
                </div>
              )}
              {selectedOption.description && (
                <div 
                  className="prose max-w-none text-slate-700"
                  style={{ fontSize: '15px', lineHeight: '1.6' }}
                  dangerouslySetInnerHTML={{ __html: selectedOption.description }}
                />
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Component to display motif categories
function MotifCategories() {
  const motifs = data.motifs;

  return (
    <div>
      <h4 className="font-medium text-slate-900 mb-3" style={{ fontSize: '15px' }}>
        Browse Motif Categories
      </h4>
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
        {motifs.slice(0, 12).map((motif) => (
          <div
            key={motif.id}
            className="group relative overflow-hidden rounded-lg border border-slate-300 bg-white hover:border-slate-400 hover:shadow-md transition-all cursor-pointer"
          >
            <div className="p-3">
              <div className="mb-2 flex h-16 items-center justify-center">
                <img
                  src={motif.img}
                  alt={getMotifCategoryName(motif.name)}
                  className="h-full w-full object-contain"
                  loading="lazy"
                />
              </div>
              <div className="text-center">
                <div className="text-xs font-medium text-slate-900 truncate">
                  {getMotifCategoryName(motif.name)}
                </div>
                {motif.traditional && (
                  <span className="inline-block mt-1 rounded bg-slate-100 px-2 py-0.5 text-[10px] text-slate-700">
                    Traditional
                  </span>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
      {motifs.length > 12 && (
        <div className="mt-3 text-center">
          <p className="text-sm text-slate-600">
            Showing 12 of {motifs.length} categories
          </p>
        </div>
      )}
    </div>
  );
}

// Draggable component for inscriptions and motifs
function DraggableElement({ 
  children, 
  initialStyle,
  onPositionChange 
}: { 
  children: React.ReactNode; 
  initialStyle: React.CSSProperties;
  onPositionChange?: (x: number, y: number) => void;
}) {
  const [isDragging, setIsDragging] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const elementRef = useRef<HTMLDivElement>(null);

  const handleMouseDown = (e: React.MouseEvent) => {
    setIsDragging(true);
    setDragStart({
      x: e.clientX - position.x,
      y: e.clientY - position.y,
    });
    e.preventDefault();
  };

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isDragging) return;
    
    const newX = e.clientX - dragStart.x;
    const newY = e.clientY - dragStart.y;
    
    setPosition({ x: newX, y: newY });
    onPositionChange?.(newX, newY);
  }, [isDragging, dragStart, onPositionChange]);

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);

  return (
    <div
      ref={elementRef}
      onMouseDown={handleMouseDown}
      style={{
        ...initialStyle,
        transform: `${initialStyle.transform || ''} translate(${position.x}px, ${position.y}px)`,
        cursor: isDragging ? 'grabbing' : 'grab',
        userSelect: 'none',
      }}
    >
      {children}
    </div>
  );
}

export default function DesignPageClient({
  productSlug,
  category,
  slug,
  designId,
  design: designMetadata
}: DesignPageClientProps) {
  const router = useRouter();
  const [loadingIntoEditor, setLoadingIntoEditor] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showPreview, setShowPreview] = useState(true); // Always show preview, no editor
  const [motifDimensions, setMotifDimensions] = useState<Record<string, { width: number; height: number }>>({}); // Always show preview, no editor
  const loadAttempted = useRef(false);
  const setActivePanel = useHeadstoneStore((s) => s.setActivePanel);
  const [svgContent, setSvgContent] = useState<string | null>(null);
  const [svgDimensions, setSvgDimensions] = useState<{ width: number; height: number } | null>(null);
  const [screenshotDimensions, setScreenshotDimensions] = useState<{ width: number; height: number } | null>(null);
  const [cropBounds, setCropBounds] = useState<CropBounds | null>(null);
  const svgHostRef = useRef<HTMLDivElement>(null);
  const [displayScale, setDisplayScale] = useState(1);

  const { design: designData, loading } = useSavedDesign(designId, designMetadata.mlDir);
  
  // Analyze screenshot for white space and calculate crop bounds
  useEffect(() => {
    if (designMetadata.preview) {
      // Increased threshold to 50% to reduce false positives
      analyzeImageForCrop(designMetadata.preview, 50)
        .then(bounds => {
          setCropBounds(bounds);
          console.log('Auto-crop analysis complete:', {
            shouldCrop: bounds.shouldCrop,
            whiteSpace: bounds.whiteSpacePercentage.toFixed(2) + '%',
            original: { width: bounds.width, height: bounds.height },
            cropped: { width: bounds.croppedWidth, height: bounds.croppedHeight }
          });
        })
        .catch(err => {
          console.error('Failed to analyze screenshot for cropping:', err);
        });
    }
  }, [designMetadata.preview]);
  
  // Load screenshot dimensions - divide by DPR to get logical size and apply crop
  useEffect(() => {
    if (designMetadata.preview && designData && cropBounds) {
      const img = new Image();
      img.onload = () => {
        // Get the DPR used when design was created
        const designDPR = designData.find((item: any) => item.type === 'Headstone')?.dpr || 1;
        
        console.log('ðŸ“¸ Screenshot loading (design 1656040658203 check):', {
          designId: designMetadata.id,
          cropBounds: {
            shouldCrop: cropBounds.shouldCrop,
            whiteSpace: cropBounds.whiteSpacePercentage.toFixed(2) + '%',
            original: { width: cropBounds.width, height: cropBounds.height },
            cropped: { width: cropBounds.croppedWidth, height: cropBounds.croppedHeight }
          },
          imageActual: { width: img.width, height: img.height },
          dpr: designDPR
        });
        
        // Screenshot is captured at physical pixels (init_width Ã— DPR, init_height Ã— DPR)
        // But we need to work in LOGICAL canvas coordinates (init_width, init_height)
        // Use cropped dimensions if white space > 50% (threshold increased)
        const physicalWidth = cropBounds.shouldCrop ? cropBounds.croppedWidth : img.width;
        const physicalHeight = cropBounds.shouldCrop ? cropBounds.croppedHeight : img.height;
        
        // Calculate the ACTUAL DPR from the screenshot
        // (the screenshot might not match init_width Ã— dpr due to browser constraints)
        const headstoneData = designData.find((item: any) => item.type === 'Headstone');
        const initWidth = headstoneData?.init_width || 707;
        const initHeight = headstoneData?.init_height || 476;
        
        // Calculate effective DPR from actual screenshot size
        const effectiveDPR = physicalWidth / initWidth;
        
        console.log('Screenshot dimensions (with DPR analysis):', {
          original: { width: img.width, height: img.height },
          cropped: cropBounds.shouldCrop ? { width: cropBounds.croppedWidth, height: cropBounds.croppedHeight } : 'not needed',
          physical: { width: physicalWidth, height: physicalHeight },
          canvas: { width: initWidth, height: initHeight },
          dpr: { 
            fromJSON: designDPR,
            calculated: effectiveDPR.toFixed(4),
            note: 'Using calculated DPR from actual screenshot size'
          }
        });
        
        // Store the canvas dimensions (logical space for coordinate system)
        setScreenshotDimensions({ width: initWidth, height: initHeight });
      };
      img.src = designMetadata.preview;
    }
  }, [designMetadata.preview, designData, cropBounds]);
  
  // Load name databases for accurate name detection
  const [nameDatabase, setNameDatabase] = useState<{
    firstNames: Set<string>;
    surnames: Set<string>;
    femaleNames?: string[];
    maleNames?: string[];
  } | null>(null);

  useEffect(() => {
    // Load name databases
    Promise.all([
      fetch('/json/firstnames_f.json').then(r => r.json()),
      fetch('/json/firstnames_m.json').then(r => r.json()),
      fetch('/json/surnames.json').then(r => r.json()),
    ]).then(([femaleNames, maleNames, surnames]) => {
      // Combine and convert to Sets for fast lookup (case-insensitive)
      const firstNames = new Set([
        ...femaleNames.map((n: string) => n.toUpperCase()),
        ...maleNames.map((n: string) => n.toUpperCase()),
      ]);
      const surnameSet = new Set(surnames.map((n: string) => n.toUpperCase()));
      
      setNameDatabase({ 
        firstNames, 
        surnames: surnameSet,
        // Store separate arrays for gender-specific selection
        femaleNames: femaleNames,
        maleNames: maleNames,
        firstNamesArray: [...femaleNames, ...maleNames],
        surnamesArray: surnames,
      } as any);
    }).catch(err => {
      console.error('Failed to load name databases:', err);
    });
  }, []);
  
  // Determine if category is female, male, or neutral
  const getGenderFromCategory = useCallback((categoryName: string): 'female' | 'male' | 'neutral' => {
    const lower = categoryName.toLowerCase();
    
    // Female categories
    if (lower.includes('mother') || lower.includes('daughter') || lower.includes('wife') || 
        lower.includes('sister') || lower.includes('grandmother') || lower.includes('nanna') ||
        lower.includes('grandma') || lower.includes('aunt') || lower.includes('woman') ||
        lower.includes('lady') || lower.includes('girl')) {
      return 'female';
    }
    
    // Male categories
    if (lower.includes('father') || lower.includes('son') || lower.includes('husband') || 
        lower.includes('brother') || lower.includes('grandfather') || lower.includes('papa') ||
        lower.includes('grandpa') || lower.includes('uncle') || lower.includes('man') ||
        lower.includes('gentleman') || lower.includes('boy') || lower.includes('dad')) {
      return 'male';
    }
    
    return 'neutral';
  }, []);
  
  // Simple hash function to convert string to number for consistent randomization
  const hashString = useCallback((str: string): number => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
  }, []);

  // Generate a random name based on a seed and category gender (for consistent results)
  const getRandomName = useCallback((seed?: string): string => {
    if (!nameDatabase || !(nameDatabase as any).firstNamesArray || !(nameDatabase as any).surnamesArray) {
      return 'Name';
    }

    const gender = getGenderFromCategory(category);
    const femaleNames = (nameDatabase as any).femaleNames || [];
    const maleNames = (nameDatabase as any).maleNames || [];
    const surnamesArray = (nameDatabase as any).surnamesArray;
    
    // Choose appropriate name list based on category gender
    let firstNamesArray;
    if (gender === 'female' && femaleNames.length > 0) {
      firstNamesArray = femaleNames;
    } else if (gender === 'male' && maleNames.length > 0) {
      firstNamesArray = maleNames;
    } else {
      // Neutral or fallback - use combined list
      firstNamesArray = (nameDatabase as any).firstNamesArray;
    }
    
    // Use seed to get consistent "random" values
    const seedValue = seed ? hashString(seed) : Math.floor(Math.random() * 10000);
    const randomFirstName = firstNamesArray[seedValue % firstNamesArray.length];
    const randomSurname = surnamesArray[(seedValue + 1) % surnamesArray.length];
    
    return `${randomFirstName} ${randomSurname}`;
  }, [nameDatabase, hashString, category, getGenderFromCategory]);
  
  // Get a random surname based on a seed (for consistent results)
  const getRandomSurname = useCallback((seed?: string): string => {
    if (!nameDatabase || !(nameDatabase as any).surnamesArray) {
      return 'Surname';
    }

    const surnamesArray = (nameDatabase as any).surnamesArray;
    const seedValue = seed ? hashString(seed) : Math.floor(Math.random() * 10000);
    return surnamesArray[seedValue % surnamesArray.length];
  }, [nameDatabase, hashString]);
  
  // Get a random first name based on a seed (for consistent results)
  const getRandomFirstName = useCallback((seed?: string): string => {
    if (!nameDatabase || !(nameDatabase as any).firstNamesArray) {
      return 'Name';
    }

    const firstNamesArray = (nameDatabase as any).firstNamesArray;
    
    // Get gender from category for appropriate name selection
    const gender = getGenderFromCategory(category);
    
    // Filter by gender if available
    let filteredNames = firstNamesArray;
    if (nameDatabase.firstNames && gender !== 'neutral') {
      // Get names for specific gender
      filteredNames = firstNamesArray.filter((name: string) => {
        const nameUpper = name.toUpperCase();
        const nameData = (nameDatabase as any).firstNamesData?.[nameUpper];
        if (!nameData) return true; // Include if no gender data
        return nameData.gender === gender || nameData.gender === 'neutral';
      });
      
      // Fallback to all names if no gender-specific names found
      if (filteredNames.length === 0) {
        filteredNames = firstNamesArray;
      }
    }
    
    const seedValue = seed ? hashString(seed) : Math.floor(Math.random() * 10000);
    return filteredNames[seedValue % filteredNames.length];
  }, [nameDatabase, hashString, category, getGenderFromCategory]);
  
  // Extract generic name from slug (e.g., "1752154675017_son-memorial" -> "Son Memorial")
  const genericName = useMemo(() => {
    if (!slug) return 'Name';
    // Remove timestamp prefix and convert to title case
    const parts = slug.split('_');
    if (parts.length > 1) {
      // Remove the timestamp part (first part)
      const namePart = parts.slice(1).join(' ');
      // Convert to title case
      return namePart.split('-').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
    }
    return 'Name';
  }, [slug]);

  // Function to sanitize inscription text - replace likely names with generic version
  const sanitizeInscription = useCallback((text: string): string => {
    // Don't sanitize common phrases (exact matches or containing these patterns)
    const commonPhrases = [
      'IN LOVING MEMORY',
      'OF',
      'LOVING',
      'SON',
      'DAUGHTER',
      'BROTHER',
      'SISTER',
      'MOTHER',
      'FATHER',
      'WIFE',
      'HUSBAND',
      'FOREVER',
      'REST IN PEACE',
      'RIP',
      'R.I.P',
      'R.I.P.',
      'BELOVED',
      'CHERISHED',
      'ALWAYS',
      'REMEMBERED',
    ];
    
    // Common memorial phrases that should never be replaced
    const memorialPhrases = [
      'WILL ALWAYS BE IN OUR HEARTS',
      'FOREVER IN OUR HEARTS',
      'ALWAYS IN OUR HEARTS',
      'IN OUR HEARTS FOREVER',
      'GONE BUT NOT FORGOTTEN',
      'FOREVER LOVED',
      'ALWAYS LOVED',
      'DEARLY LOVED',
      'FOREVER MISSED',
      'DEEPLY MISSED',
      'GREATLY MISSED',
      'YOUR LIFE WAS A BLESSING',
      'YOUR MEMORY A TREASURE',
      'SHE MADE BROKEN LOOK BEAUTIFUL',
      'UNIVERSE ON HER SHOULDERS',
      'BELOVED MOTHER',
      'BELOVED FATHER',
      'BELOVED GRANDMOTHER',
      'BELOVED GRANDFATHER',
      'BELOVED WIFE',
      'BELOVED HUSBAND',
      'LOVING MOTHER',
      'LOVING FATHER',
      'DEVOTED MOTHER',
      'DEVOTED FATHER',
      'A LIFE LIVED WITH PASSION',
      'A LOVE THAT NEVER FADED',
      'A LIFE LIVED WITH PASSION, A LOVE THAT NEVER FADED',
    ];
    
    const upperText = text.toUpperCase().trim();
    const upperTextNoPunctuation = upperText.replace(/[.,!?;:'"]/g, '');
    
    // Check if this is an exact match to a memorial phrase
    if (memorialPhrases.some(phrase => upperText === phrase || upperText.includes(phrase))) {
      return text;
    }
    
    // Check if this is an exact match to a common phrase (with or without punctuation)
    if (commonPhrases.includes(upperText) || commonPhrases.includes(upperTextNoPunctuation)) {
      return text;
    }
    
    // Check if this is a quote (surrounded by quotes or has quote marks)
    if ((text.startsWith('"') && text.endsWith('"')) || 
        (text.startsWith("'") && text.endsWith("'")) ||
        text.includes('"FOREVER') || 
        text.includes('"#')) {
      return text;
    }
    
    // Skip relationship descriptions (these should not be replaced)
    const relationshipWords = /\b(beloved|loving|cherished|dear|dearest|devoted|precious|adored|treasured|father|mother|son|daughter|brother|sister|grandfather|grandmother|uncle|aunt|wife|husband|grandson|granddaughter|great-grandfather|great-grandmother|friend)\b/i;
    if (relationshipWords.test(text.toLowerCase())) {
      // But also check if it ends with "to" or "of" (relationship descriptions like "Father to" or "Mother of")
      if (/\b(to|of)\s*$/i.test(text)) {
        return text; // Keep relationship descriptions as-is
      }
    }
    
    // Check if this is a date pattern WITHOUT names
    // First check if text contains dates
    const hasDatePattern = /\d{1,2}[,\/\-\s]+\d{1,4}/.test(text) || 
        /(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)/i.test(text) ||
        /\d{4}\s*-\s*\d{4}/.test(text) ||
        /\d{2}\/\d{2}\/\d{4}/.test(text);
    
    // If it has a date pattern, check if it's ONLY dates (no names)
    if (hasDatePattern) {
      // Remove all date-related content and see if there's anything left that could be a name
      const textWithoutDates = text
        .replace(/\d{4}\s*-\s*\d{4}/g, '') // Remove year ranges like "1916 - 1996"
        .replace(/\d{1,2}[,\/\-\s]+\d{1,4}/g, '') // Remove dates like "23, 1936" or "12/25/2000"
        .replace(/\d{2}\/\d{2}\/\d{4}/g, '') // Remove full dates
        .replace(/(?:JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER)/gi, '') // Remove month names
        .replace(/\s+/g, ' ') // Normalize spaces
        .trim();
      
      // If nothing or very little remains, it's just dates
      if (textWithoutDates.length === 0 || textWithoutDates === '-') {
        return text;
      }
    }
    
    // Split into words for analysis
    const words = text.split(/\s+/).filter(w => w.length > 0);
    
    // If we have name database loaded, check for names even if dates are present
    if (nameDatabase && words.length >= 1) {
      const upperWords = words.map(w => w.toUpperCase().replace(/['".,!?]/g, ''));
      
      // Check if it contains known first names or surnames
      const hasFirstName = upperWords.some(w => nameDatabase.firstNames.has(w));
      const hasSurname = upperWords.some(w => nameDatabase.surnames.has(w));
      
      // If it's ONLY a first name (single word that is a first name), replace with just a random first name
      // Even if the name exists in both first and surname databases, treat single words as first names
      if (hasFirstName && words.length === 1 && !hasDatePattern) {
        const randomFirstName = getRandomFirstName(text); // Use original text as seed
        const isAllCaps = text === text.toUpperCase();
        console.log('Single first name detected:', text, 'â†’', randomFirstName, '(all caps:', isAllCaps, ') [hasSurname:', hasSurname, ']');
        return isAllCaps ? randomFirstName.toUpperCase() : randomFirstName;
      }
      
      // If it's ONLY a surname (single word that is a surname but NOT a first name), replace with just a random surname
      if (hasSurname && !hasFirstName && words.length === 1 && !hasDatePattern) {
        const randomSurname = getRandomSurname(text); // Use original text as seed
        const isAllCaps = text === text.toUpperCase();
        console.log('Single surname detected:', text, 'â†’', randomSurname, '(all caps:', isAllCaps, ')');
        return isAllCaps ? randomSurname.toUpperCase() : randomSurname;
      }
      
      // If we find both first name and surname (with or without dates)
      if ((hasFirstName && hasSurname) || (hasFirstName && words.length >= 2)) {
        console.log('Full name or multi-word detected:', text, 'hasFirstName:', hasFirstName, 'hasSurname:', hasSurname, 'words:', words.length);
        // Check it's not a poetic verse with sentence words
        const hasSentenceWords = /\b(the|you|me|my|your|when|feel|know|am|are|is|see|being|part|of|and|or|not|lost|may|be|thine|thy|thee|heaven|eternal|happiness|shall|will|has|had|was|were|would|could|should|our|their|us|we)\b/i.test(text);
        if (!hasSentenceWords) {
          // If text contains dates, replace name but keep dates
          if (hasDatePattern) {
            const randomName = getRandomName(text); // Use original text as seed
            const isAllCaps = text === text.toUpperCase();
            const nameToUse = isAllCaps ? randomName.toUpperCase() : randomName;
            
            // Replace the name part while keeping the date part
            // Match pattern: "Name Surname YYYY - YYYY" or similar
            const dateMatch = text.match(/(\d{4}\s*-\s*\d{4}|\d{1,2}[,\/\-\s]+\d{1,4}|\d{2}\/\d{2}\/\d{4})/);
            if (dateMatch) {
              // Keep everything from the date onwards
              const dateAndAfter = text.substring(text.indexOf(dateMatch[0]));
              return `${nameToUse} ${dateAndAfter}`;
            }
          }
          
          // Return random name in same case format as input (no dates)
          const randomName = getRandomName(text); // Use original text as seed
          const isAllCaps = text === text.toUpperCase();
          if (isAllCaps) {
            return randomName.toUpperCase();
          } else {
            return randomName;
          }
        }
      }
    }
    
    // Fallback pattern-based detection (if database not loaded yet)
    // Check for title case names (e.g., "Cameron Anthony Fyfe")
    const isTitleCaseName = words.length >= 2 && 
      words.every(word => /^[A-Z][a-z]+$/.test(word)) &&
      !words.some(word => ['The', 'When', 'You', 'Feel', 'Know', 'See', 'Being', 'Part', 'And', 'Or', 'Am', 'Are', 'Is', 'Not', 'Lost'].includes(word));
    
    if (isTitleCaseName) {
      return getRandomName(text);
    }
    
    // Check if this is a poetic/memorial verse
    const hasLowerCase = /[a-z]/.test(text);
    const isShortPhrase = words.length <= 8;
    const hasSentenceWords = /\b(the|you|me|my|your|when|feel|know|am|are|is|see|being|part|of|and|or|not|lost)\b/i.test(text);
    
    if (hasLowerCase && isShortPhrase && hasSentenceWords) {
      return text;
    }
    
    // Check if text contains ALL CAPS name patterns
    const isAllCapsOrMixedCaps = /^[A-Z\s'-]+$/.test(text) && words.length >= 2;
    const isAllCapsSingleWord = /^[A-Z'-]+$/.test(text) && words.length === 1;
    const hasApostrophe = text.includes("'") || text.includes('&apos;');
    const hasSuffix = /\b(JR\.?|SR\.?|III|II|IV)\b/i.test(text);
    
    // Single word all caps - check if it's a first name or surname
    if (isAllCapsSingleWord && !hasSentenceWords && nameDatabase) {
      const upperWord = text.toUpperCase().replace(/['".,!?]/g, '');
      const isFirstName = nameDatabase.firstNames?.has(upperWord);
      const isSurname = nameDatabase.surnames?.has(upperWord);
      
      console.log('Fallback ALL CAPS single word:', text, 'isFirstName:', isFirstName, 'isSurname:', isSurname);
      
      if (isFirstName && !isSurname) {
        // It's a first name - return just a random first name
        const randomFirstName = getRandomFirstName(text);
        console.log('â†’ Returning first name only:', randomFirstName.toUpperCase());
        return randomFirstName.toUpperCase();
      } else {
        // It's a surname or unknown - return surname
        const randomSurname = getRandomSurname(text);
        console.log('â†’ Returning surname only:', randomSurname.toUpperCase());
        return randomSurname.toUpperCase();
      }
    }
    
    if ((isAllCapsOrMixedCaps || hasSuffix) && !hasSentenceWords) {
      return getRandomName(text).toUpperCase();
    }
    
    return text;
  }, [nameDatabase, getRandomName, getRandomSurname, getRandomFirstName]);
  
  // Extract shape name and map to SVG file
  const shapeName = useMemo(() => {
    if (!designData) return null;
    const shapeItem = designData.find((item: any) => item.shape);
    return shapeItem?.shape;
  }, [designData]);

  // Extract shape, texture, and motif data from designData
  const shapeData = useMemo(() => {
    if (!designData) return null;
    const shapeItem = designData.find((item: any) => item.type === 'HeadStone' || item.type === 'Headstone');
    return shapeItem;
  }, [designData]);

  // Pre-process design data to sanitize all inscriptions
  const sanitizedDesignData = useMemo(() => {
    if (!designData || !nameDatabase) return designData;
    
    return designData.map((item: any) => {
      if (item.type === 'Inscription' && item.label) {
        return {
          ...item,
          label: sanitizeInscription(item.label),
        };
      }
      return item;
    });
  }, [designData, nameDatabase, sanitizeInscription]);

  // Map shape name to SVG filename
  const shapeImagePath = useMemo(() => {
    if (!shapeName || !shapeData) return null;
    
    // Check if this is a landscape orientation (width > height)
    const isLandscape = (shapeData.width || 0) > (shapeData.height || 0);
    
    // Map shape names to their SVG files - direct mapping
    const shapeMap: Record<string, string> = {
      'Cropped Peak': 'cropped_peak.svg',
      'Curved Gable': 'curved_gable.svg',
      'Curved Peak': 'curved_peak.svg',
      'Curved Top': 'curved_top.svg',
      'Half Round': 'half_round.svg',
      'Gable': 'gable.svg',
      'Left Wave': 'left_wave.svg',
      'Peak': 'peak.svg',
      'Right Wave': 'right_wave.svg',
      'Serpentine': isLandscape ? 'serpentine_landscape.svg' : 'serpentine.svg',
      'Square': 'square.svg',
      'Rectangle': 'square.svg',  // Use square.svg for Rectangle too (clean coordinates)
      // Guitar shapes
      'Guitar 1': 'headstone_3.svg',
      'Guitar 2': 'headstone_4.svg',
      'Guitar 3': 'headstone_5.svg',
      'Guitar 4': 'headstone_6.svg',
      'Guitar 5': 'headstone_7.svg',
    };
    
    // Check if it's in the map
    if (shapeMap[shapeName]) {
      return `/shapes/headstones/${shapeMap[shapeName]}`;
    }
    
    // For numbered headstones (e.g., "Headstone 27"), extract the number and map directly
    const match = shapeName.match(/^Headstone (\d+)$/);
    if (match) {
      const number = match[1];
      return `/shapes/headstones/headstone_${number}.svg`;
    }
    
    return null;
  }, [shapeName, shapeData]);

  // FIX #2: Helper function to convert legacy saved coordinates back to canvas space
  const toCanvasCoordsLegacy = useCallback((xSaved: number, ySaved: number, legacyScale: number) => {
    // Legacy scale == old ratio_height used for both x and y
    return { x: xSaved / legacyScale, y: ySaved / legacyScale };
  }, []);

  // FIX #7: Auto-detect legacy vs axis-correct coordinates for X
  const inferCanvasX = useCallback((
    savedX: number,
    ratioW: number,
    ratioH: number,
    canvasW: number,
    marginPx = 8
  ) => {
    // Two candidates: old bug (Ã·ratioH) vs correct (Ã·ratioW)
    const xBug = savedX / ratioH;   // legacy
    const xFixed = savedX / ratioW; // axis-correct

    const halfW = canvasW / 2;
    const inside = (x: number) => Math.abs(x) <= halfW + marginPx;

    const insideBug = inside(xBug);
    const insideFixed = inside(xFixed);

    // If both are valid, pick the one with more horizontal spread (closer to edges)
    if (insideBug && insideFixed) {
      return Math.abs(xFixed) > Math.abs(xBug) ? xFixed : xBug;
    }
    // If only one is valid, use it
    if (insideFixed) return xFixed;
    if (insideBug) return xBug;

    // Fallback: clamp axis-correct
    return Math.max(-halfW, Math.min(halfW, xFixed));
  }, []);

  // Calculate scaling factors for positioning inscriptions
  const scalingFactors = useMemo(() => {
    // 1. Find the Authoring Frame (The "Truth")
    const headstoneData = designData?.find((item: any) => item.type === 'Headstone');
    const shapeDataFallback = shapeData || {};
    
    // Canvas Dimensions (The Workspace)
    const initW = headstoneData?.init_width || shapeDataFallback.init_width || 800;
    const initH = headstoneData?.init_height || shapeDataFallback.init_height || 800;
    const designDpr = headstoneData?.dpr || shapeDataFallback.dpr || 1;

    // 2. Detect Coordinate System
    const layoutItems = designData?.filter((i: any) => i.type === 'Inscription' || i.type === 'Motif') || [];
    
    // Check if items are positioned way outside logical bounds (indicating physical pixels)
    const usesPhysicalCoords = layoutItems.some((item: any) => {
      const x = item.x ?? 0;
      const y = item.y ?? 0;
      return Math.abs(x) > (initW / 2 + 50) || Math.abs(y) > (initH / 2 + 50);
    });

    // 3. Determine Display Dimensions (Responsive)
    const viewportWidth = typeof window !== 'undefined' ? window.innerWidth : 1200;
    const isMobile = viewportWidth < 768;
    
    // Mobile: 90% of screen width. Desktop: Max 600px.
    const maxContainerWidth = isMobile ? viewportWidth * 0.92 : 600;
    
    // Calculate the display width maintaining aspect ratio of the CANVAS
    let displayWidth = Math.min(initW, maxContainerWidth);
    
    // If high-res legacy design, ensure we don't render tiny on desktop
    if (usesPhysicalCoords && displayWidth < 400) displayWidth = 400;

    const aspectRatio = initW / initH;
    const displayHeight = displayWidth / aspectRatio;

    // 4. Calculate Scales
    
    // A. Layout Scale: How do logical canvas units map to screen pixels?
    // This is strictly (Screen Width / Logical Canvas Width)
    const layoutScale = displayWidth / initW;

    // B. Content Scale: How do Child coordinates map to screen pixels?
    // If children use physical coordinates (multiplied by DPR), we must divide by DPR first.
    const normalizationFactor = usesPhysicalCoords ? (1 / designDpr) : 1;
    const uniformScale = layoutScale * normalizationFactor;

    console.log('ðŸ“ Layout Calculation:', {
      initW, initH, designDpr, usesPhysicalCoords,
      viewportWidth, displayWidth, displayHeight,
      uniformScale, layoutScale
    });

    return { 
      // Global Scene Values
      scaleX: uniformScale, 
      scaleY: uniformScale, 
      displayWidth, 
      displayHeight, 
      offsetX: displayWidth / 2, // Center of Scene
      offsetY: displayHeight / 2, // Center of Scene
      
      // Canvas Data
      initW,
      initH,
      designDpr,
      usesPhysicalCoords,
      uniformScale,
      
      // Legacy compatibility
      upscaleFactor: 1,
      containerScalingMultiplier: 1,
      ratioWidth: 1,
      ratioHeight: 1,
      legacyScale: 1,
      canvasCropLeft: 0,
      canvasCropTop: 0
    };
  }, [designData, shapeData]);

  const textureData = useMemo(() => {
    if (!designData) return null;
    const textureItem = designData.find((item: any) => item.texture);
    if (!textureItem?.texture) return null;
    
    // Extract texture path from saved design (e.g., "src/granites/forever2/l/17.jpg" or "src/granites/forever2/l/White-Carrara-600-x-600.jpg")
    const savedTexturePath = textureItem.texture;
    
    // Mapping from old texture paths to new material image filenames
    const textureMapping: Record<string, string> = {
      'forever2/l/17.jpg': 'Glory-Black-1.jpg', // Glory Gold Spots
      'forever2/l/18.jpg': 'Glory-Black-2.jpg', // Glory Black
    };
    
    // Try to match the texture path with our mapping
    for (const [oldPath, newImage] of Object.entries(textureMapping)) {
      if (savedTexturePath.includes(oldPath)) {
        return `/textures/forever/l/${newImage}`;
      }
    }
    
    // Extract the granite name from the filename
    // Handles formats like: "White-Carrara-600-x-600.jpg", "G633-TILE-900-X-900.jpg", "G633.jpg"
    const match = savedTexturePath.match(/\/([A-Z][A-Za-z0-9-]+?)(?:-TILE)?-\d+-[xX]-\d+\.jpg$/i);
    if (match && match[1]) {
      const graniteName = match[1];
      // Map to our texture system: /textures/forever/l/White-Carrara.jpg
      return `/textures/forever/l/${graniteName}.jpg`;
    }
    
    // Fallback: try to extract any filename and use it
    const filename = savedTexturePath.split('/').pop();
    if (filename) {
      // Remove -TILE-900-X-900 or -600-x-600 suffix if present
      const cleanFilename = filename.replace(/(-TILE)?-\d+-[xX]-\d+/i, '');
      return `/textures/forever/l/${cleanFilename}`;
    }
    
    return savedTexturePath;
  }, [designData]);

  // Load and process SVG with texture
  useEffect(() => {
    console.log('ðŸ” SVG useEffect check:', {
      shapeImagePath: !!shapeImagePath,
      textureData: !!textureData,
      shapeData: !!shapeData,
      screenshotDimensions: !!screenshotDimensions,
      cropBounds: !!cropBounds,
      values: {
        shapeImagePath,
        textureData,
        screenshotDimensions,
        cropBounds: cropBounds ? { width: cropBounds.width, height: cropBounds.height, shouldCrop: cropBounds.shouldCrop } : null
      }
    });
    
    if (!shapeImagePath || !textureData || !shapeData || !screenshotDimensions || !cropBounds) {
      console.log('âŒ SVG generation skipped - missing dependencies');
      setSvgContent(null);
      return;
    }
    
    console.log('âœ… All dependencies available, fetching SVG from:', shapeImagePath);
    
    fetch(shapeImagePath)
      .then(res => {
        console.log('ðŸ“¥ SVG fetch response:', res.status, res.ok);
        return res.text();
      })
      .then(svgText => {
        console.log('ðŸ“„ SVG text received, length:', svgText.length);
        // Parse SVG and inject texture pattern
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgText, 'image/svg+xml');
        const svg = doc.querySelector('svg');
        
        console.log('ðŸ” SVG element found:', !!svg);
        
        if (svg) {
          // Check if this is a fixed-proportion shape (Guitar or Headstone)
          const isFixedProportionShape = shapeName && (
            shapeName.toLowerCase().includes('guitar') || 
            shapeName.toLowerCase().includes('headstone')
          );
          
          const designDPR = shapeData.dpr || 1;
          const designDevice = shapeData.device || 'desktop';
          const isDesktopDesign = designDevice === 'desktop';
          
          // screenshotDimensions now holds canvas size (logical init_width/height)
          // Get physical screenshot size for display
          const canvasWidth = screenshotDimensions.width;
          const canvasHeight = screenshotDimensions.height;
          
          // Calculate physical size from canvas and actual DPR
          const headstoneData = designData?.find((item: any) => item.type === 'Headstone');
          
          console.log('ðŸ“Š Headstone item data:', {
            x: headstoneData?.x,
            y: headstoneData?.y,
            width: headstoneData?.width,
            height: headstoneData?.height,
            allKeys: headstoneData ? Object.keys(headstoneData) : []
          });
          
          const physicalWidth = cropBounds.shouldCrop ? cropBounds.croppedWidth : cropBounds.width;
          const physicalHeight = cropBounds.shouldCrop ? cropBounds.croppedHeight : cropBounds.height;
          
          // Display dimensions: scale physical by upscale factor
          const upscaleFactor = (!isDesktopDesign && designDPR > 1) ? 2 : 1;
          const displayWidth = physicalWidth * upscaleFactor;
          const displayHeight = physicalHeight * upscaleFactor;
          
          console.log('SVG Processing:', {
            canvas: { width: canvasWidth, height: canvasHeight },
            physical: { width: physicalWidth, height: physicalHeight },
            display: { width: displayWidth, height: displayHeight },
            upscaleFactor,
            dpr: designDPR
          });
          
          // Get original viewBox dimensions (SVG's natural size)
          const viewBoxAttr = svg.getAttribute('viewBox');
          let originalWidth = 400;
          let originalHeight = 400;
          
          if (viewBoxAttr) {
            const viewBoxParts = viewBoxAttr.split(' ');
            if (viewBoxParts.length >= 4) {
              originalWidth = parseFloat(viewBoxParts[2]);
              originalHeight = parseFloat(viewBoxParts[3]);
            }
          }
          
          console.log('SVG original dimensions from viewBox:', { originalWidth, originalHeight });
          
          // Store SVG dimensions for container sizing
          setSvgDimensions({ width: originalWidth, height: originalHeight });
          
          // Calculate how to scale SVG to fit authoring frame
          // We want the SVG to fill as much of the authoring frame as possible
          // while maintaining aspect ratio (similar to object-fit: contain)
          const scaleX = canvasWidth / originalWidth;
          const scaleY = canvasHeight / originalHeight;
          const svgScale = Math.min(scaleX, scaleY); // Fit within frame
          
          const scaledSvgWidth = originalWidth * svgScale;
          const scaledSvgHeight = originalHeight * svgScale;
          
          console.log('SVG scaling to authoring frame:', {
            original: { width: originalWidth, height: originalHeight },
            authoring: { width: canvasWidth, height: canvasHeight },
            scale: svgScale,
            scaled: { width: scaledSvgWidth, height: scaledSvgHeight }
          });
          
          // Instead of changing viewBox, apply transform to scale and center the SVG content
          // This preserves the original coordinates while making it fit the authoring frame
          // The authoring frame is initW Ã— initH (e.g., 414Ã—660)
          // The SVG native size is originalWidth Ã— originalHeight (e.g., 400Ã—400)
          // We need to scale the viewBox to fill the authoring frame
          const svgToAuthoringScaleX = canvasWidth / originalWidth;
          const svgToAuthoringScaleY = canvasHeight / originalHeight;
          
          console.log('SVG to authoring scale:', {
            canvasWidth,
            canvasHeight,
            originalWidth,
            originalHeight,
            svgToAuthoringScaleX,
            svgToAuthoringScaleY
          });
          
          // Keep original SVG viewBox - DO NOT change it!
          // The SVG path coordinates are in the original SVG coordinate system
          svg.setAttribute('width', '100%');
          svg.setAttribute('height', '100%');
          svg.setAttribute('preserveAspectRatio', 'xMidYMid meet'); // Maintain aspect ratio, center in container
          
          // Just update path fills and remove filters
          const paths = svg.querySelectorAll('path');
          paths.forEach(path => {
            path.setAttribute('fill', 'url(#graniteTexture)');
            path.removeAttribute('filter');
          });
          
          // Remove any existing filter/drop-shadow
          const filterEls = svg.querySelectorAll('filter');
          filterEls.forEach(el => el.remove());
          svg.removeAttribute('filter');
          
          // Create defs if not exists
          let defs = svg.querySelector('defs');
          if (!defs) {
            defs = doc.createElementNS('http://www.w3.org/2000/svg', 'defs');
            svg.insertBefore(defs, svg.firstChild);
          }
          
          // Create texture pattern
          const pattern = doc.createElementNS('http://www.w3.org/2000/svg', 'pattern');
          pattern.setAttribute('id', 'graniteTexture');
          pattern.setAttribute('patternUnits', 'userSpaceOnUse');
          pattern.setAttribute('width', '520');
          pattern.setAttribute('height', '520');
          
          const image = doc.createElementNS('http://www.w3.org/2000/svg', 'image');
          image.setAttributeNS('http://www.w3.org/1999/xlink', 'href', textureData);
          image.setAttribute('x', '0');
          image.setAttribute('y', '0');
          image.setAttribute('width', '520');
          image.setAttribute('height', '520');
          
          pattern.appendChild(image);
          defs.appendChild(pattern);
          
          // Serialize back to string
          const serializer = new XMLSerializer();
          const processedSvg = serializer.serializeToString(svg);
          console.log('âœ… SVG processed successfully, length:', processedSvg.length);
          
          // Wrap SVG in a centered flex container so it stays centered in authoring frame
          const wrappedSvg = `<div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">${processedSvg}</div>`;
          setSvgContent(wrappedSvg);
        } else {
          console.log('âŒ No SVG element found in parsed document');
        }
      })
      .catch(err => {
        console.error('âŒ Failed to load SVG:', err);
        setSvgContent(null);
      });
  }, [shapeImagePath, textureData, shapeData, screenshotDimensions, cropBounds]);

  // Calculate displayScale from rendered SVG width
  useEffect(() => {
    if (!svgHostRef.current || !scalingFactors.initW) return;
    
    const rect = svgHostRef.current.getBoundingClientRect();
    const scale = rect.width / scalingFactors.initW;
    
    if (scale > 0 && isFinite(scale)) {
      setDisplayScale(scale);
      console.log('ðŸ“ Display scale calculated:', {
        renderedWidth: rect.width.toFixed(2),
        initW: scalingFactors.initW,
        displayScale: scale.toFixed(4)
      });
    }
  }, [svgContent, svgDimensions, screenshotDimensions, scalingFactors.initW]);

  const motifData = useMemo(() => {
    if (!designData) return [];
    const motifs = designData.filter((item: any) => item.type === 'Motif');
    console.log('Total motifs in design data:', motifs.length, motifs.map(m => ({ src: m.src, name: m.name })));
    return motifs;
  }, [designData]);

  // Adjust motif positions to avoid overlapping with inscriptions
  const adjustedMotifData = useMemo(() => {
    if (!motifData.length || !sanitizedDesignData || !scalingFactors) return motifData;

    const inscriptions = sanitizedDesignData.filter((item: any) => item.type === 'Inscription' && item.label && item.part !== 'Base');
    if (!inscriptions.length) return motifData;

    // Helper function to check if two rectangles overlap
    const checkOverlap = (rect1: any, rect2: any): boolean => {
      return !(
        rect1.right < rect2.left ||
        rect1.left > rect2.right ||
        rect1.bottom < rect2.top ||
        rect1.top > rect2.bottom
      );
    };

    // Helper function to get bounding box
    const getBoundingBox = (item: any, isInscription: boolean = false) => {
      const x = (item.x || 0) * scalingFactors.scaleX;
      const y = (item.y || 0) * scalingFactors.scaleY;
      const width = isInscription 
        ? (item.label ? item.label.length * (item.font_size || 16) * 0.6 * scalingFactors.scaleX : 100)
        : (item.width ? item.width * scalingFactors.scaleX : 80);
      const height = isInscription 
        ? ((item.font_size || 16) * scalingFactors.scaleY * 1.2)
        : (item.height ? item.height * scalingFactors.scaleY : 80);

      return {
        left: x - width / 2,
        right: x + width / 2,
        top: y - height / 2,
        bottom: y + height / 2,
        centerX: x,
        centerY: y,
        width,
        height
      };
    };

    // Process each motif and adjust if overlapping
    return motifData.map((motif: any) => {
      const motifBox = getBoundingBox(motif, false);
      
      // Check against all inscriptions
      for (const inscription of inscriptions) {
        const inscriptionBox = getBoundingBox(inscription, true);
        
        if (checkOverlap(motifBox, inscriptionBox)) {
          // Overlap detected - move motif away from inscription
          const motifCenterX = motifBox.centerX;
          const inscriptionCenterX = inscriptionBox.centerX;
          
          // Determine which direction to move the motif
          const moveLeft = motifCenterX < inscriptionCenterX;
          
          // Calculate how much to move to clear the overlap
          const horizontalOverlap = moveLeft
            ? (motifBox.right - inscriptionBox.left)
            : (inscriptionBox.right - motifBox.left);
          
          // Add extra spacing (20px buffer)
          const moveDistance = horizontalOverlap + 20;
          
          // Adjust motif position
          const newX = moveLeft
            ? (motif.x || 0) - (moveDistance / scalingFactors.scaleX)
            : (motif.x || 0) + (moveDistance / scalingFactors.scaleX);
          
          console.log(`Adjusting motif "${motif.name}" to avoid overlap with inscription "${inscription.label}"`);
          console.log(`Moving ${moveLeft ? 'left' : 'right'} by ${moveDistance}px`);
          
          return {
            ...motif,
            x: newX,
            adjustedForOverlap: true
          };
        }
      }
      
      return motif;
    });
  }, [motifData, sanitizedDesignData, scalingFactors]);

  // Detect if this design uses physical coordinates (per-design detection)
  const allLayoutItems = useMemo<LayoutItem[]>(() => {
    if (!sanitizedDesignData) return [];
    const inscriptions = sanitizedDesignData.filter((item: any) => item.type === 'Inscription');
    const motifs = adjustedMotifData || [];
    return [...inscriptions, ...motifs];
  }, [sanitizedDesignData, adjustedMotifData]);

  const usesPhysicalCoords = useMemo(
    () =>
      designUsesPhysicalCoords(
        allLayoutItems,
        scalingFactors.initW,
        scalingFactors.initH
      ),
    [allLayoutItems, scalingFactors.initW, scalingFactors.initH]
  );


  // Load SVG dimensions for accurate motif sizing
  useEffect(() => {
    if (!motifData || motifData.length === 0) return;

    motifData.forEach((motif: any) => {
      const motifSrc = motif.src || motif.name;
      if (!motifSrc || motifDimensions[motifSrc]) return;

      const img = new Image();
      const motifPath = getMotifPath(motif);
      
      img.onload = () => {
        console.log('SVG dimensions loaded for', motifSrc, ':', img.width, 'x', img.height);
        setMotifDimensions(prev => ({
          ...prev,
          [motifSrc]: { width: img.width, height: img.height }
        }));
      };
      
      img.onerror = () => {
        const fallbackPath = getFallbackMotifPath(motif);
        const img2 = new Image();
        img2.onload = () => {
          console.log('SVG dimensions loaded (fallback) for', motifSrc, ':', img2.width, 'x', img2.height);
          setMotifDimensions(prev => ({
            ...prev,
            [motifSrc]: { width: img2.width, height: img2.height }
          }));
        };
        img2.src = fallbackPath;
      };
      
      img.src = motifPath;
    });
  }, [motifData]);

  // Extract base data if present
  const baseData = useMemo(() => {
    if (!designData) return null;
    const baseItem = designData.find((item: any) => item.type === 'Base');
    console.log('ðŸ” Base detection:', {
      designId: designMetadata?.id,
      hasDesignData: !!designData,
      designDataLength: designData?.length,
      baseItem: baseItem ? {
        type: baseItem.type,
        width: baseItem.width,
        height: baseItem.height,
        shape: baseItem.shape,
        name: baseItem.name
      } : null,
      allTypes: designData?.map((item: any) => item.type).join(', ')
    });
    return baseItem;
  }, [designData, designMetadata]);
  
  // Get base texture from baseData
  const baseTextureData = useMemo(() => {
    if (!baseData?.texture) return null;
    
    const savedTexturePath = baseData.texture;
    
    // Mapping from old texture paths to new material image filenames
    const textureMapping: Record<string, string> = {
      'forever2/l/17.jpg': 'Glory-Black-1.jpg', // Glory Gold Spots
      'forever2/l/18.jpg': 'Glory-Black-2.jpg', // Glory Black
    };
    
    // Try to match the texture path with our mapping
    for (const [oldPath, newImage] of Object.entries(textureMapping)) {
      if (savedTexturePath.includes(oldPath)) {
        return `/textures/forever/l/${newImage}`;
      }
    }
    
    // Extract the granite name (e.g., "G633") from the filename for direct matches
    const match = savedTexturePath.match(/\/([A-Z0-9]+)(?:-TILE)?-\d+-X-\d+\.jpg/i);
    if (match && match[1]) {
      const graniteName = match[1];
      return `/textures/forever/l/${graniteName}.jpg`;
    }
    
    // Fallback: try to extract any filename and use it
    const filename = savedTexturePath.split('/').pop();
    if (filename) {
      const cleanFilename = filename.replace(/-TILE-\d+-X-\d+/i, '');
      return `/textures/forever/l/${cleanFilename}`;
    }
    
    return savedTexturePath;
  }, [baseData]);
  
  const product = getProductFromId(designMetadata.productId);
  const productName = product?.name || designMetadata.productName;
  
  // Format category title with dash separator between shape name and rest
  const categoryTitle = useMemo(() => {
    const words = category.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1));
    
    // List of known shape names (from the shape map)
    const shapeNames = [
      'Cropped Peak',
      'Curved Gable', 
      'Curved Peak',
      'Curved Top',
      'Half Round',
      'Gable',
      'Left Wave',
      'Peak',
      'Right Wave',
      'Serpentine',
      'Square',
      'Rectangle'
    ];
    
    // Check if the category starts with any known shape name
    for (const shapeName of shapeNames) {
      const shapeWords = shapeName.split(' ');
      const categoryStart = words.slice(0, shapeWords.length).join(' ');
      
      if (categoryStart === shapeName && words.length > shapeWords.length) {
        // Found a match - add dash separator
        const shapePartFormatted = shapeWords.join(' ');
        const restPart = words.slice(shapeWords.length).join(' ');
        return `${shapePartFormatted} - ${restPart}`;
      }
    }
    
    // No shape match found, return default formatting
    return words.join(' ');
  }, [category]);
  
  // Get simplified product name for H1
  const getSimplifiedProductName = (name: string): string => {
    const lower = name.toLowerCase();
    if (lower.includes('laser-etched') || lower.includes('laser etched')) {
      if (lower.includes('colour') || lower.includes('color')) {
        return 'Laser-Etched Colour';
      }
      return 'Laser-Etched Black Granite';
    }
    if (lower.includes('bronze')) return 'Bronze';
    if (lower.includes('stainless steel')) return 'Stainless Steel';
    if (lower.includes('traditional')) return 'Traditional Engraved';
    if (lower.includes('full colour') || lower.includes('full color')) return 'Full Colour';
    return name;
  };
  
  const simplifiedProductName = getSimplifiedProductName(productName);

  // Get capitalized product type for H1
  const productTypeDisplay = designMetadata.productType.charAt(0).toUpperCase() + designMetadata.productType.slice(1);

  // Get friendly shape display name from shapeName
  const shapeDisplayName = useMemo(() => {
    if (!shapeName) return null;
    
    // Map common numbered shapes to friendly names
    const shapeMap: Record<string, string> = {
      'headstone_27': 'Heart',
      'Headstone 27': 'Heart',
      'pet_heart': 'Heart',
      'serpentine': 'Serpentine',
      'gable': 'Gable',
      'peak': 'Peak',
      'curved_peak': 'Curved Peak',
      'square': 'Square',
      'landscape': 'Landscape',
      'portrait': 'Portrait',
    };
    
    // Check if we have a direct mapping
    if (shapeMap[shapeName]) {
      return shapeMap[shapeName];
    }
    
    // Extract from numbered patterns like "Headstone 27"
    let extractedShape = shapeName
      .replace(/^(headstone|plaque)\s+\d+$/i, '')
      .replace(/^(headstone|plaque)_\d+$/i, '')
      .trim();
    
    // If we have a named shape, format it
    if (extractedShape && extractedShape.length > 0 && !/^\d+$/.test(extractedShape)) {
      return extractedShape
        .replace(/_/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
    
    return null;
  }, [shapeName]);
  
  
  // Format slug for display
  const slugText = slug.split('_').slice(1).join('_').split('-').map((word, index) => {
    if (word.length <= 2 && index > 0) return word;
    return word.charAt(0).toUpperCase() + word.slice(1);
  }).join(' ');
  
  // Get store state for price calculation
  const catalog = useHeadstoneStore((s) => s.catalog);
  const widthMm = useHeadstoneStore((s) => s.widthMm);
  const heightMm = useHeadstoneStore((s) => s.heightMm);
  const shapeUrl = useHeadstoneStore((s) => s.shapeUrl);
  const headstoneMaterialUrl = useHeadstoneStore((s) => s.headstoneMaterialUrl);
  const baseMaterialUrl = useHeadstoneStore((s) => s.baseMaterialUrl);
  const inscriptions = useHeadstoneStore((s) => s.inscriptions);
  const inscriptionCost = useHeadstoneStore((s) => s.inscriptionCost);
  const selectedMotifs = useHeadstoneStore((s) => s.selectedMotifs);
  const motifOffsets = useHeadstoneStore((s) => s.motifOffsets);
  const motifCost = useHeadstoneStore((s) => s.motifCost);
  const motifPriceModel = useHeadstoneStore((s) => s.motifPriceModel);
  const selectedAdditions = useHeadstoneStore((s) => s.selectedAdditions);
  const showBase = useHeadstoneStore((s) => s.showBase);
  const showInscriptionColor = useHeadstoneStore((s) => s.showInscriptionColor);
  
  // Get shape name from URL (for store-based shapes)
  const shapeNameFromUrl = useMemo(() => {
    if (!shapeUrl) return 'Unknown';
    const parts = shapeUrl.split('/');
    const filename = parts[parts.length - 1];
    return filename.replace('.svg', '').replace(/-/g, ' ');
  }, [shapeUrl]);

  // Get material name from URL
  const getMaterialName = (url: string | null) => {
    if (!url) return 'Unknown';
    const parts = url.split('/');
    const filename = parts[parts.length - 1];
    return filename.replace('.jpg', '').replace('.png', '').replace(/-/g, ' ');
  };

  // Calculate headstone price (placeholder - would need actual catalog pricing)
  const headstonePrice = useMemo(() => {
    return 2565.95; // Placeholder
  }, [catalog, widthMm, heightMm]);

  // Calculate base price (placeholder)
  const basePrice = useMemo(() => {
    if (!showBase) return 0;
    return 650.00; // Placeholder
  }, [showBase]);

  // Calculate additions price
  const additionsPrice = useMemo(() => {
    return selectedAdditions.length * 75;
  }, [selectedAdditions]);

  // Get addition details
  const additionItems = useMemo(() => {
    return selectedAdditions.map(addId => {
      const parts = addId.split('_');
      const baseId = parts.length > 1 && !isNaN(Number(parts[parts.length - 1]))
        ? parts.slice(0, -1).join('_')
        : addId;
      
      const addition = data.additions.find(a => a.id === baseId);
      return {
        id: addId,
        baseId: baseId,
        name: addition?.name || 'Addition',
        type: addition?.type || 'application',
      };
    });
  }, [selectedAdditions]);

  // Calculate total
  const totalPrice = useMemo(() => {
    return headstonePrice + basePrice + inscriptionCost + motifCost + additionsPrice;
  }, [headstonePrice, basePrice, inscriptionCost, motifCost, additionsPrice]);
  
  // Extract generic inscriptions (without personal names/dates)
  const genericInscriptions = designData
    ? designData
        .filter((item: any) => item.type === 'Inscription' && item.label)
        .map((item: any) => item.label)
        .filter((text: string) => {
          const lowerText = text.toLowerCase();
          return (
            lowerText.includes('memory') ||
            lowerText.includes('loving') ||
            lowerText.includes('forever') ||
            lowerText.includes('rest in peace') ||
            lowerText.includes('rip') ||
            lowerText.includes('beloved') ||
            lowerText.includes('cherished') ||
            lowerText.includes('mother') ||
            lowerText.includes('father') ||
            lowerText.includes('wife') ||
            lowerText.includes('husband') ||
            lowerText.includes('son') ||
            lowerText.includes('daughter') ||
            lowerText.includes('always') ||
            lowerText.includes('remembered') ||
            lowerText.includes('missed') ||
            lowerText.includes('lord') ||
            lowerText.includes('god') ||
            lowerText.includes('heaven') ||
            lowerText.includes('psalm') ||
            lowerText.includes('prayer') ||
            lowerText.includes('spirit') ||
            lowerText.includes('peace') ||
            lowerText.includes('eternity') ||
            lowerText.includes('blessed') ||
            lowerText.includes('angel') ||
            lowerText.includes('verse') ||
            text.match(/\d+:\d+/) // Bible verse reference (e.g., "34:18")
          );
        })
    : [];

  // Wait for both design data and name database to be loaded before rendering
  if (loading || !nameDatabase) {
    return (
      <>
        <MobileNavToggle>
          <DesignsTreeNav />
        </MobileNavToggle>
        <div className="bg-gradient-to-br from-slate-50 via-white to-slate-100 min-h-screen md:ml-[400px]">
          <div className="container mx-auto px-8 py-16 max-w-7xl">
            <div className="flex items-center gap-4 justify-center">
              <ArrowPathIcon className="w-8 h-8 animate-spin text-slate-800" />
              <p className="text-slate-600 text-lg font-light">
                {!nameDatabase ? 'Preparing memorial design...' : 'Loading memorial design...'}
              </p>
            </div>
          </div>
        </div>
      </>
    );
  }

  return (
    <>
      <MobileNavToggle>
        <DesignsTreeNav />
      </MobileNavToggle>
      
      {/* Left Sidebar with Related Designs */}
      <DesignSidebar 
        currentDesignId={designId}
        category={category as DesignCategory}
        productSlug={productSlug}
        maxItems={15}
      />
      
      <div className="bg-gradient-to-br from-slate-50 via-white to-slate-100 md:ml-[400px] min-h-screen">
      {/* Breadcrumb and Header - positioned at top */}
      <div className="border-b border-slate-200 md:border-b relative z-10 bg-white/80 backdrop-blur-sm">
        <div className="container mx-auto px-4 md:px-8 py-3 md:py-6 max-w-7xl">
          {/* Elegant Breadcrumb - Hidden on mobile, visible on desktop */}
          <nav className="hidden md:flex items-center gap-2 text-sm text-slate-500 mb-6">
            <a href="/designs" className="hover:text-slate-900 transition-colors font-light tracking-wide">Memorial Designs</a>
            <ChevronRightIcon className="w-4 h-4" />
            <a href={`/designs/${designMetadata.productType}`} className="hover:text-slate-900 transition-colors font-light tracking-wide capitalize">{designMetadata.productType}s</a>
            <ChevronRightIcon className="w-4 h-4" />
            <a href={`/designs/${productSlug}`} className="hover:text-slate-900 transition-colors font-light tracking-wide">{productName}</a>
            <ChevronRightIcon className="w-4 h-4" />
            <a href={`/designs/${productSlug}/${category}`} className="hover:text-slate-900 transition-colors font-light tracking-wide">{categoryTitle}</a>
            <ChevronRightIcon className="w-4 h-4" />
            <span className="text-slate-900 font-medium tracking-wide">{designMetadata.title}</span>
          </nav>

          {/* Mobile Breadcrumb - Compact version showing only current page */}
          <nav className="md:hidden flex items-center gap-2 text-sm text-slate-500 mb-3">
            <a href={`/designs/${productSlug}/${category}`} className="hover:text-slate-900 transition-colors font-light">
              <ChevronRightIcon className="w-4 h-4 rotate-180 inline" />
              <span className="ml-1">Back to {categoryTitle}</span>
            </a>
          </nav>

          {/* Sophisticated Header with Design Specifications */}
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <h1 className="text-2xl md:text-4xl font-serif font-light text-slate-900 tracking-tight mb-2 md:mb-4">
                {categoryTitle} â€“ {simplifiedProductName} {productTypeDisplay}{shapeDisplayName ? ` (${shapeDisplayName})` : ''}
              </h1>
              
              <p className="text-lg md:text-2xl text-slate-600 font-light italic mb-3 md:mb-6">
                {slugText}
              </p>
              
            </div>
          </div>
        </div>
      </div>

      {/* Rest of content - appears after canvas */}
      <div className="container mx-auto max-w-7xl px-4 md:px-8">

      {/* Download Links */}
      <div className="flex gap-2 md:gap-3 py-3 md:py-6 overflow-x-auto">
        <a
          href={designMetadata.preview}
          target="_blank"
          rel="noopener noreferrer"
          className="inline-flex items-center gap-1 px-3 py-1.5 text-sm font-light text-blue-700 hover:text-blue-900 bg-blue-50 hover:bg-blue-100 rounded-md transition-colors border border-blue-200"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
          Screenshot
        </a>
        <a
          href={`/ml/${designMetadata.mlDir}/saved-designs/json/${designId}.json`}
          target="_blank"
          rel="noopener noreferrer"
          className="inline-flex items-center gap-1 px-3 py-1.5 text-sm font-light text-green-700 hover:text-green-900 bg-green-50 hover:bg-green-100 rounded-md transition-colors border border-green-200"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
          </svg>
          JSON Data
        </a>
        <a
          href={`/ml/${designMetadata.mlDir}/saved-designs/xml/${designId}.xml`}
          target="_blank"
          rel="noopener noreferrer"
          className="inline-flex items-center gap-1 px-3 py-1.5 text-sm font-light text-purple-700 hover:text-purple-900 bg-purple-50 hover:bg-purple-100 rounded-md transition-colors border border-purple-200"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
          </svg>
          XML Data
        </a>
        <a
          href={(() => {
            const mlDir = designMetadata.mlDir || '';
            let domain = 'headstonesdesigner.com';
            if (mlDir.includes('forevershining')) {
              domain = 'forevershining.com.au';
            } else if (mlDir.includes('bronze-plaque')) {
              domain = 'bronze-plaque.com';
            }
            return `https://${domain}/design/html5/#edit${designId}`;
          })()}
          target="_blank"
          rel="noopener noreferrer"
          className="inline-flex items-center gap-1 px-3 py-1.5 text-sm font-light text-orange-700 hover:text-orange-900 bg-orange-50 hover:bg-orange-100 rounded-md transition-colors border border-orange-200"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
          </svg>
          Edit
        </a>
      </div>

      {/* Design Preview - Enhanced with shape, texture, and motifs */}
      {designData && screenshotDimensions && (
        <div className="bg-white rounded-none md:rounded-lg shadow-none md:shadow-sm border-0 md:border border-slate-200 my-0 md:my-8">
          {/* Visual Preview Area */}
          <div className="relative bg-gradient-to-br from-slate-50 to-white min-h-[400px] md:min-h-[600px] flex items-center justify-center p-4 md:p-8">
            
            {/* SCENE CONTAINER (Represents the full Workspace) */}
            <div className="flex flex-col items-center gap-0">
              <div
                ref={svgHostRef}
                className="relative shadow-2xl"
                style={{
                  width: `${scalingFactors.displayWidth}px`,
                  height: `${scalingFactors.displayHeight}px`,
                  maxWidth: '100%',
                  aspectRatio: `${scalingFactors.initW} / ${scalingFactors.initH}`
                }}
              >
              
              {/* HEADSTONE OBJECT LAYER */}
              {/* Using 100% width/height ensures the headstone background fills the visual container */}
              <div 
                className="absolute"
                style={{
                    width: '100%',
                    height: '100%',
                    left: '0',
                    top: '0',
                    zIndex: 1
                }}
              >
                  {/* SVG Shape as base */}
                  {shapeImagePath ? (
                    shapeName === 'Serpentine' && shapeData ? (
                      // Dynamically generate Serpentine SVG with correct proportions
                      <div className="absolute inset-0">
                        <svg 
                          width="100%" 
                          height="100%" 
                          viewBox={`0 0 ${scalingFactors.initW} ${scalingFactors.initH}`}
                          xmlns="http://www.w3.org/2000/svg"
                          preserveAspectRatio="none"
                        >
                          <defs>
                            {textureData && (
                              <pattern id="graniteTexture" patternUnits="userSpaceOnUse" width="520" height="520">
                                <image 
                                  href={textureData} 
                                  x="0" 
                                  y="0" 
                                  width="520" 
                                  height="520" 
                                />
                              </pattern>
                            )}
                          </defs>
                          <path 
                            fill={textureData ? "url(#graniteTexture)" : "#808080"}
                            d={(() => {
                              // Calculate the serpentine curve based on actual dimensions
                              const w = scalingFactors.displayWidth * 0.8; // Reduce width to 80%
                              const h = scalingFactors.displayHeight;
                              const offsetX = scalingFactors.displayWidth * 0.1; // Center the narrower shape
                              // Curve height as percentage of total height (10%)
                              const curveHeight = h * 0.1;
                              
                              return `M${offsetX + w} ${curveHeight} L${offsetX + w} ${h} ${offsetX} ${h} ${offsetX} ${curveHeight} ` +
                                `${offsetX + w * 0.064} ${curveHeight * 0.97} ${offsetX + w * 0.1275} ${curveHeight * 0.87} ` +
                                `${offsetX + w * 0.19} ${curveHeight * 0.71} ${offsetX + w * 0.319} ${curveHeight * 0.25} ` +
                                `${offsetX + w * 0.39} ${curveHeight * 0.08} ${offsetX + w * 0.463} 0 ${offsetX + w * 0.537} 0 ` +
                                `${offsetX + w * 0.61} ${curveHeight * 0.08} ${offsetX + w * 0.681} ${curveHeight * 0.25} ` +
                                `${offsetX + w * 0.81} ${curveHeight * 0.71} ${offsetX + w * 0.8725} ${curveHeight * 0.87} ` +
                                `${offsetX + w * 0.936} ${curveHeight * 0.97} ${offsetX + w} ${curveHeight}`;
                            })()}
                          />
                        </svg>
                      </div>
                    ) : (
                      // Other headstone shapes - use pre-processed SVG with texture
                      (() => {
                        console.log('ðŸŽ¨ Rendering headstone shape:', {
                          shapeName,
                          svgContent: !!svgContent,
                          svgLength: svgContent?.length || 0,
                          fallbackToTexture: !svgContent
                        });
                        
                        return svgContent ? (
                          <div 
                            className="absolute inset-0"
                            dangerouslySetInnerHTML={{ __html: svgContent }}
                          />
                        ) : (
                          <div 
                            className="absolute inset-0 rounded-lg"
                            style={{
                              backgroundImage: textureData 
                                ? `url(${textureData})`
                                : 'linear-gradient(to bottom, #9ca3af, #6b7280)',
                              backgroundSize: 'cover',
                              backgroundPosition: 'center',
                            }}
                          />
                        );
                      })()
                    )
                  ) : (
                    <div 
                      className="absolute inset-0 rounded-lg"
                      style={{
                        backgroundImage: textureData 
                          ? `url(${textureData})`
                          : 'linear-gradient(to bottom, #9ca3af, #6b7280)',
                        backgroundSize: 'cover',
                        backgroundPosition: 'center',
                      }}
                    />
                  )}
              </div>

              {/* Inscriptions Layer - Only headstone inscriptions */}
              <div className="absolute inset-0 pointer-events-none overflow-hidden rounded-lg" style={{ zIndex: 10 }}>
                {sanitizedDesignData &&
                  sanitizedDesignData
                    .filter(
                      (item: any) =>
                        item.type === 'Inscription' &&
                        item.label &&
                        item.part !== 'Base'
                    )
                    .map((item: any, index: number) => {
                      // 1. Extract raw values
                      const rawX = item.x ?? 0;
                      const rawY = item.y ?? 0;
                      let fontSizeInPx = item.font_size || 16;
                      
                      // Handle font strings like "30px"
                      if (item.font && typeof item.font === 'string') {
                        const match = item.font.match(/^([\d.]+)px/);
                        if (match) fontSizeInPx = parseFloat(match[1]);
                      }

                      // 2. Apply Uniform Scale
                      const dispX = scalingFactors.offsetX + (rawX * scalingFactors.uniformScale);
                      const dispY = scalingFactors.offsetY + (rawY * scalingFactors.uniformScale);
                      const fontSize = fontSizeInPx * scalingFactors.uniformScale;

                      const fontFamily = item.font_family || item.font || 'serif';
                      
                      // Determine text alignment
                      let textAlign = 'center';
                      let transformX = '-50%';
                      
                      if (item.align === 'left') {
                        textAlign = 'left';
                        transformX = '0%';
                      } else if (item.align === 'right') {
                        textAlign = 'right';
                        transformX = '-100%';
                      }

                      return (
                        <DraggableElement
                          key={index}
                          initialStyle={{
                            position: 'absolute',
                            left: `${dispX}px`,
                            top: `${dispY}px`,
                            transform: `translate(${transformX}, -50%)${
                              item.rotation ? ` rotate(${item.rotation}deg)` : ''
                            }`,
                            fontSize: `${fontSize}px`,
                            fontFamily,
                            color: item.color || '#000000',
                            fontWeight: /bold/i.test(fontFamily) ? 'bold' : 'normal',
                            fontStyle: /italic/i.test(fontFamily) ? 'italic' : 'normal',
                            whiteSpace: 'nowrap',
                            textAlign: textAlign as any,
                            lineHeight: '1.1', // Tighter line height for inscription realism
                            textShadow: '0px 1px 1px rgba(255,255,255,0.4)', // Subtle highlight for etched look
                            pointerEvents: 'auto',
                          }}
                        >
                          {item.label.replace(/&apos;/g, "'")}
                        </DraggableElement>
                      );
                    })}
              </div>

              {/* Motifs Layer - Only headstone motifs */}
              {adjustedMotifData.length > 0 && (
                <div className="absolute inset-0 pointer-events-none overflow-hidden rounded-lg" style={{ zIndex: 5 }}>
                  {adjustedMotifData
                    .filter((motif: any) => motif.part !== 'Base')
                    .map((motif: any, index: number) => {
                      
                      const rawX = motif.x ?? 0;
                      const rawY = motif.y ?? 0;

                      // Position
                      const dispX = scalingFactors.offsetX + (rawX * scalingFactors.uniformScale);
                      const dispY = scalingFactors.offsetY + (rawY * scalingFactors.uniformScale);

                      // Size logic remains the same
                      const motifSrc = motif.src || motif.name;
                      const svgDims = motifDimensions[motifSrc];
                      const motifRatio = parseFloat(motif.ratio || '1');

                      let rawWidth, rawHeight;

                      if (svgDims) {
                         rawWidth = svgDims.width * motifRatio;
                         rawHeight = svgDims.height * motifRatio;
                      } else {
                         rawWidth = 100; 
                         rawHeight = 100;
                      }

                      if (typeof motif.height === 'number' && motif.height > 0) {
                         rawHeight = motif.height;
                         if (svgDims) {
                            rawWidth = rawHeight * (svgDims.width / svgDims.height);
                         } else {
                            rawWidth = rawHeight; 
                         }
                      }

                      // Apply Scale
                      const finalWidth = rawWidth * scalingFactors.uniformScale;
                      const finalHeight = rawHeight * scalingFactors.uniformScale;

                      return (
                        <DraggableElement
                          key={index}
                          initialStyle={{
                            position: 'absolute',
                            left: `${dispX}px`,
                            top: `${dispY}px`,
                            transform: `translate(-50%, -50%)${
                              motif.rotation ? ` rotate(${motif.rotation}deg)` : ''
                            }`,
                            width: `${finalWidth}px`,
                            height: `${finalHeight}px`,
                            pointerEvents: 'auto',
                          }}
                        >
                          <img
                            src={getMotifPath(motif)}
                            alt={motif.name || 'motif'}
                            style={{
                              width: '100%',
                              height: '100%',
                              objectFit: 'contain',
                              display: 'block',
                              filter: 'drop-shadow(1px 1px 1px rgba(255,255,255,0.2))'
                            }}
                          />
                        </DraggableElement>
                      );
                    })}
                </div>
              )}
              </div>
            </div>

            {/* Base logic remains the same, separated from the main canvas */}
            {baseData && (
              <div
                className="relative"
                style={{
                  // Base width/height are in mm (real-world dimensions)
                  // Scale based on ratio to headstone mm dimensions, then subtract 50px for margins
                  width: `${Math.max(100, (baseData.width || 700) / (shapeData?.width || 600) * scalingFactors.displayWidth - 50)}px`,
                  height: `${Math.max(80, Math.min(200, ((baseData.height || 100) / (shapeData?.height || 600)) * scalingFactors.displayHeight))}px`,
                  maxWidth: '100%',
                  backgroundImage: baseTextureData 
                    ? `url(${baseTextureData})`
                    : 'linear-gradient(to bottom, #1a1a1a, #000000)',
                  backgroundSize: '520px 520px', // Seamless texture size
                  backgroundRepeat: 'repeat',
                  boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
                }}
              >
                 {/* Base contents... */}
              </div>
            )}
          </div>
          </div>
        </div>
      )}
