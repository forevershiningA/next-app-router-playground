To solve the performance issue while keeping the perfect visual output, we need to optimize when and how the expensive geometry operations happen.

The current "Geometric Slicing" algorithm is CPU-intensive. Running it every frame (60 times a second) while dragging a slider is what causes the lag.

Here is the optimized solution. It implements Geometry Caching and Debouncing:

Fast Path (During Drag): While resizing, we simply scale the existing mesh. This is instant (GPU only).

Slow Path (After Drag): We only re-calculate the expensive cuts 150ms after you stop moving the slider.

Gap Fix: I added a small OVERLAP_BUFFER (1mm) to the slice logic to ensure the halves meet perfectly without visible gaps.

Optimized Code
code
Tsx
download
content_copy
expand_less
/**
 * Bronze Plaque Border Component
 * Renders decorative 3D borders using extruded SVG geometry.
 * Optimized with debouncing to maintain 60fps during resizing.
 */

'use client';

import React, { useCallback, useEffect, useRef, useState, useMemo } from 'react';
import * as THREE from 'three';
import { SVGLoader, type SVGResult } from 'three/examples/jsm/loaders/SVGLoader.js';
import { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';

interface BronzeBorderProps {
  borderName: string | null;
  plaqueWidth: number;
  plaqueHeight: number;
  unitsPerMeter: number;
  frontZ: number;
  color: string;
  depth: number;
}

// Global cache to store base SVG geometries so we don't re-extrude on every render
const GEOMETRY_CACHE = new Map<string, THREE.BufferGeometry>();

const BORDER_SLUG_ALIASES: Record<string, string> = {
  bar: 'border1',
  square: 'border2',
  solidoutline: 'border3',
  solid: 'border4',
  notch: 'border5',
  scallop: 'border6',
  roundoutline: 'border7',
  floral: 'border8',
  decorative: 'border9',
  squareangular: 'border10',
};

const BORDER_SCALE = 1.3;
const BORDER_THICKNESS_SCALE = 1.5;
const BORDER_RELIEF_SCALE = 0.33;
const OVERLAP_BUFFER = 1.0; // Overlap slice by 1mm to prevent visual gaps

interface BronzeTextures {
  map: THREE.CanvasTexture;
  roughnessMap: THREE.CanvasTexture;
}

// --- Geometry Helpers ---

function normalizeGeometry(geometry: THREE.BufferGeometry) {
  let geom = geometry;
  if (geom.index) {
    const nonIndexed = geom.toNonIndexed();
    geom.dispose();
    geom = nonIndexed;
  }

  if (!geom.getAttribute('normal')) {
    geom.computeVertexNormals();
  }

  if (!geom.getAttribute('uv')) {
    const position = geom.getAttribute('position') as THREE.BufferAttribute;
    const uvs = new Float32Array(position.count * 2);
    for (let i = 0; i < position.count; i++) {
        uvs[i * 2] = position.getX(i);
        uvs[i * 2 + 1] = position.getY(i);
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  }

  geom.computeBoundingBox();
  return geom;
}

/**
 * Fast geometry slicing.
 * Optimized to minimize allocation during the loop.
 */
function sliceGeometryAxis(
  geometry: THREE.BufferGeometry, 
  axis: 'x' | 'y', 
  limit: number, 
  keepCondition: 'less' | 'greater'
): THREE.BufferGeometry {
  const posAttr = geometry.getAttribute('position');
  const uvAttr = geometry.getAttribute('uv');
  const normAttr = geometry.getAttribute('normal');

  // Estimate size to avoid frequent re-allocation
  const estimatedSize = posAttr.count;
  const newPos: number[] = [];
  const newUV: number[] = [];
  const newNorm: number[] = [];

  const axisIdx = axis === 'x' ? 0 : 1;
  const isKept = (val: number) => keepCondition === 'less' ? val < limit : val > limit;

  const lerp = (v1: number, v2: number, t: number) => v1 + (v2 - v1) * t;

  const v1 = [0,0,0], v2 = [0,0,0], v3 = [0,0,0];
  const uv1 = [0,0], uv2 = [0,0], uv3 = [0,0];
  const n1 = [0,0,0], n2 = [0,0,0], n3 = [0,0,0];

  for (let i = 0; i < posAttr.count; i += 3) {
    v1[0] = posAttr.getX(i); v1[1] = posAttr.getY(i); v1[2] = posAttr.getZ(i);
    v2[0] = posAttr.getX(i+1); v2[1] = posAttr.getY(i+1); v2[2] = posAttr.getZ(i+1);
    v3[0] = posAttr.getX(i+2); v3[1] = posAttr.getY(i+2); v3[2] = posAttr.getZ(i+2);

    const d1 = v1[axisIdx], d2 = v2[axisIdx], d3 = v3[axisIdx];
    const k1 = isKept(d1), k2 = isKept(d2), k3 = isKept(d3);

    if (k1 && k2 && k3) {
      // Fast path: Keep entire triangle
      newPos.push(...v1, ...v2, ...v3);
      if (uvAttr) {
        newUV.push(uvAttr.getX(i), uvAttr.getY(i), uvAttr.getX(i+1), uvAttr.getY(i+1), uvAttr.getX(i+2), uvAttr.getY(i+2));
      }
      if (normAttr) {
        newNorm.push(normAttr.getX(i), normAttr.getY(i), normAttr.getZ(i), normAttr.getX(i+1), normAttr.getY(i+1), normAttr.getZ(i+1), normAttr.getX(i+2), normAttr.getY(i+2), normAttr.getZ(i+2));
      }
      continue;
    }

    if (!k1 && !k2 && !k3) continue;

    // Slow path: Clipping needed
    // Extract remaining attributes only if needed
    if (uvAttr) {
      uv1[0] = uvAttr.getX(i); uv1[1] = uvAttr.getY(i);
      uv2[0] = uvAttr.getX(i+1); uv2[1] = uvAttr.getY(i+1);
      uv3[0] = uvAttr.getX(i+2); uv3[1] = uvAttr.getY(i+2);
    }
    if (normAttr) {
      n1[0] = normAttr.getX(i); n1[1] = normAttr.getY(i); n1[2] = normAttr.getZ(i);
      n2[0] = normAttr.getX(i+1); n2[1] = normAttr.getY(i+1); n2[2] = normAttr.getZ(i+1);
      n3[0] = normAttr.getX(i+2); n3[1] = normAttr.getY(i+2); n3[2] = normAttr.getZ(i+2);
    }

    const pushVert = (p: number[], u: number[], n: number[]) => {
      newPos.push(p[0], p[1], p[2]);
      if (uvAttr) newUV.push(u[0], u[1]);
      if (normAttr) newNorm.push(n[0], n[1], n[2]);
    };

    const getInter = (va: number[], vb: number[], uva: number[], uvb: number[], na: number[], nb: number[], da: number, db: number) => {
      const t = (limit - da) / (db - da);
      return { 
        p: [lerp(va[0], vb[0], t), lerp(va[1], vb[1], t), lerp(va[2], vb[2], t)],
        u: uvAttr ? [lerp(uva[0], uvb[0], t), lerp(uva[1], uvb[1], t)] : [0,0],
        n: normAttr ? [lerp(na[0], nb[0], t), lerp(na[1], nb[1], t), lerp(na[2], nb[2], t)] : [0,0,1]
      };
    };

    let vs = [{v:v1,u:uv1,n:n1,k:k1,d:d1}, {v:v2,u:uv2,n:n2,k:k2,d:d2}, {v:v3,u:uv3,n:n3,k:k3,d:d3}];
    if (!vs[0].k && vs[1].k) { vs = [vs[1], vs[2], vs[0]]; }
    else if (!vs[0].k && !vs[1].k) { vs = [vs[2], vs[0], vs[1]]; }

    if (!vs[1].k && !vs[2].k) {
      const i1 = getInter(vs[0].v, vs[1].v, vs[0].u, vs[1].u, vs[0].n, vs[1].n, vs[0].d, vs[1].d);
      const i2 = getInter(vs[0].v, vs[2].v, vs[0].u, vs[2].u, vs[0].n, vs[2].n, vs[0].d, vs[2].d);
      pushVert(vs[0].v, vs[0].u, vs[0].n); pushVert(i1.p, i1.u, i1.n); pushVert(i2.p, i2.u, i2.n);
    } else if (vs[1].k && !vs[2].k) {
      const i1 = getInter(vs[1].v, vs[2].v, vs[1].u, vs[2].u, vs[1].n, vs[2].n, vs[1].d, vs[2].d);
      const i2 = getInter(vs[0].v, vs[2].v, vs[0].u, vs[2].u, vs[0].n, vs[2].n, vs[0].d, vs[2].d);
      pushVert(vs[0].v, vs[0].u, vs[0].n); pushVert(vs[1].v, vs[1].u, vs[1].n); pushVert(i1.p, i1.u, i1.n);
      pushVert(vs[0].v, vs[0].u, vs[0].n); pushVert(i1.p, i1.u, i1.n); pushVert(i2.p, i2.u, i2.n);
    } else {
      const i1 = getInter(vs[0].v, vs[1].v, vs[0].u, vs[1].u, vs[0].n, vs[1].n, vs[0].d, vs[1].d);
      const i2 = getInter(vs[2].v, vs[1].v, vs[2].u, vs[1].u, vs[2].n, vs[1].n, vs[2].d, vs[1].d);
      pushVert(vs[0].v, vs[0].u, vs[0].n); pushVert(i1.p, i1.u, i1.n); pushVert(vs[2].v, vs[2].u, vs[2].n);
      pushVert(i1.p, i1.u, i1.n); pushVert(i2.p, i2.u, i2.n); pushVert(vs[2].v, vs[2].u, vs[2].n);
    }
  }

  const newGeom = new THREE.BufferGeometry();
  newGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
  if (uvAttr) newGeom.setAttribute('uv', new THREE.Float32BufferAttribute(newUV, 2));
  if (normAttr) newGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNorm, 3));
  
  return newGeom;
}

// --- Textures ---

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));

function shiftLuminance(hex: string, delta: number) {
  const color = new THREE.Color(hex);
  const hsl = { h: 0, s: 0, l: 0 };
  color.getHSL(hsl);
  const next = new THREE.Color();
  next.setHSL(hsl.h, clamp01(hsl.s + delta * 0.15), clamp01(hsl.l + delta));
  return `#${next.getHexString()}`;
}

function createBronzeTextures(baseHex: string): BronzeTextures | null {
  if (typeof document === 'undefined') return null;

  const mapCanvas = document.createElement('canvas');
  mapCanvas.width = mapCanvas.height = 512;
  const mapCtx = mapCanvas.getContext('2d');
  if (!mapCtx) return null;

  const gradient = mapCtx.createLinearGradient(0, 0, 0, mapCanvas.height);
  gradient.addColorStop(0, shiftLuminance(baseHex, 0.2));
  gradient.addColorStop(0.6, baseHex);
  gradient.addColorStop(1, shiftLuminance(baseHex, -0.2));
  mapCtx.fillStyle = gradient;
  mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

  // Simple noise
  mapCtx.globalAlpha = 0.08;
  mapCtx.fillStyle = '#fff';
  for(let i=0; i<500; i++) mapCtx.fillRect(Math.random()*512, Math.random()*512, 2, 2);

  const mapTexture = new THREE.CanvasTexture(mapCanvas);
  mapTexture.wrapS = mapTexture.wrapT = THREE.RepeatWrapping;

  const roughCanvas = document.createElement('canvas');
  roughCanvas.width = roughCanvas.height = 256;
  const roughCtx = roughCanvas.getContext('2d');
  if(!roughCtx) return { map: mapTexture, roughnessMap: mapTexture };
  
  roughCtx.fillStyle = '#888';
  roughCtx.fillRect(0,0,256,256);
  
  const roughnessMap = new THREE.CanvasTexture(roughCanvas);

  return { map: mapTexture, roughnessMap };
}

export function BronzeBorder({
  borderName,
  plaqueWidth,
  plaqueHeight,
  unitsPerMeter,
  frontZ,
  color,
  depth,
}: BronzeBorderProps) {
  const unitScale = Math.max(1e-6, Math.abs(unitsPerMeter) || 1);
  const localWidth = Math.max(1e-3, Math.abs(plaqueWidth) * unitScale);
  const localHeight = Math.max(1e-3, Math.abs(plaqueHeight) * unitScale);

  const normalizedName = borderName?.toLowerCase() ?? '';
  const effectiveName = normalizedName.includes('no border') ? null : borderName;
  const slug = effectiveName ? toBorderSlug(effectiveName) : null;
  const resolvedSlug = slug ? `${slug}a` : null;
  const usesIntegratedRails = Boolean(resolvedSlug);
  const shouldRender = Boolean(resolvedSlug && localWidth > 0 && localHeight > 0);

  const bronzeTextures = useMemo(() => createBronzeTextures(color), [color]);
  const groupRef = useRef<THREE.Group>(null);
  
  // Debounce State
  const [debouncedDims, setDebouncedDims] = useState({ w: localWidth, h: localHeight });
  const [isResizing, setIsResizing] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Handle Resize Debouncing
  useEffect(() => {
    setIsResizing(true);
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    
    // While resizing, we just scale the group (in the render loop/ref)
    // We only trigger a full geometry rebuild after 150ms of silence
    timeoutRef.current = setTimeout(() => {
      setDebouncedDims({ w: localWidth, h: localHeight });
      setIsResizing(false);
    }, 150);

    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, [localWidth, localHeight]);

  // Visual scaling during resize (Fast Path)
  useEffect(() => {
    if (groupRef.current && isResizing) {
      // Approximate scaling to keep the border visually responsive
      // This distorts the butterflies slightly during drag, but keeps 60fps
      const currentScaleX = localWidth / debouncedDims.w;
      const currentScaleY = localHeight / debouncedDims.h;
      groupRef.current.scale.set(currentScaleX, currentScaleY, 1);
    } else if (groupRef.current && !isResizing) {
      // Reset scale when geometry is rebuilt
      groupRef.current.scale.set(1, 1, 1);
    }
  }, [localWidth, localHeight, isResizing, debouncedDims]);


  const [svgData, setSvgData] = useState<SVGResult | null>(null);
  const [borderMesh, setBorderMesh] = useState<THREE.Mesh | null>(null);

  useEffect(() => {
    return () => {
      bronzeTextures?.map.dispose();
      bronzeTextures?.roughnessMap.dispose();
    };
  }, [bronzeTextures]);

  useEffect(() => {
    if (!resolvedSlug) {
      setSvgData(null);
      return;
    }

    // Check memory cache first
    if (GEOMETRY_CACHE.has(resolvedSlug)) {
       // We have the geometry, but we need SVG data structure for logic? 
       // Actually we can skip SVG loading if we cache the base geometry.
       // For now, let's just stick to the SVG loader pattern but optimizing the extrude.
    }

    const loader = new SVGLoader();
    loader.load(
      `/shapes/borders/${resolvedSlug}.svg`,
      (data) => setSvgData(data),
      undefined,
      (err) => console.warn(err)
    );
  }, [resolvedSlug]);

  useEffect(() => {
    if (!shouldRender || !svgData) {
      setBorderMesh(null);
      return;
    }

    // --- HEAVY COMPUTATION ---
    // This now only runs when `debouncedDims` changes (user stops dragging)
    const result = buildBorderMesh(svgData, {
      plaqueWidth: debouncedDims.w,
      plaqueHeight: debouncedDims.h,
      depth,
      color,
      frontZ,
      textures: bronzeTextures ?? undefined,
      integratedRails: usesIntegratedRails,
      slug: resolvedSlug || ''
    });

    if (result) {
      setBorderMesh(result);
    }
    
    return () => {
      if (result) {
        result.geometry.dispose();
        // Don't dispose material here if shared, but here it's unique per build
        if (result.material instanceof THREE.Material) result.material.dispose();
      }
    };
  }, [svgData, shouldRender, debouncedDims, depth, color, frontZ, bronzeTextures, resolvedSlug]);

  if (!borderMesh) return null;

  return <primitive object={borderMesh} ref={groupRef} />;
}

function toBorderSlug(name: string) {
  const normalized = name.toLowerCase().replace(/[^a-z0-9]/g, '');
  const alias = BORDER_SLUG_ALIASES[normalized];
  if (alias) return alias;
  const match = name.match(/\d+/);
  return match ? `border${match[0]}` : normalized || 'border1';
}

function buildBorderMesh(
  data: SVGResult,
  params: {
    plaqueWidth: number;
    plaqueHeight: number;
    depth: number;
    color: string;
    frontZ: number;
    textures?: BronzeTextures;
    integratedRails?: boolean;
    slug: string;
  },
): THREE.Mesh | null {
  const { plaqueWidth, plaqueHeight, color, frontZ, textures, integratedRails, slug } = params;
  const width = Math.max(1e-3, Math.abs(plaqueWidth));
  const height = Math.max(1e-3, Math.abs(plaqueHeight));

  const reliefDepthBase = Math.max(0.001, Math.min(width, height) * 0.003);
  const reliefDepth = reliefDepthBase * BORDER_RELIEF_SCALE;

  // 1. Get Base Geometry (Cached or New)
  let baseGeometry = GEOMETRY_CACHE.get(slug);

  if (!baseGeometry) {
    const extrudeSettings = {
      depth: reliefDepth,
      bevelEnabled: true,
      bevelSegments: 1, // Reduced segments for performance
      bevelSize: reliefDepth * 0.35,
      bevelThickness: reliefDepth * 0.35,
      steps: 1,
      curveSegments: 12, // Reduced from 24
    };

    const shapes: THREE.Shape[] = [];
    data.paths.forEach((path) => {
      shapes.push(...SVGLoader.createShapes(path));
    });

    if (shapes.length === 0) return null;

    const rawGeom = new THREE.ExtrudeGeometry(shapes, extrudeSettings);
    baseGeometry = normalizeGeometry(rawGeom);
    
    // Center the base geometry
    baseGeometry.computeBoundingBox();
    const bb = baseGeometry.boundingBox!;
    const cx = (bb.max.x + bb.min.x) / 2;
    const cy = (bb.max.y + bb.min.y) / 2;
    baseGeometry.translate(-cx, -cy, 0);

    GEOMETRY_CACHE.set(slug, baseGeometry);
  }

  // Clone base for manipulation
  const merged = baseGeometry.clone();

  // 2. Scaling Logic
  const bb = merged.boundingBox || new THREE.Box3(); // Should be cached actually
  if (!merged.boundingBox) merged.computeBoundingBox();
  const originalWidth = merged.boundingBox!.max.x - merged.boundingBox!.min.x;
  const originalHeight = merged.boundingBox!.max.y - merged.boundingBox!.min.y;

  const edgeThicknessBase = Math.max(0.01, Math.min(width, height) * 0.02 * BORDER_SCALE);
  const edgeThickness = edgeThicknessBase * BORDER_THICKNESS_SCALE;
  const lineThickness = edgeThickness * 0.4;

  if (integratedRails) {
    // Keep scale logic simple
    const uniformScale = Math.min(width / originalWidth, height / originalHeight);
    merged.scale(uniformScale, uniformScale, 1);
  } else {
    const targetCornerSpan = Math.max(lineThickness * 6, Math.min(width, height) * 0.25);
    const baseScale = (targetCornerSpan / Math.max(originalWidth, originalHeight)) * 0.7;
    merged.scale(baseScale, baseScale, 1);
  }

  const textureRepeatX = Math.max(1, width / 120);
  const textureRepeatY = Math.max(1, height / 120);

  const material = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(color),
    metalness: 0.95,
    roughness: 0.28,
    envMapIntensity: 1.5,
    side: THREE.DoubleSide,
  });

  if (textures?.map) {
    textures.map.repeat.set(textureRepeatX, textureRepeatY);
    material.map = textures.map;
  }
  if (textures?.roughnessMap) {
    textures.roughnessMap.repeat.set(textureRepeatX, textureRepeatY);
    material.roughnessMap = textures.roughnessMap;
  }

  const cornerParts: THREE.BufferGeometry[] = [];
  const SURFACE_Z = frontZ + 0.0001;

  const createCornerMesh = (
    alignX: 'left' | 'right',
    alignY: 'top' | 'bottom',
  ) => {
    let geom = merged.clone();

    // Orientation
    const flipX = alignX === 'right';
    const flipY = alignY === 'top';
    if (flipX) geom.scale(-1, 1, 1);
    if (flipY) geom.scale(1, -1, 1);

    // Fix Winding Order if flipped asymmetrically
    if (flipX !== flipY) {
      const pos = geom.getAttribute('position');
      for (let i = 0; i < pos.count; i += 3) {
        const x2 = pos.getX(i + 1), y2 = pos.getY(i + 1), z2 = pos.getZ(i + 1);
        const x3 = pos.getX(i + 2), y3 = pos.getY(i + 2), z3 = pos.getZ(i + 2);
        pos.setXYZ(i + 1, x3, y3, z3);
        pos.setXYZ(i + 2, x2, y2, z2);
      }
    }

    geom = normalizeGeometry(geom);
    geom.computeBoundingBox();
    const bounds = geom.boundingBox!;
    const posX = alignX === 'left' ? -width / 2 - bounds.min.x : width / 2 - bounds.max.x;
    const posY = alignY === 'top' ? height - bounds.max.y : 0 - bounds.min.y;
    geom.translate(posX, posY, SURFACE_Z);
    
    // UV Fix
    const posAttr = geom.getAttribute('position');
    const uvs = geom.getAttribute('uv');
    for (let i = 0; i < posAttr.count; i++) {
        uvs.setXY(i, posAttr.getX(i), posAttr.getY(i));
    }

    // --- Optimized Slicing with Buffer ---
    // We add OVERLAP_BUFFER to the limit to ensure slight overlap at seams
    
    // X Cut
    if (alignX === 'left') {
      // Keep x < +buffer
      geom = sliceGeometryAxis(geom, 'x', OVERLAP_BUFFER, 'less');
    } else {
      // Keep x > -buffer
      geom = sliceGeometryAxis(geom, 'x', -OVERLAP_BUFFER, 'greater');
    }

    // Y Cut
    if (alignY === 'top') {
      // Keep y > center - buffer
      geom = sliceGeometryAxis(geom, 'y', (height / 2) - OVERLAP_BUFFER, 'greater');
    } else {
      // Keep y < center + buffer
      geom = sliceGeometryAxis(geom, 'y', (height / 2) + OVERLAP_BUFFER, 'less');
    }

    geom.computeVertexNormals();
    cornerParts.push(geom);
  };

  createCornerMesh('left', 'top');
  createCornerMesh('right', 'top');
  createCornerMesh('left', 'bottom');
  createCornerMesh('right', 'bottom');

  if (cornerParts.length === 0) return null;

  const finalGeom = mergeGeometries(cornerParts, false);
  merged.dispose(); // Dispose the template
  cornerParts.forEach(g => g.dispose()); // Dispose parts

  const mesh = new THREE.Mesh(finalGeom, material);
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  mesh.renderOrder = 3;

  return mesh;
}